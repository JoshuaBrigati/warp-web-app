// Generated by dts-bundle-generator v9.3.1

import { MsgWithdrawValidatorCommission as MsgWithdrawValidatorCommission_pb } from '@terra-money/legacy.proto/cosmos/distribution/v1beta1/tx';
import { ParamChange as ParamChange_pb } from '@terra-money/legacy.proto/cosmos/params/v1beta1/params';
import { SignMode as SignModeV1 } from '@terra-money/legacy.proto/cosmos/tx/signing/v1beta1/signing';
import { OrderBy as OrderBy_pb } from '@terra-money/legacy.proto/cosmos/tx/v1beta1/service';
import { CancelSoftwareUpgradeProposal as CancelSoftwareUpgradeProposal_pb, SoftwareUpgradeProposal as SoftwareUpgradeProposal_pb } from '@terra-money/legacy.proto/cosmos/upgrade/v1beta1/upgrade';
import { Any } from '@terra-money/legacy.proto/google/protobuf/any';
import { DenomTrace as DenomTrace_pb } from '@terra-money/legacy.proto/ibc/applications/transfer/v1/transfer';
import { LazyGradedVestingAccount as LazyGradedVestingAccount_pb, Schedule as Schedule_pb, VestingSchedule as VestingSchedule_pb } from '@terra-money/legacy.proto/terra/vesting/v1beta1/vesting';
import { MsgClearContractAdmin as MsgClearContractAdmin_legacy_pb, MsgExecuteContract as MsgExecuteContract_legacy_pb, MsgInstantiateContract as MsgInstantiateContract_legacy_pb, MsgMigrateCode as MsgMigrateCode_legacy_pb, MsgMigrateContract as MsgMigrateContract_legacy_pb, MsgStoreCode as MsgStoreCode_legacy_pb, MsgUpdateContractAdmin as MsgUpdateContractAdmin_legacy_pb } from '@terra-money/legacy.proto/terra/wasm/v1beta1/tx';
import { RewardWeightRange } from '@terra-money/terra.proto/alliance/alliance';
import { MsgCreateAlliance as MsgCreateAlliance_pb, MsgDeleteAlliance as MsgDeleteAlliance_pb, MsgUpdateAlliance as MsgUpdateAlliance_pb } from '@terra-money/terra.proto/alliance/alliance/tx';
import { MsgCreateAllianceProposal as MsgCreateAllianceProposal_pb, MsgDeleteAllianceProposal as MsgDeleteAllianceProposal_pb, MsgUpdateAllianceProposal as MsgUpdateAllianceProposal_pb } from '@terra-money/terra.proto/alliance/gov';
import { MsgClaimDelegationRewards as MsgClaimDelegationRewards_pb, MsgDelegate as MsgDelegate_pb$1, MsgRedelegate as MsgRedelegate_pb, MsgUndelegate as MsgUndelegate_pb$1 } from '@terra-money/terra.proto/alliance/tx';
import { BaseAccount as BaseAccount_pb, ModuleAccount as ModuleAccount_pb } from '@terra-money/terra.proto/cosmos/auth/v1beta1/auth';
import { GenericAuthorization as GenericAuthorization_pb, Grant as Grant_pb } from '@terra-money/terra.proto/cosmos/authz/v1beta1/authz';
import { MsgExec as MsgExec_pb, MsgGrant as MsgGrant_pb, MsgRevoke as MsgRevoke_pb } from '@terra-money/terra.proto/cosmos/authz/v1beta1/tx';
import { SendAuthorization as SendAuthorization_pb } from '@terra-money/terra.proto/cosmos/bank/v1beta1/authz';
import { Input as Input_pb, Metadata, Output as Output_pb } from '@terra-money/terra.proto/cosmos/bank/v1beta1/bank';
import { MsgMultiSend as MsgMultiSend_pb, MsgSend as MsgSend_pb } from '@terra-money/terra.proto/cosmos/bank/v1beta1/tx';
import { ABCIMessageLog as ABCIMessageLog_pb, TxResponse as TxResponse_pb } from '@terra-money/terra.proto/cosmos/base/abci/v1beta1/abci';
import { Coin as Coin_pb } from '@terra-money/terra.proto/cosmos/base/v1beta1/coin';
import { MsgVerifyInvariant as MsgVerifyInvariant_pb } from '@terra-money/terra.proto/cosmos/crisis/v1beta1/tx';
import { LegacyAminoPubKey as LegacyAminoPubKey_pb } from '@terra-money/terra.proto/cosmos/crypto/multisig/keys';
import { CompactBitArray as CompactBitArray_pb } from '@terra-money/terra.proto/cosmos/crypto/multisig/v1beta1/multisig';
import { PubKey as PubKey_pb } from '@terra-money/terra.proto/cosmos/crypto/secp256k1/keys';
import { CommunityPoolSpendProposal as CommunityPoolSpendProposal_pb } from '@terra-money/terra.proto/cosmos/distribution/v1beta1/distribution';
import { MsgFundCommunityPool as MsgFundCommunityPool_pb, MsgSetWithdrawAddress as MsgSetWithdrawAddress_pb, MsgWithdrawDelegatorReward as MsgWithdrawDelegatorReward_pb } from '@terra-money/terra.proto/cosmos/distribution/v1beta1/tx';
import { AllowedMsgAllowance as AllowedMsgAllowance_pb, BasicAllowance as BasicAllowance_pb, PeriodicAllowance as PeriodicAllowance_pb } from '@terra-money/terra.proto/cosmos/feegrant/v1beta1/feegrant';
import { MsgGrantAllowance as MsgGrantAllowance_pb, MsgRevokeAllowance as MsgRevokeAllowance_pb } from '@terra-money/terra.proto/cosmos/feegrant/v1beta1/tx';
import { DepositParams, Proposal as Proposal_pb$1, ProposalStatus as ProposalStatus$1, TallyParams, Vote as Vote_pb$1, VoteOption as VoteOption$1, VotingParams, WeightedVoteOption as WeightedVoteOption_pb$1 } from '@terra-money/terra.proto/cosmos/gov/v1/gov';
import { MsgDeposit as MsgDeposit_pb, MsgExecLegacyContent as MsgExecLegacyContent_pb, MsgSubmitProposal as MsgSubmitProposal_pb, MsgVote as MsgVote_pb, MsgVoteWeighted as MsgVoteWeighted_pb } from '@terra-money/terra.proto/cosmos/gov/v1/tx';
import { Deposit as Deposit_pb, Proposal as Proposal_pb, ProposalStatus, TextProposal as TextProposal_pb, Vote as Vote_pb, VoteOption, WeightedVoteOption as WeightedVoteOption_pb } from '@terra-money/terra.proto/cosmos/gov/v1beta1/gov';
import { MsgDeposit as MsgDeposit_pb$1, MsgSubmitProposal as MsgSubmitProposal_pb$1, MsgVote as MsgVote_pb$1, MsgVoteWeighted as MsgVoteWeighted_pb$1 } from '@terra-money/terra.proto/cosmos/gov/v1beta1/tx';
import { ParameterChangeProposal as ParameterChangeProposal_pb } from '@terra-money/terra.proto/cosmos/params/v1beta1/params';
import { MsgUnjail as MsgUnjail_pb } from '@terra-money/terra.proto/cosmos/slashing/v1beta1/tx';
import { AuthorizationType, StakeAuthorization as StakeAuthorization_pb, StakeAuthorization_Validators as StakeAuthorizationValidators_pb } from '@terra-money/terra.proto/cosmos/staking/v1beta1/authz';
import { BondStatus, Commission as Commission_pb, CommissionRates as CommissionRates_pb, DelegationResponse as DelegationResponse_pb, Description as Description_pb, RedelegationEntryResponse as RedelegationEntryResponse_pb, RedelegationResponse as RedelegationResponse_pb, UnbondingDelegation as UnbondingDelegation_pb, UnbondingDelegationEntry as UnbondingDelegationEntry_pb, Validator as Validator_pb } from '@terra-money/terra.proto/cosmos/staking/v1beta1/staking';
import { MsgBeginRedelegate as MsgBeginRedelegate_pb, MsgCancelUnbondingDelegation as MsgCancelUnbondingDelegation_pb, MsgCreateValidator as MsgCreateValidator_pb, MsgDelegate as MsgDelegate_pb, MsgEditValidator as MsgEditValidator_pb, MsgUndelegate as MsgUndelegate_pb } from '@terra-money/terra.proto/cosmos/staking/v1beta1/tx';
import { SignMode, SignMode as SignModeV2, SignMode as SignMode_pb } from '@terra-money/terra.proto/cosmos/tx/signing/v1beta1/signing';
import { AuthInfo as AuthInfo_pb, Fee as Fee_pb, ModeInfo as ModeInfo_pb, ModeInfo_Multi as ModeInfoMulti_pb, ModeInfo_Single as ModeInfoSingle_pb, SignDoc as SignDoc_pb, SignerInfo as SignerInfo_pb, Tx as Tx_pb, TxBody as TxBody_pb } from '@terra-money/terra.proto/cosmos/tx/v1beta1/tx';
import { Plan as Plan_pb } from '@terra-money/terra.proto/cosmos/upgrade/v1beta1/upgrade';
import { MsgCreatePeriodicVestingAccount as MsgCreatePeriodicVestingAccount_pb, MsgCreateVestingAccount as MsgCreateVestingAccount_pb, MsgDonateAllVestingTokens as MsgDonateAllVestingTokens_pb } from '@terra-money/terra.proto/cosmos/vesting/v1beta1/tx';
import { BaseVestingAccount as BaseVestingAccount_pb, ContinuousVestingAccount as ContinuousVestingAccount_pb, DelayedVestingAccount as DelayedVestingAccount_pb, Period as Period_pb, PeriodicVestingAccount as PeriodicVestingAccount_pb } from '@terra-money/terra.proto/cosmos/vesting/v1beta1/vesting';
import { AccessConfigUpdate as AccessConfigUpdate_pb, ClearAdminProposal as ClearAdminProposal_pb, ExecuteContractProposal as ExecuteContractProposal_pb, InstantiateContractProposal as InstantiateContractProposal_pb, MigrateContractProposal as MigrateContractProposal_pb, PinCodesProposal as PinCodesProposal_pb, StoreCodeProposal as StoreCodeProposal_pb, SudoContractProposal as SudoContractProposal_pb, UnpinCodesProposal as UnpinCodesProposal_pb, UpdateAdminProposal as UpdateAdminProposal_pb, UpdateInstantiateConfigProposal as UpdateInstantiateConfigProposal_pb } from '@terra-money/terra.proto/cosmwasm/wasm/v1/proposal';
import { MsgClearAdmin as MsgClearAdmin_pb, MsgExecuteContract as MsgExecuteContract_pb, MsgInstantiateContract as MsgInstantiateContract_pb, MsgMigrateContract as MsgMigrateContract_pb, MsgStoreCode as MsgStoreCode_pb, MsgUpdateAdmin as MsgUpdateAdmin_pb } from '@terra-money/terra.proto/cosmwasm/wasm/v1/tx';
import { AbsoluteTxPosition as AbsoluteTxPosition_pb, AccessConfig as AccessConfig_pb, AccessType, AccessTypeParam as AccessTypeParam_pb, ContractCodeHistoryEntry as HistoryEntry_pb, ContractCodeHistoryOperationType, Params } from '@terra-money/terra.proto/cosmwasm/wasm/v1/types';
import { Any as Any$1 } from '@terra-money/terra.proto/google/protobuf/any';
import { Duration } from '@terra-money/terra.proto/google/protobuf/duration';
import { Params as ControllerParams } from '@terra-money/terra.proto/ibc/applications/interchain_accounts/controller/v1/controller';
import { QueryInterchainAccountResponse } from '@terra-money/terra.proto/ibc/applications/interchain_accounts/controller/v1/query';
import { MsgRegisterInterchainAccount as MsgRegisterInterchainAccount_pb, MsgSendTx as MsgSendTx_pb } from '@terra-money/terra.proto/ibc/applications/interchain_accounts/controller/v1/tx';
import { Params as HostParams, Params as Params_pb } from '@terra-money/terra.proto/ibc/applications/interchain_accounts/host/v1/host';
import { CosmosTx as CosmosTx_pb, InterchainAccountPacketData as InterchainAccountPacketData_pb, Type } from '@terra-money/terra.proto/ibc/applications/interchain_accounts/v1/packet';
import { MsgTransfer as MsgTransfer_pb } from '@terra-money/terra.proto/ibc/applications/transfer/v1/tx';
import { FungibleTokenPacketData as FungibleTokenPacketData_pb } from '@terra-money/terra.proto/ibc/applications/transfer/v2/packet';
import { Channel as Channel_pb, Counterparty as Counterparty_pb$1, IdentifiedChannel as IdentifiedChannel_pb, Order, Packet as Packet_pb, State as State$1 } from '@terra-money/terra.proto/ibc/core/channel/v1/channel';
import { MsgAcknowledgement as MsgAcknowledgement_pb, MsgChannelCloseConfirm as MsgChannelCloseConfirm_pb, MsgChannelCloseInit as MsgChannelCloseInit_pb, MsgChannelOpenAck as MsgChannelOpenAck_pb, MsgChannelOpenConfirm as MsgChannelOpenConfirm_pb, MsgChannelOpenInit as MsgChannelOpenInit_pb, MsgChannelOpenTry as MsgChannelOpenTry_pb, MsgRecvPacket as MsgRecvPacket_pb, MsgTimeout as MsgTimeout_pb, MsgTimeoutOnClose as MsgTimeoutOnClose_pb } from '@terra-money/terra.proto/ibc/core/channel/v1/tx';
import { ClientConsensusStates as ClientConsensusStates_pb, ClientUpdateProposal as ClientUpdateProposal_pb, ConsensusStateWithHeight as ConsensusStateWithHeight_pb, Height as Height_pb, IdentifiedClientState as IdentifiedClientState_pb } from '@terra-money/terra.proto/ibc/core/client/v1/client';
import { MsgCreateClient as MsgCreateClient_pb, MsgSubmitMisbehaviour as MsgSubmitMisbehaviour_pb, MsgUpdateClient as MsgUpdateClient_pb, MsgUpgradeClient as MsgUpgradeClient_pb } from '@terra-money/terra.proto/ibc/core/client/v1/tx';
import { MerklePrefix as MerklePrefix_pb } from '@terra-money/terra.proto/ibc/core/commitment/v1/commitment';
import { Counterparty as Counterparty_pb, IdentifiedConnection as IdentifiedConnection_pb, State, Version as Version_pb } from '@terra-money/terra.proto/ibc/core/connection/v1/connection';
import { MsgConnectionOpenAck as MsgConnectionOpenAck_pb, MsgConnectionOpenConfirm as MsgConnectionOpenConfirm_pb, MsgConnectionOpenInit as MsgConnectionOpenInit_pb, MsgConnectionOpenTry as MsgConnectionOpenTry_pb } from '@terra-money/terra.proto/ibc/core/connection/v1/tx';
import { Params as Params$4 } from '@terra-money/terra.proto/icq/v1/icq';
import { Params as Params$2 } from '@terra-money/terra.proto/juno/feeshare/v1/genesis';
import { QueryFeeSharesResponse } from '@terra-money/terra.proto/juno/feeshare/v1/query';
import { MsgCancelFeeShare as MsgCancelFeeShare_pb, MsgRegisterFeeShare as MsgRegisterFeeShare_pb, MsgUpdateFeeShare as MsgUpdateFeeShare_pb } from '@terra-money/terra.proto/juno/feeshare/v1/tx';
import { QueryParamsResponse } from '@terra-money/terra.proto/osmosis/tokenfactory/v1beta1/query';
import { MsgBurn as MsgBurn_pb, MsgChangeAdmin as MsgChangeAdmin_pb, MsgCreateDenom as MsgCreateDenom_pb, MsgForceTransfer as MsgForceTransfer_pb, MsgMint as MsgMint_pb, MsgSetBeforeSendHook as MsgSetBeforeSendHook_pb, MsgSetDenomMetadata as MsgSetDenomMetadata_pb } from '@terra-money/terra.proto/osmosis/tokenfactory/v1beta1/tx';
import { Params as Params$1 } from '@terra-money/terra.proto/pob/builder/v1/genesis';
import { MsgAuctionBid as MsgAuctionBid_pb } from '@terra-money/terra.proto/pob/builder/v1/tx';
import Decimal from 'decimal.js';
import { EventEmitter } from 'events';
import Long$1 from 'long';

export interface BlockInfo {
	block_id: BlockID;
	block: Block;
}
export interface Block {
	header: Header;
	data: {
		txs: string[] | null;
	};
	evidence: Evidence;
	last_commit: LastCommit;
}
export interface Evidence {
	evidence: string[];
}
export interface Header {
	version: Version;
	/** blockchain ID */
	chain_id: string;
	/** block's height */
	height: string;
	/** time the block was included */
	time: string;
	last_block_id: BlockID;
	last_commit_hash: string;
	data_hash: string;
	validators_hash: string;
	next_validators_hash: string;
	consensus_hash: string;
	app_hash: string;
	last_results_hash: string;
	evidence_hash: string;
	proposer_address: string;
}
export interface BlockID {
	hash: string;
	part_set_header: Parts;
}
export interface Parts {
	total: string;
	hash: string;
}
export interface Version {
	block: string;
	app: string;
}
export interface LastCommit {
	height: string;
	round: number;
	block_id: BlockID;
	signatures: Signature[];
}
export interface Signature {
	block_id_flag: number;
	validator_address: string;
	timestamp: string;
	signature: string;
}
declare abstract class JSONSerializable<A, D, P> {
	abstract toAmino(isClassic?: boolean): A;
	abstract toData(isClassic?: boolean): D;
	abstract toProto(isClassic?: boolean): P;
	toJSON(isClassic?: boolean): string;
	toAminoJSON(isClassic?: boolean): string;
}
export type Denom = string;
export declare const DEC_PRECISION = 18;
export interface Numeric<T> {
	add(other: any): T;
	sub(other: any): T;
	mul(other: any): T;
	div(other: any): T;
	mod(other: any): T;
}
export declare namespace Numeric {
	type Input = Decimal.Value;
	type Output = Int | Dec;
	function parse(value: Input): Output;
}
/**
 * Represents decimal values serialized with 18 digits of precision. This implementation
 * is based on the `decimal.js` library, and returns Dec values for only [[Dec.add]],
 * [[Dec.sub]], [[Dec.mul]], [[Dec.div]], and [[Dec.mod]]. For other methods inherited
 * from `Decimal`, you will need to convert back to `Dec` to remain compatible for
 * submitting information that requires `Dec` format back to the blockchain.
 *
 * Example:
 *
 * ```ts
 * const dec = new Dec(1.5);
 *
 * const decimal = dec.sqrt();
 * const dec2 = new Dec(decimal);
 */
export declare class Dec extends Decimal implements Numeric<Dec> {
	constructor(arg?: Numeric.Input);
	toString(): string;
	static withPrec(value: Decimal.Value, prec: number): Dec;
	toInt(): Int;
	add(other: Numeric.Input): Dec;
	sub(other: Numeric.Input): Dec;
	mul(other: Numeric.Input): Dec;
	div(other: Numeric.Input): Dec;
	mod(other: Numeric.Input): Dec;
}
declare const _Int: typeof Decimal;
/**
 * Represents Integer values. Used mainly to store integer values of [[Coin]] and [[Coins]].
 *
 * Note: Do not use to work with values greater than 9999999999999999999. This
 * implementation is based on the `decimal.js` library, and returns Int values for only
 * [[Int.add]], [[Int.sub]], [[Int.mul]], [[Int.div]], and [[Int.mod]]. For other
 * methods inherited from `Decimal`, you will need to convert back to `Int` to remain
 * compatible for submitting information that requires `Int` format back to the
 * blockchain.
 *
 * Example:
 *
 * ```ts
 * const int = new Int(1.5);
 *
 * const decimal = int.pow(3);
 * const int2 = new Int(decimal);
 */
export declare class Int extends _Int implements Numeric<Numeric.Output> {
	constructor(arg?: Numeric.Input);
	toString(): string;
	toDec(): Dec;
	add(other: Numeric.Input): Numeric.Output;
	sub(other: Numeric.Input): Numeric.Output;
	mul(other: Numeric.Input): Numeric.Output;
	div(other: Numeric.Input): Numeric.Output;
	mod(other: Numeric.Input): Numeric.Output;
}
/**
 * Template tagged literal for creating new Dec objects out of literal string.
 * This does not support literal string interpolation  with `${}`.
 *
 * Usage is:
 *
 * ```ts
 * import { dec } from "@terra-money/terra.js";
 *
 * const dec1 = dec`234.12312`;
 * const dec2 = new Dec("234.12312");
 *
 * dec1.equals(dec2);
 * ```
 * @param strings
 */
export declare function dec(strings: TemplateStringsArray): Dec;
/**
 * Template tagged literal for creating new Int objects out of literal string.
 * This does not support literal string interpolation  with `${}`.
 *
 * Usage is:
 *
 * ```ts
 * import { int } from "@terra-money/terra.js";
 *
 * const int1 = int`234`;
 * const int2 = new Int("234");
 *
 * int1.equals(int2);
 * ```
 * @param strings
 */
export declare function int(strings: TemplateStringsArray): Int;
/**
 * Captures `sdk.Coin` and `sdk.DecCoin` from Cosmos SDK. A composite value that combines
 * a denomination with an amount value. Coins are immutable once created, and operations
 * that return Coin will return a new Coin. See [[Coins]] for a collection of Coin objects.
 */
export declare class Coin extends JSONSerializable<Coin.Amino, Coin.Data, Coin.Proto> implements Numeric<Coin> {
	readonly denom: Denom;
	readonly amount: Numeric.Output;
	/**
	 * Creates a new coin. Depending on the type of amount, it will be converted to an
	 * integer coin or decimal coin.
	 *
	 * @param denom denomination
	 * @param amount coin's amount
	 */
	constructor(denom: Denom, amount: Numeric.Input);
	/**
	 * Checks whether the Coin is an Integer coin.
	 */
	isIntCoin(): boolean;
	/**
	 * Checks whether the Coin is a Decimal coin.
	 */
	isDecCoin(): boolean;
	/**
	 * Turns the Coin into an Integer coin.
	 */
	toIntCoin(): Coin;
	/**
	 * Turns the Coin into an Integer coin with ceiling the amount.
	 */
	toIntCeilCoin(): Coin;
	/**
	 * Turns the Coin into a Decimal coin.
	 */
	toDecCoin(): Coin;
	/**
	 * Outputs `<amount><denom>`.
	 *
	 * Eg: `Coin('uluna', 1500) -> 1500uluna`
	 */
	toString(): string;
	static fromString(str: string): Coin;
	/**
	 * Creates a new Coin adding to the current value.
	 *
	 * @param other
	 */
	add(other: Numeric.Input | Coin): Coin;
	/**
	 * Creates a new Coin subtracting from the current value.
	 * @param other
	 */
	sub(other: Numeric.Input | Coin): Coin;
	/**
	 * Multiplies the current value with an amount.
	 * @param other
	 */
	mul(other: Numeric.Input): Coin;
	/**
	 * Divides the current value with an amount.
	 * @param other
	 */
	div(other: Numeric.Input): Coin;
	/**
	 * Modulo the current value with an amount.
	 * @param other
	 */
	mod(other: Numeric.Input): Coin;
	static fromAmino(data: Coin.Amino): Coin;
	toAmino(): Coin.Amino;
	static fromData(data: Coin.Data): Coin;
	toData(): Coin.Data;
	static fromProto(proto: Coin.Proto): Coin;
	toProto(): Coin.Proto;
}
export declare namespace Coin {
	interface Amino {
		denom: Denom;
		amount: string;
	}
	interface Data {
		denom: Denom;
		amount: string;
	}
	class ArithmeticError {
		readonly message: string;
		constructor(message: string);
	}
	type Proto = Coin_pb;
}
/**
 * Analagous to `sdk.Coins` and `sdk.DecCoins` from Cosmos-SDK, and represents a collection
 * of [[Coin]] objects.
 *
 */
export declare class Coins extends JSONSerializable<Coins.Amino, Coins.Data, Coins.Proto> implements Numeric<Coins>, Iterable<Coin.Data> {
	private _coins;
	[Symbol.iterator](): {
		next: () => {
			value: Coin;
			done: true;
		};
	};
	/**
	 * Converts the Coins information to a comma-separated list.
	 *
	 * Eg: `15000ukrw,12000uluna`
	 */
	toString(): string;
	/**
	 * Converts a comma-separated list of coins to a Coins object
	 *
	 * Eg. `1500ukrw,12302uluna`
	 *
	 * @param str comma-separated list of coins
	 */
	static fromString(str: string): Coins;
	/**
	 * Gets the list of denominations
	 */
	denoms(): Denom[];
	/**
	 * Creates a new Coins object with all Decimal coins
	 */
	toDecCoins(): Coins;
	/**
	 * Creates a new Coins object with all Integer coins
	 */
	toIntCoins(): Coins;
	/**
	 * Creates a new Coins object with all Integer coins with ceiling the amount
	 */
	toIntCeilCoins(): Coins;
	/**
	 * @param arg coins to input
	 */
	constructor(arg?: Coins.Input);
	/**
	 * Gets the Coin for denomination if it exists in the collection.
	 * @param denom denomination to lookup
	 */
	get(denom: Denom): Coin | undefined;
	/**
	 * Sets the Coin value for a denomination.
	 * @param denom denomination to set
	 * @param value value to set
	 */
	set(denom: Denom, value: Numeric.Input | Coin): void;
	/**
	 * Gets the individual elements of the collection.
	 */
	toArray(): Coin[];
	/**
	 * Adds a value from the elements of the collection. Coins of a similar denomination
	 * will be clobbered into one value containing their sum.
	 * @param other
	 */
	add(other: Coin | Coins): Coins;
	/**
	 * Subtracts a value from the elements of the collection.
	 * @param other
	 */
	sub(other: Coin | Coins): Coins;
	/**
	 * Multiplies the elements of the collection by a value.
	 * @param other
	 */
	mul(other: Numeric.Input): Coins;
	/**
	 * Divides the elements of the collection by a value.
	 * @param other
	 */
	div(other: Numeric.Input): Coins;
	/**
	 * Modulos the elements of the collection with a value.
	 * @param other
	 */
	mod(other: Numeric.Input): Coins;
	/**
	 * Map a value onto the elements of the Coin collection.
	 * @param fn
	 */
	map<T>(fn: (c: Coin) => T): T[];
	/**
	 * Filters out the Coin objects that don't match the predicate
	 * @param fn predicate
	 */
	filter(fn: (c: Coin) => boolean): Coins;
	/**
	 * Find out the Coin objects that match the predicate
	 * @param fn predicate
	 */
	find(fn: (c: Coin) => boolean): Coin | undefined;
	static fromAmino(data: Coins.Amino | null): Coins;
	toAmino(): Coins.Amino;
	static fromData(data: Coins.Data | null): Coins;
	toData(): Coins.Data;
	static fromProto(data: Coins.Proto | null): Coins;
	toProto(): Coins.Proto;
}
export declare namespace Coins {
	type Input = Coins.AminoDict | Coin[] | Coins | string;
	type Amino = Coin.Amino[];
	type Data = Coin.Data[];
	type Proto = Coin.Proto[];
	type AminoDict = {
		[denom: string]: Numeric.Input;
	};
	type ReprDict = {
		[denom: string]: Coin;
	};
}
/** `terra-` prefixed account address */
export type AccAddress = string;
/** `terravaloper-` prefixed validator operator address */
export type ValAddress = string;
/** `terravalcons-` prefixed validator consensus address */
export type ValConsAddress = string;
/** `terrapub-` prefixed account public key */
export type AccPubKey = string;
/** `terravaloperpub-` prefixed validator public key */
export type ValPubKey = string;
export declare namespace AccAddress {
	/**
	 * Checks if a string is a valid account address.
	 *
	 * @param data string to check
	 * @param prefix expected chain prefix
	 */
	function validate(data: string, prefix?: string): boolean;
	/**
	 * Converts a validator address into an account address
	 *
	 * @param address validator address
	 */
	function fromValAddress(address: ValAddress): AccAddress;
	/**
	 * Get the prefix of an account address
	 *
	 * @param address accont address
	 */
	function getPrefix(address: AccAddress): string;
}
export declare namespace AccPubKey {
	/**
	 * Checks if a string is a valid account's public key
	 * @param data string to check
	 * @param prefix expected chain prefix
	 */
	function validate(data: string, prefix?: string): boolean;
	/**
	 * Converts a validator pubkey to an account pubkey.
	 * @param address validator pubkey to convert
	 * @param prefix expected chain prefix
	 */
	function fromAccAddress(address: AccAddress, prefix: string): AccPubKey;
	/**
	 * Get the prefix of an account public key
	 *
	 * @param address accont address
	 */
	function getPrefix(address: AccPubKey): string;
}
export declare namespace ValAddress {
	/**
	 * Checks if a string is a Terra validator address.
	 *
	 * @param data string to check
	 * @param prefix expected chain prefix
	 */
	function validate(data: string, prefix?: string): boolean;
	/**
	 * Converts a Terra account address to a validator address.
	 * @param address account address to convert
	 * @param prefix expected chain prefix
	 */
	function fromAccAddress(address: AccAddress, prefix: string): ValAddress;
	/**
	 * Get the prefix of a validator address
	 *
	 * @param address validator address
	 */
	function getPrefix(address: ValAddress): string;
}
export declare namespace ValPubKey {
	/**
	 * Checks if a string is a Terra validator pubkey
	 * @param data string to check
	 * @param prefix expected chain prefix
	 */
	function validate(data: string, prefix?: string): boolean;
	/**
	 * Converts a Terra validator operator address to a validator pubkey.
	 * @param valAddress account pubkey
	 * @param prefix expected chain prefix
	 */
	function fromValAddress(valAddress: ValAddress, prefix: string): ValPubKey;
	/**
	 * Get the prefix of a validator public key
	 *
	 * @param address validator public key
	 */
	function getPrefix(address: ValPubKey): string;
}
export declare namespace ValConsAddress {
	/**
	 * Checks if a string is a Terra validator consensus address
	 * @param data string to check
	 * @param prefix expected chain prefix
	 */
	function validate(data: string, prefix?: string): boolean;
	/**
	 * Get the prefix of a validator consensus address
	 *
	 * @param address validator consensus address
	 */
	function getPrefix(address: ValConsAddress): string;
}
/**
 * A basic message for sending [[Coins]] between Terra accounts.
 */
export declare class MsgSend extends JSONSerializable<MsgSend.Amino, MsgSend.Data, MsgSend.Proto> {
	from_address: AccAddress;
	to_address: AccAddress;
	/**
	 * value of the transaction
	 */
	amount: Coins;
	/**
	 * @param from_address sender's address
	 * @param to_address recipient's address
	 * @param amount value of the transaction
	 */
	constructor(from_address: AccAddress, to_address: AccAddress, amount: Coins.Input);
	static fromAmino(data: MsgSend.Amino, _?: boolean): MsgSend;
	toAmino(isClassic?: boolean): MsgSend.Amino;
	static fromData(data: MsgSend.Data, isClassic?: boolean): MsgSend;
	toData(_?: boolean): MsgSend.Data;
	static fromProto(proto: MsgSend.Proto, _?: boolean): MsgSend;
	toProto(_?: boolean): MsgSend.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): MsgSend;
}
export declare namespace MsgSend {
	interface Amino {
		type: "bank/MsgSend" | "cosmos-sdk/MsgSend";
		value: {
			from_address: AccAddress;
			to_address: AccAddress;
			amount: Coins.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.bank.v1beta1.MsgSend";
		from_address: AccAddress;
		to_address: AccAddress;
		amount: Coins.Data;
	}
	type Proto = MsgSend_pb;
}
/**
 * If you have multiple senders and/or multiple recipients, you can use MsgMultiSend,
 * which can batch together the senders and recipients in one message to save on gas
 * fees.
 *
 * Specify the senders and recipients and their corresponding deposit contribution /
 * receiving amounts with [[MsgMultiSend.Input]] or [[MsgMultiSend.Output]].
 *
 * Example:
 *
 * ```ts
 * import { MsgMultiSend } from "@terra-money/terra.js";
 *
 * const inputs: MsgMultiSend.Input[] = [
 *    new MsgMultiSend.Input(
 *      'terra105rz2q5a4w7nv7239tl9c4px5cjy7axx3axf6p',
 *      {
 *        ukrw: 123123,
 *      })
 *    ),
 *    new MsgMultiSend.Input('terra105rz2q5a4w7nv7239tl9c4px5cjy7axx3axfad', [
 *      new Coin('uluna', 123123),
 *    ]),
 *  ];
 *   const outputs: MsgMultiSend.Output[] = [
 *    new MsgMultiSend.Output(
 *      'terra105rz2q5a4w7nv7239tl9c4px5cjy7axx3axfad',
 *        {
 *          ukrw: 123123,
 *        }
 *    ),
 *    new MsgMultiSend.Output('terra105rz2q5a4w7nv7239tl9c4px5cjy7axx3axfga',
 *      {
 *        uluna: 123123,
 *      }
 *    ),
 *  ];
 *  const multisend = new MsgMultiSend(inputs, outputs);
 * ```
 */
export declare class MsgMultiSend extends JSONSerializable<MsgMultiSend.Amino, MsgMultiSend.Data, MsgMultiSend.Proto> {
	inputs: MsgMultiSend.Input[];
	outputs: MsgMultiSend.Output[];
	/**
	 * @param inputs inputs
	 * @param outputs outputs
	 */
	constructor(inputs: MsgMultiSend.Input[], outputs: MsgMultiSend.Output[]);
	static fromAmino(data: MsgMultiSend.Amino, _?: boolean): MsgMultiSend;
	toAmino(isClassic?: boolean): MsgMultiSend.Amino;
	static fromData(data: MsgMultiSend.Data, _?: boolean): MsgMultiSend;
	toData(_?: boolean): MsgMultiSend.Data;
	static fromProto(proto: MsgMultiSend.Proto, _?: boolean): MsgMultiSend;
	toProto(_?: boolean): MsgMultiSend.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): MsgMultiSend;
}
export declare namespace MsgMultiSend {
	interface Amino {
		readonly type: "bank/MsgMultiSend" | "cosmos-sdk/MsgMultiSend";
		value: {
			inputs: Input.Amino[];
			outputs: Output.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmos.bank.v1beta1.MsgMultiSend";
		inputs: Input.Data[];
		outputs: Output.Data[];
	}
	type Proto = MsgMultiSend_pb;
	class Input extends JSONSerializable<Input.Amino, Input.Data, Input.Proto> {
		address: AccAddress;
		/**
		 * Value of the transaction
		 */
		coins: Coins;
		/**
		 * @param address address
		 * @param coinsInput coins-compatible input
		 */
		constructor(address: AccAddress, coinsInput: Coins.Input);
		toAmino(_?: boolean): Input.Amino;
		static fromAmino(data: Input.Amino, _?: boolean): Input;
		toData(_?: boolean): Input.Data;
		static fromData(data: Input.Data, _?: boolean): Input;
		toProto(_?: boolean): Input.Proto;
		static fromProto(proto: Input.Proto, _?: boolean): Input;
	}
	class Output extends JSONSerializable<Output.Amino, Output.Data, Output.Proto> {
		address: AccAddress;
		/**
		 * Value of the transaction
		 */
		coins: Coins;
		/**
		 * @param address address
		 * @param coinsOutput coins-compatible input
		 */
		constructor(address: AccAddress, coinsInput: Coins.Input);
		toAmino(_?: boolean): Output.Amino;
		static fromAmino(data: Output.Amino, _?: boolean): Output;
		toData(_?: boolean): Output.Data;
		static fromData(data: Output.Data, _?: boolean): Output;
		toProto(_?: boolean): Output.Proto;
		static fromProto(proto: Output.Proto, _?: boolean): Output;
	}
	namespace Input {
		interface Amino {
			address: AccAddress;
			coins: Coins.Amino;
		}
		interface Data {
			address: AccAddress;
			coins: Coins.Data;
		}
		type Proto = Input_pb;
	}
	namespace Output {
		interface Amino {
			address: AccAddress;
			coins: Coins.Amino;
		}
		interface Data {
			address: AccAddress;
			coins: Coins.Data;
		}
		type Proto = Output_pb;
	}
}
export type BankMsg = MsgSend | MsgMultiSend;
export declare namespace BankMsg {
	type Amino = MsgSend.Amino | MsgMultiSend.Amino;
	type Data = MsgSend.Data | MsgMultiSend.Data;
	type Proto = MsgSend.Proto | MsgMultiSend.Proto;
}
/**
 * A validator can withdraw their outstanding commission rewards accrued from all
 * delegations (not including its self-delegation) into their associated account's
 * withdraw address.
 */
export declare class MsgSetWithdrawAddress extends JSONSerializable<MsgSetWithdrawAddress.Amino, MsgSetWithdrawAddress.Data, MsgSetWithdrawAddress.Proto> {
	delegator_address: AccAddress;
	withdraw_address: AccAddress;
	/**
	 * @param delegator_address delegator's account address
	 * @param withdraw_address desired new withdraw address
	 */
	constructor(delegator_address: AccAddress, withdraw_address: AccAddress);
	static fromAmino(data: MsgSetWithdrawAddress.Amino, _?: boolean): MsgSetWithdrawAddress;
	toAmino(isClassic?: boolean): MsgSetWithdrawAddress.Amino;
	static fromData(data: MsgSetWithdrawAddress.Data, _?: boolean): MsgSetWithdrawAddress;
	toData(_?: boolean): MsgSetWithdrawAddress.Data;
	static fromProto(proto: MsgSetWithdrawAddress.Proto, _?: boolean): MsgSetWithdrawAddress;
	toProto(_?: boolean): MsgSetWithdrawAddress.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgSetWithdrawAddress;
}
export declare namespace MsgSetWithdrawAddress {
	interface Amino {
		type: "distribution/MsgModifyWithdrawAddress" | "cosmos-sdk/MsgModifyWithdrawAddress";
		value: {
			delegator_address: AccAddress;
			withdraw_address: AccAddress;
		};
	}
	interface Data {
		"@type": "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress";
		delegator_address: AccAddress;
		withdraw_address: AccAddress;
	}
	type Proto = MsgSetWithdrawAddress_pb;
}
/**
 * A delegator can withdraw currently outstanding rewards accrued from their delegation
 * toward a validator by submitting the following message.
 *
 * The rewards will be deposited to their Withdraw Address.
 */
export declare class MsgWithdrawDelegatorReward extends JSONSerializable<MsgWithdrawDelegatorReward.Amino, MsgWithdrawDelegatorReward.Data, MsgWithdrawDelegatorReward.Proto> {
	delegator_address: AccAddress;
	validator_address: ValAddress;
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_address validator's operator address
	 */
	constructor(delegator_address: AccAddress, validator_address: ValAddress);
	static fromAmino(data: MsgWithdrawDelegatorReward.Amino, _?: boolean): MsgWithdrawDelegatorReward;
	toAmino(isClassic?: boolean): MsgWithdrawDelegatorReward.Amino;
	static fromData(proto: MsgWithdrawDelegatorReward.Data, _?: boolean): MsgWithdrawDelegatorReward;
	toData(_?: boolean): MsgWithdrawDelegatorReward.Data;
	static fromProto(proto: MsgWithdrawDelegatorReward.Proto, _?: boolean): MsgWithdrawDelegatorReward;
	toProto(_?: boolean): MsgWithdrawDelegatorReward.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgWithdrawDelegatorReward;
}
export declare namespace MsgWithdrawDelegatorReward {
	interface Amino {
		type: "distribution/MsgWithdrawDelegationReward" | "cosmos-sdk/MsgWithdrawDelegationReward";
		value: {
			delegator_address: AccAddress;
			validator_address: ValAddress;
		};
	}
	interface Data {
		"@type": "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
		delegator_address: AccAddress;
		validator_address: ValAddress;
	}
	type Proto = MsgWithdrawDelegatorReward_pb;
}
/**
 * A validator can withdraw their outstanding commission rewards accrued from all
 * delegations (not including its self-delegation) into their associated account's
 * withdraw address.
 */
export declare class MsgWithdrawValidatorCommission extends JSONSerializable<MsgWithdrawValidatorCommission.Amino, MsgWithdrawValidatorCommission.Data, MsgWithdrawValidatorCommission.Proto> {
	validator_address: ValAddress;
	/**
	 * @param validator_address validator's operator address
	 */
	constructor(validator_address: ValAddress);
	static fromAmino(data: MsgWithdrawValidatorCommission.Amino, _?: boolean): MsgWithdrawValidatorCommission;
	toAmino(isClassic?: boolean): MsgWithdrawValidatorCommission.Amino;
	static fromData(proto: MsgWithdrawValidatorCommission.Data, _?: boolean): MsgWithdrawValidatorCommission;
	toData(_?: boolean): MsgWithdrawValidatorCommission.Data;
	static fromProto(proto: MsgWithdrawValidatorCommission.Proto, _?: boolean): MsgWithdrawValidatorCommission;
	toProto(_?: boolean): MsgWithdrawValidatorCommission.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgWithdrawValidatorCommission;
}
export declare namespace MsgWithdrawValidatorCommission {
	interface Amino {
		type: "distribution/MsgWithdrawValidatorCommission" | "cosmos-sdk/MsgWithdrawValidatorCommission";
		value: {
			validator_address: ValAddress;
		};
	}
	interface Data {
		"@type": "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission";
		validator_address: ValAddress;
	}
	type Proto = MsgWithdrawValidatorCommission_pb;
}
export declare class MsgFundCommunityPool extends JSONSerializable<MsgFundCommunityPool.Amino, MsgFundCommunityPool.Data, MsgFundCommunityPool.Proto> {
	depositor: AccAddress;
	amount: Coins;
	/**
	 * @param depositor depositor's account address
	 * @param amount coins to fund the community pool
	 */
	constructor(depositor: AccAddress, amount: Coins.Input);
	static fromAmino(data: MsgFundCommunityPool.Amino, _?: boolean): MsgFundCommunityPool;
	toAmino(isClassic?: boolean): MsgFundCommunityPool.Amino;
	static fromData(proto: MsgFundCommunityPool.Data, _?: boolean): MsgFundCommunityPool;
	toData(_?: boolean): MsgFundCommunityPool.Data;
	static fromProto(proto: MsgFundCommunityPool.Proto, _?: Boolean): MsgFundCommunityPool;
	toProto(_?: boolean): MsgFundCommunityPool.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgFundCommunityPool;
}
export declare namespace MsgFundCommunityPool {
	interface Amino {
		type: "distribution/MsgFundCommunityPool" | "cosmos-sdk/MsgFundCommunityPool";
		value: {
			depositor: AccAddress;
			amount: Coins.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.distribution.v1beta1.MsgFundCommunityPool";
		depositor: AccAddress;
		amount: Coins.Data;
	}
	type Proto = MsgFundCommunityPool_pb;
}
export type DistributionMsg = MsgSetWithdrawAddress | MsgWithdrawDelegatorReward | MsgWithdrawValidatorCommission | MsgFundCommunityPool;
export declare namespace DistributionMsg {
	type Amino = MsgSetWithdrawAddress.Amino | MsgWithdrawDelegatorReward.Amino | MsgWithdrawValidatorCommission.Amino | MsgFundCommunityPool.Amino;
	type Data = MsgSetWithdrawAddress.Data | MsgWithdrawDelegatorReward.Data | MsgWithdrawValidatorCommission.Data | MsgFundCommunityPool.Data;
	type Proto = MsgSetWithdrawAddress.Proto | MsgWithdrawDelegatorReward.Proto | MsgWithdrawValidatorCommission.Proto | MsgFundCommunityPool.Proto;
}
/**
 * BasicAllowance implements Allowance with a one-time grant of tokens
 * that optionally expires. The grantee can use up to SpendLimit to cover fees.
 */
export declare class BasicAllowance extends JSONSerializable<BasicAllowance.Amino, BasicAllowance.Data, BasicAllowance.Proto> {
	expiration?: Date | undefined;
	spend_limit?: Coins;
	/**
	 * @param spend_limit spend_limit allowed to be spent as fee
	 * @param expiration allowance's expiration
	 */
	constructor(spend_limit?: Coins.Input, expiration?: Date | undefined);
	static fromAmino(data: BasicAllowance.Amino, _?: boolean): BasicAllowance;
	toAmino(isClassic?: boolean): BasicAllowance.Amino;
	static fromData(proto: BasicAllowance.Data, _?: boolean): BasicAllowance;
	toData(_?: boolean): BasicAllowance.Data;
	static fromProto(proto: BasicAllowance.Proto, _?: boolean): BasicAllowance;
	toProto(_?: boolean): BasicAllowance.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): BasicAllowance;
}
export declare namespace BasicAllowance {
	interface Amino {
		type: "feegrant/BasicAllowance" | "cosmos-sdk/BasicAllowance";
		value: {
			spend_limit?: Coins.Amino;
			expiration?: string;
		};
	}
	interface Data {
		"@type": "/cosmos.feegrant.v1beta1.BasicAllowance";
		spend_limit?: Coins.Data;
		expiration?: string;
	}
	type Proto = BasicAllowance_pb;
}
/**
 * PeriodicAllowance extends Allowance to allow for both a maximum cap,
 * as well as a limit per time period.
 */
export declare class PeriodicAllowance extends JSONSerializable<PeriodicAllowance.Amino, PeriodicAllowance.Data, PeriodicAllowance.Proto> {
	basic: BasicAllowance;
	period: number;
	period_reset: Date;
	period_spend_limit: Coins;
	period_can_spend: Coins;
	/**
	 * @param basic basic allowance given per period
	 * @param period the time duration in which period_spend_limit coins can be spent before that allowance is reset
	 * @param period_spend_limit the maximum number of coins that can be spent in the period
	 * @param period_can_spend the number of coins left to be spent before the period_reset time
	 * @param period_reset the time at which this period resets and a new one begins
	 */
	constructor(basic: BasicAllowance, period: number, period_spend_limit: Coins.Input, period_can_spend: Coins.Input, period_reset: Date);
	static fromAmino(data: PeriodicAllowance.Amino, isClassic?: boolean): PeriodicAllowance;
	toAmino(isClassic?: boolean): PeriodicAllowance.Amino;
	static fromData(proto: PeriodicAllowance.Data, _?: boolean): PeriodicAllowance;
	toData(_?: boolean): PeriodicAllowance.Data;
	static fromProto(proto: PeriodicAllowance.Proto, _?: boolean): PeriodicAllowance;
	toProto(_?: boolean): PeriodicAllowance.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): PeriodicAllowance;
}
export declare namespace PeriodicAllowance {
	interface Amino {
		type: "feegrant/PeriodicAllowance" | "cosmos-sdk/PeriodicAllowance";
		value: {
			basic: BasicAllowance.Amino;
			period: string;
			period_spend_limit: Coins.Amino;
			period_can_spend: Coins.Amino;
			period_reset: string;
		};
	}
	interface Data {
		"@type": "/cosmos.feegrant.v1beta1.PeriodicAllowance";
		basic: BasicAllowance.Data;
		period: string;
		period_spend_limit: Coins.Data;
		period_can_spend: Coins.Data;
		period_reset: string;
	}
	type Proto = PeriodicAllowance_pb;
}
/**
 * AllowedMsgAllowance creates allowance only for specified message types.
 */
export declare class AllowedMsgAllowance extends JSONSerializable<AllowedMsgAllowance.Amino, AllowedMsgAllowance.Data, AllowedMsgAllowance.Proto> {
	allowance: BasicAllowance | PeriodicAllowance;
	allowed_messages: string[];
	/**
	 * @param allowance any of basic and periodic fee allowance.
	 * @param allowed_messages the messages for which the grantee has the access.
	 */
	constructor(allowance: BasicAllowance | PeriodicAllowance, allowed_messages: string[]);
	static fromAmino(data: AllowedMsgAllowance.Amino, isClassic?: boolean): AllowedMsgAllowance;
	toAmino(isClassic?: boolean): AllowedMsgAllowance.Amino;
	static fromData(proto: AllowedMsgAllowance.Data, _?: boolean): AllowedMsgAllowance;
	toData(_?: boolean): AllowedMsgAllowance.Data;
	static fromProto(proto: AllowedMsgAllowance.Proto, isClassic?: boolean): AllowedMsgAllowance;
	toProto(isClassic?: boolean): AllowedMsgAllowance.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): AllowedMsgAllowance;
}
export declare namespace AllowedMsgAllowance {
	interface Amino {
		type: "feegrant/AllowedMsgAllowance" | "cosmos-sdk/AllowedMsgAllowance";
		value: {
			allowance: BasicAllowance.Amino | PeriodicAllowance.Amino;
			allowed_messages: string[];
		};
	}
	interface Data {
		"@type": "/cosmos.feegrant.v1beta1.AllowedMsgAllowance";
		allowance: BasicAllowance.Data | PeriodicAllowance.Data;
		allowed_messages: string[];
	}
	type Proto = AllowedMsgAllowance_pb;
}
export type Allowance = BasicAllowance | PeriodicAllowance | AllowedMsgAllowance;
export declare namespace Allowance {
	type Amino = BasicAllowance.Amino | PeriodicAllowance.Amino | AllowedMsgAllowance.Amino;
	type Data = BasicAllowance.Data | PeriodicAllowance.Data | AllowedMsgAllowance.Data;
	type Proto = BasicAllowance.Proto | PeriodicAllowance.Proto | AllowedMsgAllowance.Proto;
	function fromAmino(data: Allowance.Amino, isClassic?: boolean): Allowance;
	function fromData(data: Allowance.Data, isClassic?: boolean): Allowance;
	function fromProto(proto: Any, isClassic?: boolean): Allowance;
}
/**
 * MsgGrantAllowance adds permission for Grantee to spend up to Allowance
 * of fees from the account of Granter.
 */
export declare class MsgGrantAllowance extends JSONSerializable<MsgGrantAllowance.Amino, MsgGrantAllowance.Data, MsgGrantAllowance.Proto> {
	granter: AccAddress;
	grantee: AccAddress;
	allowance: Allowance;
	/**
	 *
	 * @param granter granter's account address
	 * @param grantee grantee's account address
	 * @param allowance allowance willing to grant
	 */
	constructor(granter: AccAddress, grantee: AccAddress, allowance: Allowance);
	static fromAmino(data: MsgGrantAllowance.Amino, isClassic?: boolean): MsgGrantAllowance;
	toAmino(isClassic?: boolean): MsgGrantAllowance.Amino;
	static fromData(data: MsgGrantAllowance.Data, isClassic?: boolean): MsgGrantAllowance;
	toData(isClassic?: boolean): MsgGrantAllowance.Data;
	static fromProto(proto: MsgGrantAllowance.Proto, isClassic?: boolean): MsgGrantAllowance;
	toProto(isClassic?: boolean): MsgGrantAllowance.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgGrantAllowance;
}
export declare namespace MsgGrantAllowance {
	interface Amino {
		type: "feegrant/MsgGrantAllowance" | "cosmos-sdk/MsgGrantAllowance";
		value: {
			granter: AccAddress;
			grantee: AccAddress;
			allowance: Allowance.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.feegrant.v1beta1.MsgGrantAllowance";
		granter: AccAddress;
		grantee: AccAddress;
		allowance: Allowance.Data;
	}
	type Proto = MsgGrantAllowance_pb;
}
/**
 * MsgRevokeAllowance remove permission any existing Allowance from Granter to Grantee.
 */
export declare class MsgRevokeAllowance extends JSONSerializable<MsgRevokeAllowance.Amino, MsgRevokeAllowance.Data, MsgRevokeAllowance.Proto> {
	granter: AccAddress;
	grantee: AccAddress;
	/**
	 *
	 * @param granter granter's account address
	 * @param grantee grantee's account address
	 */
	constructor(granter: AccAddress, grantee: AccAddress);
	static fromAmino(data: MsgRevokeAllowance.Amino, _?: boolean): MsgRevokeAllowance;
	toAmino(isClassic?: boolean): MsgRevokeAllowance.Amino;
	static fromData(proto: MsgRevokeAllowance.Data, _?: boolean): MsgRevokeAllowance;
	toData(_?: boolean): MsgRevokeAllowance.Data;
	static fromProto(proto: MsgRevokeAllowance.Proto, _?: boolean): MsgRevokeAllowance;
	toProto(_?: boolean): MsgRevokeAllowance.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgRevokeAllowance;
}
export declare namespace MsgRevokeAllowance {
	interface Amino {
		type: "feegrant/MsgRevokeAllowance" | "cosmos-sdk/MsgRevokeAllowance";
		value: {
			granter: AccAddress;
			grantee: AccAddress;
		};
	}
	interface Data {
		"@type": "/cosmos.feegrant.v1beta1.MsgRevokeAllowance";
		granter: AccAddress;
		grantee: AccAddress;
	}
	type Proto = MsgRevokeAllowance_pb;
}
export type FeeGrantMsg = MsgGrantAllowance | MsgRevokeAllowance;
export declare namespace FeeGrantMsg {
	type Amino = MsgGrantAllowance.Amino | MsgRevokeAllowance.Amino;
	type Data = MsgGrantAllowance.Data | MsgRevokeAllowance.Data;
	type Proto = MsgGrantAllowance.Proto | MsgRevokeAllowance.Proto;
}
/**
 * Proposal that disburses funds from the Distribution module's community pool to the
 * specified recipient if passed.
 */
export declare class CommunityPoolSpendProposal extends JSONSerializable<CommunityPoolSpendProposal.Amino, CommunityPoolSpendProposal.Data, CommunityPoolSpendProposal.Proto> {
	title: string;
	description: string;
	recipient: AccAddress;
	amount: Coins;
	/**
	 * @param title proposal's title
	 * @param description proposal's description
	 * @param recipient recipient address
	 * @param amount amount to give recipient
	 */
	constructor(title: string, description: string, recipient: AccAddress, amount: Coins.Input);
	static fromAmino(data: CommunityPoolSpendProposal.Amino, _?: boolean): CommunityPoolSpendProposal;
	toAmino(isClassic?: boolean): CommunityPoolSpendProposal.Amino;
	static fromData(data: CommunityPoolSpendProposal.Data, _?: boolean): CommunityPoolSpendProposal;
	toData(_?: boolean): CommunityPoolSpendProposal.Data;
	static fromProto(proto: CommunityPoolSpendProposal.Proto, _?: boolean): CommunityPoolSpendProposal;
	toProto(_?: boolean): CommunityPoolSpendProposal.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): CommunityPoolSpendProposal;
}
export declare namespace CommunityPoolSpendProposal {
	interface Amino {
		type: "distribution/CommunityPoolSpendProposal" | "cosmos-sdk/CommunityPoolSpendProposal";
		value: {
			title: string;
			description: string;
			recipient: AccAddress;
			amount: Coins.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal";
		title: string;
		description: string;
		recipient: AccAddress;
		amount: Coins.Data;
	}
	type Proto = CommunityPoolSpendProposal_pb;
}
export declare class ParamChanges extends JSONSerializable<ParamChanges.Amino, ParamChanges.Data, ParamChanges.Proto> {
	paramChanges: ParamChange[];
	constructor(paramChanges: ParamChange[]);
	static fromAmino(proto: ParamChanges.Amino | null): ParamChanges;
	toAmino(): ParamChanges.Amino;
	static fromData(proto: ParamChanges.Data | null): ParamChanges;
	toData(): ParamChanges.Data;
	static fromProto(proto: ParamChanges.Proto | null): ParamChanges;
	toProto(): ParamChanges.Proto;
}
export declare namespace ParamChanges {
	type Amino = ParamChange.Amino[];
	type Data = ParamChange.Data[];
	type Proto = ParamChange.Proto[];
}
export declare class ParamChange extends JSONSerializable<ParamChange.Amino, ParamChange.Data, ParamChange.Proto> {
	subspace: string;
	key: string;
	value: string;
	constructor(subspace: string, key: string, value: string);
	static fromAmino(data: ParamChange.Amino): ParamChange;
	toAmino(): ParamChange.Amino;
	static fromData(data: ParamChange.Data): ParamChange;
	toData(): ParamChange.Data;
	static fromProto(proto: ParamChange.Proto): ParamChange;
	toProto(): ParamChange.Proto;
}
export declare namespace ParamChange {
	interface Amino {
		subspace: string;
		key: string;
		value: string;
	}
	interface Data {
		subspace: string;
		key: string;
		value: string;
	}
	type Proto = ParamChange_pb;
}
/**
 * Describes a proposal for directly altering the value of the module parameters.
 * If you want to select a couple parameters to change for your proposal, you'll first
 * include the subspace (module it belongs to, such as "oracle" or "distribution"), and
 * then just the specific keys that you want to include in your changes as items in a
 * JavaScript object.
 *
 * ```ts
 * import {
 *    Dec,
 *    MsgSubmitProposal,
 *    ParameterChangeProposal
 * } from "@terra-money/terra.js";
 *
 * const proposal = new ParameterChangeProposal("title", "description", {
 *    market: {
 *      minspread: new Dec(0.25),
 *      basepool: new Dec(10000000)
 *    },
 *    staking: {
 *      UnbondingTime: 15000000
 *    }
 * });
 *
 * const msg = new MsgSubmitProposal();
 * ```
 */
export declare class ParameterChangeProposal extends JSONSerializable<ParameterChangeProposal.Amino, ParameterChangeProposal.Data, ParameterChangeProposal.Proto> {
	title: string;
	description: string;
	changes: ParamChanges;
	/**
	 * @param title proposal's title
	 * @param description proposal's description
	 * @param changes an object whose keys are subspace names, and whose values are objects
	 * with objects having for keys and values, the desired parameter changes.
	 */
	constructor(title: string, description: string, changes: ParamChange.Data[] | ParamChanges);
	static fromAmino(data: ParameterChangeProposal.Amino, _?: boolean): ParameterChangeProposal;
	toAmino(isClassic?: boolean): ParameterChangeProposal.Amino;
	static fromData(proto: ParameterChangeProposal.Data, _?: boolean): ParameterChangeProposal;
	toData(_?: boolean): ParameterChangeProposal.Data;
	static fromProto(proto: ParameterChangeProposal.Proto, _?: boolean): ParameterChangeProposal;
	toProto(_?: boolean): ParameterChangeProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): ParameterChangeProposal;
}
export declare namespace ParameterChangeProposal {
	interface Amino {
		type: "params/ParameterChangeProposal" | "cosmos-sdk/ParameterChangeProposal";
		value: {
			title: string;
			description: string;
			changes: ParamChange.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmos.params.v1beta1.ParameterChangeProposal";
		title: string;
		description: string;
		changes: ParamChange.Data[];
	}
	type Proto = ParameterChangeProposal_pb;
}
declare class ClientUpdateProposal extends JSONSerializable<ClientUpdateProposal.Amino, ClientUpdateProposal.Data, ClientUpdateProposal.Proto> {
	title: string;
	description: string;
	subjectClientId: string;
	substituteClientId: string;
	/**
	 * @param title proposal's title
	 * @param description proposal's description
	 * @param subjectClientId client to update
	 * @param substituteClientId client to copy
	 */
	constructor(title: string, description: string, subjectClientId: string, substituteClientId: string);
	static fromAmino(data: ClientUpdateProposal.Amino, _?: boolean): ClientUpdateProposal;
	toAmino(_?: boolean): ClientUpdateProposal.Amino;
	static fromData(data: ClientUpdateProposal.Data, _?: boolean): ClientUpdateProposal;
	toData(_?: boolean): ClientUpdateProposal.Data;
	static fromProto(proto: ClientUpdateProposal.Proto, _?: boolean): ClientUpdateProposal;
	toProto(_?: boolean): ClientUpdateProposal.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): ClientUpdateProposal;
}
declare namespace ClientUpdateProposal {
	interface Amino {
		type: "ibc/ClientUpdateProposal";
		value: {
			title: string;
			description: string;
			subjectClientId: string;
			substituteClientId: string;
		};
	}
	interface Data {
		"@type": "/ibc.core.client.v1.ClientUpdateProposal";
		title: string;
		description: string;
		subject_client_id: string;
		substitute_client_id: string;
	}
	type Proto = ClientUpdateProposal_pb;
}
/**
 * Basic proposal which describes the candidate proposition that must be put into effect
 * manually if passed. Used as a general-purpose way of discovering community's
 * sentiment / interest for an arbitrary change.
 */
export declare class TextProposal extends JSONSerializable<TextProposal.Amino, TextProposal.Data, TextProposal.Proto> {
	title: string;
	description: string;
	/**
	 * @param title proposal's title
	 * @param description proposal's description
	 */
	constructor(title: string, description: string);
	static fromAmino(data: TextProposal.Amino, _?: boolean): TextProposal;
	toAmino(isClassic?: boolean): TextProposal.Amino;
	static fromData(proto: TextProposal.Data, _?: boolean): TextProposal;
	toData(_?: boolean): TextProposal.Data;
	static fromProto(proto: TextProposal.Proto, _?: boolean): TextProposal;
	toProto(_?: boolean): TextProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): TextProposal;
}
export declare namespace TextProposal {
	interface Amino {
		type: "gov/TextProposal" | "cosmos-sdk/TextProposal";
		value: {
			title: string;
			description: string;
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1beta1.TextProposal";
		title: string;
		description: string;
	}
	type Proto = TextProposal_pb;
}
export declare class Plan extends JSONSerializable<Plan.Amino, Plan.Data, Plan.Proto> {
	name: string;
	time?: Date;
	height: string;
	info: string;
	upgraded_client_state?: any;
	/**
	 * @param name This name will be used by the upgraded  version of the software to apply any special "on-upgrade" commands during the first BeginBlock method after the upgrade is applied.
	 * @param time Deprecated
	 * @param height  The height at which the upgrade must be performed. Only used if Time is not set.
	 * @param info Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to
	 * @param upgraded_client_state Deprecated
	 */
	constructor(name: string, time: Date | undefined, height: string, info: string, upgraded_client_state: any | undefined);
	static fromAmino(data: Plan.Amino): Plan;
	toAmino(): Plan.Amino;
	static fromData(data: Plan.Data): Plan;
	toData(): Plan.Data;
	static fromProto(proto: Plan.Proto): Plan;
	toProto(): Plan.Proto;
}
export declare namespace Plan {
	interface Amino {
		name: string;
		time?: string;
		height: string;
		info: string;
		upgraded_client_state?: any;
	}
	interface Data {
		name: string;
		time?: string;
		height: string;
		info: string;
		upgraded_client_state?: any;
	}
	type Proto = Plan_pb;
}
/**
 * Softwareupgradeproposal is a gov Content type for initiating a software upgrade.
 */
export declare class SoftwareUpgradeProposal extends JSONSerializable<SoftwareUpgradeProposal.Amino, SoftwareUpgradeProposal.Data, SoftwareUpgradeProposal.Proto> {
	title: string;
	description: string;
	plan?: Plan | undefined;
	/**
	 *
	 * @param title
	 * @param description
	 * @param plan
	 */
	constructor(title: string, description: string, plan?: Plan | undefined);
	static fromAmino(data: SoftwareUpgradeProposal.Amino, _?: boolean): SoftwareUpgradeProposal;
	toAmino(isClassic?: boolean): SoftwareUpgradeProposal.Amino;
	static fromData(data: SoftwareUpgradeProposal.Data, _?: boolean): SoftwareUpgradeProposal;
	toData(_?: boolean): SoftwareUpgradeProposal.Data;
	static fromProto(proto: SoftwareUpgradeProposal.Proto, _?: boolean): SoftwareUpgradeProposal;
	toProto(_?: boolean): SoftwareUpgradeProposal.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): SoftwareUpgradeProposal;
}
export declare namespace SoftwareUpgradeProposal {
	interface Amino {
		type: "upgrade/SoftwareUpgradeProposal" | "cosmos-sdk/SoftwareUpgradeProposal";
		value: {
			title: string;
			description: string;
			plan?: Plan.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal";
		title: string;
		description: string;
		plan?: Plan.Data;
	}
	type Proto = SoftwareUpgradeProposal_pb;
}
/**
 *  CancelSoftwareUpgradeProposal is a gov Content type for cancelling a software upgrade
 */
export declare class CancelSoftwareUpgradeProposal extends JSONSerializable<CancelSoftwareUpgradeProposal.Amino, CancelSoftwareUpgradeProposal.Data, CancelSoftwareUpgradeProposal.Proto> {
	title: string;
	description: string;
	/**
	 *
	 * @param title
	 * @param description
	 */
	constructor(title: string, description: string);
	static fromAmino(data: CancelSoftwareUpgradeProposal.Amino, _?: boolean): CancelSoftwareUpgradeProposal;
	toAmino(isClassic?: boolean): CancelSoftwareUpgradeProposal.Amino;
	static fromData(data: CancelSoftwareUpgradeProposal.Data, _?: boolean): CancelSoftwareUpgradeProposal;
	toData(_?: boolean): CancelSoftwareUpgradeProposal.Data;
	static fromProto(proto: CancelSoftwareUpgradeProposal.Proto, _?: boolean): CancelSoftwareUpgradeProposal;
	toProto(_?: boolean): CancelSoftwareUpgradeProposal.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): CancelSoftwareUpgradeProposal;
}
export declare namespace CancelSoftwareUpgradeProposal {
	interface Amino {
		type: "upgrade/CancelSoftwareUpgradeProposal" | "cosmos-sdk/CancelSoftwareUpgradeProposal";
		value: {
			title: string;
			description: string;
		};
	}
	interface Data {
		"@type": "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal";
		title: string;
		description: string;
	}
	type Proto = CancelSoftwareUpgradeProposal_pb;
}
/**
 * ClearAdminProposal gov proposal content type to clear the admin of a
 * contract.
 */
export declare class ClearAdminProposal extends JSONSerializable<ClearAdminProposal.Amino, ClearAdminProposal.Data, ClearAdminProposal.Proto> {
	title: string;
	description: string;
	contract: AccAddress;
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param contract the address of the smart contract
	 */
	constructor(title: string, description: string, contract: AccAddress);
	static fromAmino(data: ClearAdminProposal.Amino, isClassic?: boolean): ClearAdminProposal;
	toAmino(isClassic?: boolean): ClearAdminProposal.Amino;
	static fromProto(proto: ClearAdminProposal.Proto, isClassic?: boolean): ClearAdminProposal;
	toProto(isClassic?: boolean): ClearAdminProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): ClearAdminProposal;
	static fromData(data: ClearAdminProposal.Data, isClassic?: boolean): ClearAdminProposal;
	toData(isClassic?: boolean): ClearAdminProposal.Data;
}
export declare namespace ClearAdminProposal {
	interface Amino {
		type: "wasm/ClearAdminProposal";
		value: {
			title: string;
			description: string;
			contract: AccAddress;
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.ClearAdminProposal";
		title: string;
		description: string;
		contract: AccAddress;
	}
	type Proto = ClearAdminProposal_pb;
}
/**
 * ExecuteContractProposal gov proposal content type to call execute on a
 * contract.
 */
export declare class ExecuteContractProposal extends JSONSerializable<ExecuteContractProposal.Amino, ExecuteContractProposal.Data, ExecuteContractProposal.Proto> {
	title: string;
	description: string;
	run_as: AccAddress;
	contract: AccAddress;
	execute_msg: object | string;
	coins: Coins;
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param run_as contract user
	 * @param contract contract address
	 * @param execute_msg HandleMsg to pass as arguments for contract invocation
	 * @param coins coins to be sent to contract
	 */
	constructor(title: string, description: string, run_as: AccAddress, contract: AccAddress, execute_msg: object | string, coins?: Coins.Input);
	static fromAmino(data: ExecuteContractProposal.Amino, _?: boolean): ExecuteContractProposal;
	toAmino(_?: boolean): ExecuteContractProposal.Amino;
	static fromProto(proto: ExecuteContractProposal.Proto, _?: boolean): ExecuteContractProposal;
	toProto(_?: boolean): ExecuteContractProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): ExecuteContractProposal;
	static fromData(data: ExecuteContractProposal.Data, _?: boolean): ExecuteContractProposal;
	toData(_?: boolean): ExecuteContractProposal.Data;
}
export declare namespace ExecuteContractProposal {
	interface Amino {
		type: "wasm/ExecuteContractProposal";
		value: {
			title: string;
			description: string;
			run_as: AccAddress;
			contract: AccAddress;
			msg: object | string;
			funds: Coins.Amino;
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.ExecuteContractProposal";
		title: string;
		description: string;
		run_as: AccAddress;
		contract: AccAddress;
		msg: object | string;
		funds: Coins.Data;
	}
	type Proto = ExecuteContractProposal_pb;
}
/**
 * InstantiateContractProposal gov proposal content type to instantiate a
 * contract.
 */
export declare class InstantiateContractProposal extends JSONSerializable<InstantiateContractProposal.Amino, InstantiateContractProposal.Data, InstantiateContractProposal.Proto> {
	title: string;
	description: string;
	run_as: AccAddress;
	admin: AccAddress | undefined;
	code_id: number;
	init_msg: object | string;
	label: string;
	init_coins: Coins;
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param run_as is a run_as address
	 * @param admin is an optional contract admin address who can migrate the contract, put empty string to disable migration
	 * @param code_id is the reference to the stored WASM code
	 * @param init_msg json encoded message to be passed to the contract on instantiation
	 * @param init_coins are transferred to the contract on execution
	 * @param label label for the contract. v2 supported only
	 */
	constructor(title: string, description: string, run_as: AccAddress, admin: AccAddress | undefined, code_id: number, init_msg: object | string, init_coins: Coins.Input | undefined, label: string);
	static fromAmino(data: InstantiateContractProposal.Amino, isClassic?: boolean): InstantiateContractProposal;
	toAmino(isClassic?: boolean): InstantiateContractProposal.Amino;
	static fromProto(proto: InstantiateContractProposal.Proto, isClassic?: boolean): InstantiateContractProposal;
	toProto(isClassic?: boolean): InstantiateContractProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): InstantiateContractProposal;
	static fromData(data: InstantiateContractProposal.Data, isClassic?: boolean): InstantiateContractProposal;
	toData(isClassic?: boolean): InstantiateContractProposal.Data;
}
export declare namespace InstantiateContractProposal {
	interface Amino {
		type: "wasm/InstantiateContractProposal";
		value: {
			title: string;
			description: string;
			run_as: AccAddress;
			admin?: AccAddress;
			code_id: string;
			label: string;
			msg: object | string;
			funds: Coins.Amino;
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.InstantiateContractProposal";
		title: string;
		description: string;
		run_as: AccAddress;
		admin: AccAddress;
		code_id: string;
		label: string;
		msg: object | string;
		funds: Coins.Data;
	}
	type Proto = InstantiateContractProposal_pb;
}
/** MigrateContractProposal gov proposal content type to migrate a contract. */
export declare class MigrateContractProposal extends JSONSerializable<MigrateContractProposal.Amino, MigrateContractProposal.Data, MigrateContractProposal.Proto> {
	title: string;
	description: string;
	contract: AccAddress;
	new_code_id: number;
	migrate_msg: object | string;
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param contract contract address to be migrated from
	 * @param new_code_id reference to the new code on the blockchain
	 * @param migrate_msg JSON message to configure the migrate state of the contract
	 */
	constructor(title: string, description: string, contract: AccAddress, new_code_id: number, migrate_msg: object | string);
	static fromAmino(data: MigrateContractProposal.Amino, isClassic?: boolean): MigrateContractProposal;
	toAmino(isClassic?: boolean): MigrateContractProposal.Amino;
	static fromProto(proto: MigrateContractProposal.Proto, isClassic?: boolean): MigrateContractProposal;
	toProto(isClassic?: boolean): MigrateContractProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MigrateContractProposal;
	static fromData(data: MigrateContractProposal.Data, isClassic?: boolean): MigrateContractProposal;
	toData(isClassic?: boolean): MigrateContractProposal.Data;
}
export declare namespace MigrateContractProposal {
	interface Amino {
		type: "wasm/MigrateContractProposal";
		value: {
			title: string;
			description: string;
			contract: AccAddress;
			code_id: string;
			msg: object | string;
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.MigrateContractProposal";
		title: string;
		description: string;
		contract: AccAddress;
		code_id: string;
		msg: object | string;
	}
	type Proto = MigrateContractProposal_pb;
}
/**
 * PinCodesProposal gov proposal content type to pin a set of code ids in the
 * wasmvm cache.
 */
export declare class PinCodesProposal extends JSONSerializable<PinCodesProposal.Amino, PinCodesProposal.Data, PinCodesProposal.Proto> {
	title: string;
	description: string;
	code_ids: number[];
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param code_ids the address of the smart code_ids
	 */
	constructor(title: string, description: string, code_ids: number[]);
	static fromAmino(data: PinCodesProposal.Amino, isClassic?: boolean): PinCodesProposal;
	toAmino(isClassic?: boolean): PinCodesProposal.Amino;
	static fromProto(proto: PinCodesProposal.Proto, isClassic?: boolean): PinCodesProposal;
	toProto(isClassic?: boolean): PinCodesProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): PinCodesProposal;
	static fromData(data: PinCodesProposal.Data, isClassic?: boolean): PinCodesProposal;
	toData(isClassic?: boolean): PinCodesProposal.Data;
}
export declare namespace PinCodesProposal {
	interface Amino {
		type: "wasm/PinCodesProposal";
		value: {
			title: string;
			description: string;
			code_ids: string[];
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.PinCodesProposal";
		title: string;
		description: string;
		code_ids: string[];
	}
	type Proto = PinCodesProposal_pb;
}
/**
 *
 */
export declare class AccessConfig extends JSONSerializable<AccessConfig.Amino, AccessConfig.Data, AccessConfig.Proto> {
	permission: AccessType;
	address: AccAddress;
	/**
	 * @param permission access type
	 * @param address
	 */
	constructor(permission: AccessType, address: AccAddress);
	static fromAmino(data: AccessConfig.Amino): AccessConfig;
	toAmino(): AccessConfig.Amino;
	static fromData(data: AccessConfig.Data): AccessConfig;
	toData(): AccessConfig.Data;
	static fromProto(proto: AccessConfig.Proto): AccessConfig;
	toProto(): AccessConfig.Proto;
}
export declare namespace AccessConfig {
	interface Amino {
		permission: string;
		address: string;
	}
	interface Data {
		permission: string;
		address: string;
	}
	type Proto = AccessConfig_pb;
}
/**
 * StoreCodeProposal gov proposal content type to submit WASM code to the system
 */
export declare class StoreCodeProposal extends JSONSerializable<StoreCodeProposal.Amino, StoreCodeProposal.Data, StoreCodeProposal.Proto> {
	title: string;
	description: string;
	run_as: string;
	wasm_byte_code: string;
	instantiate_permission?: AccessConfig | undefined;
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param run_as the address that is passed to the contract's environment as sender
	 * @param wasm_byte_code can be raw or gzip compressed
	 * @param instantiate_permission to apply on contract creation, optional
	 */
	constructor(title: string, description: string, run_as: string, wasm_byte_code: string, instantiate_permission?: AccessConfig | undefined);
	static fromAmino(data: StoreCodeProposal.Amino, isClassic?: boolean): StoreCodeProposal;
	toAmino(isClassic?: boolean): StoreCodeProposal.Amino;
	static fromData(data: StoreCodeProposal.Data, isClassic?: boolean): StoreCodeProposal;
	toData(isClassic?: boolean): StoreCodeProposal.Data;
	static fromProto(proto: StoreCodeProposal.Proto, isClassic?: boolean): StoreCodeProposal;
	toProto(isClassic?: boolean): StoreCodeProposal.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): StoreCodeProposal;
}
export declare namespace StoreCodeProposal {
	interface Amino {
		type: "wasm/StoreCodeProposal";
		value: {
			title: string;
			description: string;
			run_as: AccAddress;
			wasm_byte_code: string;
			instantiate_permission?: AccessConfig.Amino;
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.StoreCodeProposal";
		title: string;
		description: string;
		run_as: AccAddress;
		wasm_byte_code: string;
		instantiate_permission?: AccessConfig.Data;
	}
	type Proto = StoreCodeProposal_pb;
}
export declare class SudoContractProposal extends JSONSerializable<SudoContractProposal.Amino, SudoContractProposal.Data, SudoContractProposal.Proto> {
	title: string;
	description: string;
	contract: AccAddress;
	msg: object | string;
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param contract contract address to be migrated from
	 * @param msg JSON message to configure the migrate state of the contract
	 */
	constructor(title: string, description: string, contract: AccAddress, msg: object | string);
	static fromAmino(data: SudoContractProposal.Amino, isClassic?: boolean): SudoContractProposal;
	toAmino(isClassic?: boolean): SudoContractProposal.Amino;
	static fromProto(proto: SudoContractProposal.Proto, isClassic?: boolean): SudoContractProposal;
	toProto(isClassic?: boolean): SudoContractProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): SudoContractProposal;
	static fromData(data: SudoContractProposal.Data, isClassic?: boolean): SudoContractProposal;
	toData(isClassic?: boolean): SudoContractProposal.Data;
}
export declare namespace SudoContractProposal {
	interface Amino {
		type: "wasm/SudoContractProposal";
		value: {
			title: string;
			description: string;
			contract: AccAddress;
			msg: object | string;
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.SudoContractProposal";
		title: string;
		description: string;
		contract: AccAddress;
		msg: object | string;
	}
	type Proto = SudoContractProposal_pb;
}
/**
 * UnpinCodesProposal gov proposal content type to unpin a set of code ids in
 * the wasmvm cache.
 */
export declare class UnpinCodesProposal extends JSONSerializable<UnpinCodesProposal.Amino, UnpinCodesProposal.Data, UnpinCodesProposal.Proto> {
	title: string;
	description: string;
	code_ids: number[];
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param code_ids the address of the smart code_ids
	 */
	constructor(title: string, description: string, code_ids: number[]);
	static fromAmino(data: UnpinCodesProposal.Amino, isClassic?: boolean): UnpinCodesProposal;
	toAmino(isClassic?: boolean): UnpinCodesProposal.Amino;
	static fromProto(proto: UnpinCodesProposal.Proto, isClassic?: boolean): UnpinCodesProposal;
	toProto(isClassic?: boolean): UnpinCodesProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): UnpinCodesProposal;
	static fromData(data: UnpinCodesProposal.Data, isClassic?: boolean): UnpinCodesProposal;
	toData(isClassic?: boolean): UnpinCodesProposal.Data;
}
export declare namespace UnpinCodesProposal {
	interface Amino {
		type: "wasm/UnpinCodesProposal";
		value: {
			title: string;
			description: string;
			code_ids: string[];
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.UnpinCodesProposal";
		title: string;
		description: string;
		code_ids: string[];
	}
	type Proto = UnpinCodesProposal_pb;
}
/** UpdateAdminProposal gov proposal content type to set an admin for a contract. */
export declare class UpdateAdminProposal extends JSONSerializable<UpdateAdminProposal.Amino, UpdateAdminProposal.Data, UpdateAdminProposal.Proto> {
	title: string;
	description: string;
	contract: AccAddress;
	new_admin: AccAddress;
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param contract the address of the smart contract
	 * @param new_admin address to be set
	 */
	constructor(title: string, description: string, contract: AccAddress, new_admin: AccAddress);
	static fromAmino(data: UpdateAdminProposal.Amino, isClassic?: boolean): UpdateAdminProposal;
	toAmino(isClassic?: boolean): UpdateAdminProposal.Amino;
	static fromProto(proto: UpdateAdminProposal.Proto, isClassic?: boolean): UpdateAdminProposal;
	toProto(isClassic?: boolean): UpdateAdminProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): UpdateAdminProposal;
	static fromData(data: UpdateAdminProposal.Data, isClassic?: boolean): UpdateAdminProposal;
	toData(isClassic?: boolean): UpdateAdminProposal.Data;
}
export declare namespace UpdateAdminProposal {
	interface Amino {
		type: "wasm/UpdateAdminProposal";
		value: {
			title: string;
			description: string;
			contract: AccAddress;
			new_admin: AccAddress;
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.UpdateAdminProposal";
		title: string;
		description: string;
		contract: AccAddress;
		new_admin: AccAddress;
	}
	type Proto = UpdateAdminProposal_pb;
}
declare class AccessConfigUpdate extends JSONSerializable<AccessConfigUpdate.Amino, AccessConfigUpdate.Data, AccessConfigUpdate.Proto> {
	code_id: number;
	instantiate_permission?: AccessConfig | undefined;
	/**
	 * @param code_id the reference to the stored WASM code to be updated
	 * @param instantiate_permission to apply to the set of code ids
	 */
	constructor(code_id: number, instantiate_permission?: AccessConfig | undefined);
	static fromAmino(data: AccessConfigUpdate.Amino): AccessConfigUpdate;
	toAmino(): AccessConfigUpdate.Amino;
	static fromData(data: AccessConfigUpdate.Data): AccessConfigUpdate;
	toData(): AccessConfigUpdate.Data;
	static fromProto(proto: AccessConfigUpdate.Proto): AccessConfigUpdate;
	toProto(): AccessConfigUpdate.Proto;
}
declare namespace AccessConfigUpdate {
	interface Amino {
		code_id: string;
		instantiate_permission?: AccessConfig.Amino;
	}
	interface Data {
		code_id: string;
		instantiate_permission?: AccessConfig.Data;
	}
	type Proto = AccessConfigUpdate_pb;
}
/**
 * UpdateInstantiateConfigProposal gov proposal content type to pin a set of code ids in the
 * wasmvm cache.
 */
export declare class UpdateInstantiateConfigProposal extends JSONSerializable<UpdateInstantiateConfigProposal.Amino, UpdateInstantiateConfigProposal.Data, UpdateInstantiateConfigProposal.Proto> {
	title: string;
	description: string;
	access_config_updates: AccessConfigUpdate[];
	/**
	 * @param title a short summary
	 * @param description a human readable text
	 * @param access_config_updates the address of the smart access_config_updates
	 */
	constructor(title: string, description: string, access_config_updates: AccessConfigUpdate[]);
	static fromAmino(data: UpdateInstantiateConfigProposal.Amino, isClassic?: boolean): UpdateInstantiateConfigProposal;
	toAmino(isClassic?: boolean): UpdateInstantiateConfigProposal.Amino;
	static fromProto(proto: UpdateInstantiateConfigProposal.Proto, isClassic?: boolean): UpdateInstantiateConfigProposal;
	toProto(isClassic?: boolean): UpdateInstantiateConfigProposal.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): UpdateInstantiateConfigProposal;
	static fromData(data: UpdateInstantiateConfigProposal.Data, isClassic?: boolean): UpdateInstantiateConfigProposal;
	toData(isClassic?: boolean): UpdateInstantiateConfigProposal.Data;
}
export declare namespace UpdateInstantiateConfigProposal {
	interface Amino {
		type: "wasm/UpdateInstantiateConfigProposal";
		value: {
			title: string;
			description: string;
			access_config_updates: AccessConfigUpdate.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmwasm.wasm.v1.UpdateInstantiateConfigProposal";
		title: string;
		description: string;
		access_config_updates: AccessConfigUpdate.Data[];
	}
	type Proto = UpdateInstantiateConfigProposal_pb;
}
/**
 *  MsgUpdateAllianceProposal is gov content type to create a new alliance
 */
export declare class MsgUpdateAllianceProposal extends JSONSerializable<MsgUpdateAllianceProposal.Amino, MsgUpdateAllianceProposal.Data, MsgUpdateAllianceProposal.Proto> {
	title: string;
	description: string;
	denom: string;
	rewardWeight: string;
	takeRate: string;
	rewardChangeRate: string;
	rewardChangeInterval?: Duration | undefined;
	/**
	 * @description Update an existent alliance using the gov module
	 * @param title of the proposal
	 * @param description of the proposal
	 * @param denom of the asset. It could either be a native token or an IBC token
	 * @param rewardWeight specifies the ratio of rewards that will be given to each alliance asset it does not need to sum to 1. rate = weight / total_weight Native asset is always assumed to have a weight of 1.
	 * @param takeRate positive take rate is used for liquid staking derivatives. It defines an annualized reward rate that will be redirected to the distribution rewards pool
	 * @param rewardChangeRate how much the reward weight will change every rewardChangeInterval
	 * @param rewardChangeInterval how often the reward weight will change
	 */
	constructor(title: string, description: string, denom: string, rewardWeight: string, takeRate: string, rewardChangeRate: string, rewardChangeInterval?: Duration | undefined);
	static fromAmino(data: MsgUpdateAllianceProposal.Amino, _?: boolean): MsgUpdateAllianceProposal;
	toAmino(_?: boolean): MsgUpdateAllianceProposal.Amino;
	static fromData(data: MsgUpdateAllianceProposal.Data, _?: boolean): MsgUpdateAllianceProposal;
	toData(_?: boolean): MsgUpdateAllianceProposal.Data;
	static fromProto(proto: MsgUpdateAllianceProposal.Proto, _?: boolean): MsgUpdateAllianceProposal;
	toProto(_?: boolean): MsgUpdateAllianceProposal.Proto;
	packAny(_?: boolean): Any;
	static unpackAny(msgAny: Any, _?: boolean): MsgUpdateAllianceProposal;
}
export declare namespace MsgUpdateAllianceProposal {
	interface Amino {
		type: "alliance/MsgUpdateAllianceProposal";
		title: string;
		description: string;
		denom: string;
		rewardWeight: string;
		takeRate: string;
		rewardChangeRate: string;
		rewardChangeInterval?: Duration;
	}
	interface Data {
		"@type": "/alliance.alliance.MsgUpdateAllianceProposal";
		title: string;
		description: string;
		denom: string;
		rewardWeight: string;
		takeRate: string;
		rewardChangeRate: string;
		rewardChangeInterval?: Duration;
	}
	type Proto = MsgUpdateAllianceProposal_pb;
}
/**
 *  MsgCreateAllianceProposal is gov content type to create a new alliance
 */
export declare class MsgCreateAllianceProposal extends JSONSerializable<MsgCreateAllianceProposal.Amino, MsgCreateAllianceProposal.Data, MsgCreateAllianceProposal.Proto> {
	title: string;
	description: string;
	denom: string;
	rewardWeight: string;
	takeRate: string;
	rewardChangeRate: string;
	rewardChangeInterval?: Duration | undefined;
	rewardWeightRange?: RewardWeightRange | undefined;
	/**
	 * @description Create a new alliance using the gov module
	 * @param title of the proposal
	 * @param description of the proposal
	 * @param denom of the asset. It could either be a native token or an IBC token
	 * @param rewardWeight specifies the ratio of rewards that will be given to each alliance asset it does not need to sum to 1. rate = weight / total_weight Native asset is always assumed to have a weight of 1.
	 * @param takeRate positive take rate is used for liquid staking derivatives. It defines an annualized reward rate that will be redirected to the distribution rewards pool
	 * @param rewardChangeRate how much the reward weight will change every rewardChangeInterval
	 * @param rewardChangeInterval how often the reward weight will change
	 * @param rewardWeightRange set a bound of weight range to limit how much reward weights can scale.
	 */
	constructor(title: string, description: string, denom: string, rewardWeight: string, takeRate: string, rewardChangeRate: string, rewardChangeInterval?: Duration | undefined, rewardWeightRange?: RewardWeightRange | undefined);
	static fromAmino(data: MsgCreateAllianceProposal.Amino, _?: boolean): MsgCreateAllianceProposal;
	toAmino(_?: boolean): MsgCreateAllianceProposal.Amino;
	static fromData(data: MsgCreateAllianceProposal.Data, _?: boolean): MsgCreateAllianceProposal;
	toData(_?: boolean): MsgCreateAllianceProposal.Data;
	static fromProto(proto: MsgCreateAllianceProposal.Proto, _?: boolean): MsgCreateAllianceProposal;
	toProto(_?: boolean): MsgCreateAllianceProposal.Proto;
	packAny(_?: boolean): Any;
	static unpackAny(msgAny: Any, _?: boolean): MsgCreateAllianceProposal;
}
export declare namespace MsgCreateAllianceProposal {
	interface Amino {
		type: "alliance/MsgCreateAllianceProposal";
		title: string;
		description: string;
		denom: string;
		rewardWeight: string;
		takeRate: string;
		rewardChangeRate: string;
		rewardChangeInterval?: Duration;
		rewardWeightRange?: RewardWeightRange;
	}
	interface Data {
		"@type": "/alliance.alliance.MsgCreateAllianceProposal";
		title: string;
		description: string;
		denom: string;
		rewardWeight: string;
		takeRate: string;
		rewardChangeRate: string;
		rewardChangeInterval?: Duration;
		rewardWeightRange?: RewardWeightRange;
	}
	type Proto = MsgCreateAllianceProposal_pb;
}
/**
 *  MsgDeleteAllianceProposal is gov content type to delete an existing alliance
 */
export declare class MsgDeleteAllianceProposal extends JSONSerializable<MsgDeleteAllianceProposal.Amino, MsgDeleteAllianceProposal.Data, MsgDeleteAllianceProposal.Proto> {
	title: string;
	description: string;
	denom: string;
	/**
	 * @description Delete an existent alliance using the gov module
	 * @param title of the proposal
	 * @param description of the proposal
	 * @param denom of the asset. It could either be a native token or an IBC token
	 */
	constructor(title: string, description: string, denom: string);
	static fromAmino(data: MsgDeleteAllianceProposal.Amino, _?: boolean): MsgDeleteAllianceProposal;
	toAmino(_?: boolean): MsgDeleteAllianceProposal.Amino;
	static fromData(data: MsgDeleteAllianceProposal.Data, _?: boolean): MsgDeleteAllianceProposal;
	toData(_?: boolean): MsgDeleteAllianceProposal.Data;
	static fromProto(proto: MsgDeleteAllianceProposal.Proto, _?: boolean): MsgDeleteAllianceProposal;
	toProto(_?: boolean): MsgDeleteAllianceProposal.Proto;
	packAny(_?: boolean): Any;
	static unpackAny(msgAny: Any, _?: boolean): MsgDeleteAllianceProposal;
}
export declare namespace MsgDeleteAllianceProposal {
	interface Amino {
		type: "alliance/MsgDeleteAllianceProposal";
		title: string;
		description: string;
		denom: string;
	}
	interface Data {
		"@type": "/alliance.alliance.MsgDeleteAllianceProposal";
		title: string;
		description: string;
		denom: string;
	}
	type Proto = MsgDeleteAllianceProposal_pb;
}
/**
 *  MsgUpdateAlliance is gov content type to create a new alliance
 */
export declare class MsgUpdateAlliance extends JSONSerializable<MsgUpdateAlliance.Amino, MsgUpdateAlliance.Data, MsgUpdateAlliance.Proto> {
	authority: string;
	denom: string;
	rewardWeight: string;
	takeRate: string;
	rewardChangeRate: string;
	rewardChangeInterval?: Duration | undefined;
	/**
	 * @description Update an existent alliance using the gov module
	 * @param authority of the proposal
	 * @param denom of the asset. It could either be a native token or an IBC token
	 * @param rewardWeight specifies the ratio of rewards that will be given to each alliance asset it does not need to sum to 1. rate = weight / total_weight Native asset is always assumed to have a weight of 1.
	 * @param takeRate positive take rate is used for liquid staking derivatives. It defines an annualized reward rate that will be redirected to the distribution rewards pool
	 * @param rewardChangeRate how much the reward weight will change every rewardChangeInterval
	 * @param rewardChangeInterval how often the reward weight will change
	 */
	constructor(authority: string, denom: string, rewardWeight: string, takeRate: string, rewardChangeRate: string, rewardChangeInterval?: Duration | undefined);
	static fromAmino(data: MsgUpdateAlliance.Amino, _?: boolean): MsgUpdateAlliance;
	toAmino(_?: boolean): MsgUpdateAlliance.Amino;
	static fromData(data: MsgUpdateAlliance.Data, _?: boolean): MsgUpdateAlliance;
	toData(_?: boolean): MsgUpdateAlliance.Data;
	static fromProto(proto: MsgUpdateAlliance.Proto, _?: boolean): MsgUpdateAlliance;
	toProto(_?: boolean): MsgUpdateAlliance.Proto;
	packAny(_?: boolean): Any;
	static unpackAny(msgAny: Any, _?: boolean): MsgUpdateAlliance;
}
export declare namespace MsgUpdateAlliance {
	interface Amino {
		type: "alliance/MsgUpdateAlliance";
		authority: string;
		denom: string;
		rewardWeight: string;
		takeRate: string;
		rewardChangeRate: string;
		rewardChangeInterval?: Duration;
	}
	interface Data {
		"@type": "/alliance.alliance.MsgUpdateAlliance";
		authority: string;
		denom: string;
		rewardWeight: string;
		takeRate: string;
		rewardChangeRate: string;
		rewardChangeInterval?: Duration;
	}
	type Proto = MsgUpdateAlliance_pb;
}
/**
 *  MsgCreateAlliance is gov content type to create a new alliance
 */
export declare class MsgCreateAlliance extends JSONSerializable<MsgCreateAlliance.Amino, MsgCreateAlliance.Data, MsgCreateAlliance.Proto> {
	authority: string;
	denom: string;
	rewardWeight: string;
	takeRate: string;
	rewardChangeRate: string;
	rewardChangeInterval?: Duration | undefined;
	rewardWeightRange?: RewardWeightRange | undefined;
	/**
	 * @description Create a new alliance using the gov module
	 * @param authority of the proposal
	 * @param denom of the asset. It could either be a native token or an IBC token
	 * @param rewardWeight specifies the ratio of rewards that will be given to each alliance asset it does not need to sum to 1. rate = weight / total_weight Native asset is always assumed to have a weight of 1.
	 * @param takeRate positive take rate is used for liquid staking derivatives. It defines an annualized reward rate that will be redirected to the distribution rewards pool
	 * @param rewardChangeRate how much the reward weight will change every rewardChangeInterval
	 * @param rewardChangeInterval how often the reward weight will change
	 * @param rewardWeightRange set a bound of weight range to limit how much reward weights can scale.
	 */
	constructor(authority: string, denom: string, rewardWeight: string, takeRate: string, rewardChangeRate: string, rewardChangeInterval?: Duration | undefined, rewardWeightRange?: RewardWeightRange | undefined);
	static fromAmino(data: MsgCreateAlliance.Amino, _?: boolean): MsgCreateAlliance;
	toAmino(_?: boolean): MsgCreateAlliance.Amino;
	static fromData(data: MsgCreateAlliance.Data, _?: boolean): MsgCreateAlliance;
	toData(_?: boolean): MsgCreateAlliance.Data;
	static fromProto(proto: MsgCreateAlliance.Proto, _?: boolean): MsgCreateAlliance;
	toProto(_?: boolean): MsgCreateAlliance.Proto;
	packAny(_?: boolean): Any;
	static unpackAny(msgAny: Any, _?: boolean): MsgCreateAlliance;
}
export declare namespace MsgCreateAlliance {
	interface Amino {
		type: "alliance/MsgCreateAlliance";
		authority: string;
		denom: string;
		rewardWeight: string;
		takeRate: string;
		rewardChangeRate: string;
		rewardChangeInterval?: Duration;
		rewardWeightRange?: RewardWeightRange;
	}
	interface Data {
		"@type": "/alliance.alliance.MsgCreateAlliance";
		authority: string;
		denom: string;
		rewardWeight: string;
		takeRate: string;
		rewardChangeRate: string;
		rewardChangeInterval?: Duration;
		rewardWeightRange?: RewardWeightRange;
	}
	type Proto = MsgCreateAlliance_pb;
}
/**
 *  MsgDeleteAlliance is gov content type to delete an existing alliance
 */
export declare class MsgDeleteAlliance extends JSONSerializable<MsgDeleteAlliance.Amino, MsgDeleteAlliance.Data, MsgDeleteAlliance.Proto> {
	authority: string;
	denom: string;
	/**
	 * @description Delete an existent alliance using the gov module
	 * @param authority of the proposal
	 * @param description of the proposal
	 * @param denom of the asset. It could either be a native token or an IBC token
	 */
	constructor(authority: string, denom: string);
	static fromAmino(data: MsgDeleteAlliance.Amino, _?: boolean): MsgDeleteAlliance;
	toAmino(_?: boolean): MsgDeleteAlliance.Amino;
	static fromData(data: MsgDeleteAlliance.Data, _?: boolean): MsgDeleteAlliance;
	toData(_?: boolean): MsgDeleteAlliance.Data;
	static fromProto(proto: MsgDeleteAlliance.Proto, _?: boolean): MsgDeleteAlliance;
	toProto(_?: boolean): MsgDeleteAlliance.Proto;
	packAny(_?: boolean): Any;
	static unpackAny(msgAny: Any, _?: boolean): MsgDeleteAlliance;
}
export declare namespace MsgDeleteAlliance {
	interface Amino {
		type: "alliance/MsgDeleteAlliance";
		authority: string;
		denom: string;
	}
	interface Data {
		"@type": "/alliance.alliance.MsgDeleteAlliance";
		authority: string;
		denom: string;
	}
	type Proto = MsgDeleteAlliance_pb;
}
/**
 * Stores information pertaining to a submitted proposal, such as its status and time of
 * the voting period
 */
export declare class Proposal extends JSONSerializable<Proposal.Amino, Proposal.Data, Proposal.Proto> {
	id: number;
	messages: Proposal.Message[];
	status: ProposalStatus$1;
	final_tally_result: Proposal.FinalTallyResult;
	submit_time: Date;
	deposit_end_time: Date;
	total_deposit: Coins;
	metadata: string;
	title: string;
	summary: string;
	proposer: AccAddress;
	voting_start_time?: Date | undefined;
	voting_end_time?: Date | undefined;
	/**
	 *
	 * @param id proposal's ID
	 * @param messages content of the proposal
	 * @param status proposal's status
	 * @param final_tally_result tally result
	 * @param submit_time time proposal was submitted and deposit period started
	 * @param deposit_end_time time deposit period will end
	 * @param total_deposit amount of coins deposited by all users
	 * @param voting_start_time time voting period will start
	 * @param voting_end_time time voting period will end
	 */
	constructor(id: number, messages: Proposal.Message[], status: ProposalStatus$1, final_tally_result: Proposal.FinalTallyResult, submit_time: Date, deposit_end_time: Date, total_deposit: Coins, metadata: string, title: string, summary: string, proposer: AccAddress, voting_start_time?: Date | undefined, voting_end_time?: Date | undefined);
	static fromAmino(data: Proposal.Amino, isClassic?: boolean): Proposal;
	toAmino(isClassic?: boolean): Proposal.Amino;
	static fromData(data: Proposal.Data, isClassic?: boolean): Proposal;
	toData(isClassic?: boolean): Proposal.Data;
	static fromProto(data: Proposal.Proto, isClassic?: boolean): Proposal;
	toProto(isClassic?: boolean): Proposal.Proto;
}
export declare namespace Proposal {
	const Status: typeof ProposalStatus$1;
	type Status = ProposalStatus$1;
	interface FinalTallyResult {
		yes_count: Int;
		abstain_count: Int;
		no_count: Int;
		no_with_veto_count: Int;
	}
	type Message = TextProposal | CommunityPoolSpendProposal | ParameterChangeProposal | SoftwareUpgradeProposal | CancelSoftwareUpgradeProposal | MsgCreateAllianceProposal | MsgUpdateAllianceProposal | MsgDeleteAllianceProposal | MsgCreateAlliance | MsgUpdateAlliance | MsgDeleteAlliance | ClientUpdateProposal | ClearAdminProposal | ExecuteContractProposal | InstantiateContractProposal | MigrateContractProposal | PinCodesProposal | StoreCodeProposal | SudoContractProposal | UnpinCodesProposal | UpdateAdminProposal | UpdateInstantiateConfigProposal;
	namespace Message {
		type Amino = TextProposal.Amino | CommunityPoolSpendProposal.Amino | ParameterChangeProposal.Amino | SoftwareUpgradeProposal.Amino | CancelSoftwareUpgradeProposal.Amino | MsgCreateAllianceProposal.Amino | MsgUpdateAllianceProposal.Amino | MsgDeleteAllianceProposal.Amino | MsgCreateAlliance.Amino | MsgUpdateAlliance.Amino | MsgDeleteAlliance.Amino | ClientUpdateProposal.Amino | ClearAdminProposal.Amino | ExecuteContractProposal.Amino | InstantiateContractProposal.Amino | MigrateContractProposal.Amino | PinCodesProposal.Amino | StoreCodeProposal.Amino | SudoContractProposal.Amino | UnpinCodesProposal.Amino | UpdateAdminProposal.Amino | UpdateInstantiateConfigProposal.Amino | any;
		type Data = TextProposal.Data | CommunityPoolSpendProposal.Data | ParameterChangeProposal.Data | SoftwareUpgradeProposal.Data | CancelSoftwareUpgradeProposal.Data | MsgCreateAllianceProposal.Data | MsgUpdateAllianceProposal.Data | MsgDeleteAllianceProposal.Data | MsgCreateAlliance.Data | MsgUpdateAlliance.Data | MsgDeleteAlliance.Data | ClientUpdateProposal.Data | ClearAdminProposal.Data | ExecuteContractProposal.Data | InstantiateContractProposal.Data | MigrateContractProposal.Data | PinCodesProposal.Data | StoreCodeProposal.Data | SudoContractProposal.Data | UnpinCodesProposal.Data | UpdateAdminProposal.Data | UpdateInstantiateConfigProposal.Data | any;
		type Proto = TextProposal.Proto | CommunityPoolSpendProposal.Proto | ParameterChangeProposal.Proto | SoftwareUpgradeProposal.Proto | CancelSoftwareUpgradeProposal.Proto | MsgCreateAllianceProposal.Proto | MsgUpdateAllianceProposal.Proto | MsgDeleteAllianceProposal.Proto | MsgCreateAlliance.Proto | MsgUpdateAlliance.Proto | MsgDeleteAlliance.Proto | ClientUpdateProposal.Proto | ClearAdminProposal.Proto | ExecuteContractProposal.Proto | InstantiateContractProposal.Proto | MigrateContractProposal.Proto | PinCodesProposal.Proto | StoreCodeProposal.Proto | SudoContractProposal.Proto | UnpinCodesProposal.Proto | UpdateAdminProposal.Proto | UpdateInstantiateConfigProposal.Proto | undefined;
		function fromAmino(amino: Message.Amino, isClassic?: boolean): Message;
		function fromData(data: Message.Data, isClassic?: boolean): Message;
		function fromProto(anyProto: Any$1, isClassic?: boolean): Message | undefined;
	}
	interface Amino {
		id: string;
		messages: Message.Amino[];
		status: number;
		final_tally_result: {
			yes_count: string;
			abstain_count: string;
			no_count: string;
			no_with_veto_count: string;
		};
		submit_time: string;
		deposit_end_time: string;
		total_deposit: Coins.Amino;
		metadata: string;
		title: string;
		summary: string;
		proposer: string;
		voting_start_time?: string;
		voting_end_time?: string;
	}
	interface Data {
		id: string;
		messages: Message.Data[];
		status: string;
		final_tally_result: {
			yes_count: string;
			abstain_count: string;
			no_count: string;
			no_with_veto_count: string;
		};
		submit_time: string;
		deposit_end_time: string;
		total_deposit: Coins.Data;
		metadata: string;
		title: string;
		summary: string;
		proposer: string;
		voting_start_time?: string;
		voting_end_time?: string;
	}
	type Proto = Proposal_pb$1;
}
/**
 * Submit a proposal alongside an initial deposit.
 */
export declare class MsgSubmitProposal extends JSONSerializable<MsgSubmitProposal.Amino, MsgSubmitProposal.Data, MsgSubmitProposal.Proto> {
	messages: Proposal.Message[];
	initial_deposit: Coins;
	proposer: AccAddress;
	metadata: string;
	title: string;
	summary: string;
	/**
	 * @param messages proposal message to submit
	 * @param initial_deposit deposit provided
	 * @param proposer proposer's account address
	 */
	constructor(messages: Proposal.Message[], initial_deposit: Coins, proposer: AccAddress, metadata: string, title: string, summary: string);
	static fromAmino(data: MsgSubmitProposal.Amino, _?: boolean): MsgSubmitProposal;
	toAmino(_?: boolean): MsgSubmitProposal.Amino;
	static fromData(data: MsgSubmitProposal.Data, _?: boolean): MsgSubmitProposal;
	toData(_?: boolean): MsgSubmitProposal.Data;
	static fromProto(proto: MsgSubmitProposal.Proto, _?: boolean): MsgSubmitProposal;
	toProto(_?: boolean): MsgSubmitProposal.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgSubmitProposal;
}
export declare namespace MsgSubmitProposal {
	interface Amino {
		type: "cosmos-sdk/v1/MsgSubmitProposal";
		value: {
			/** messages are the arbitrary messages to be executed if proposal passes. */
			messages: Proposal.Message.Amino[];
			/** initial_deposit is the deposit value that must be paid at proposal submission. */
			initial_deposit: Coins.Amino;
			/** proposer is the account address of the proposer. */
			proposer: AccAddress;
			/** metadata is any arbitrary metadata attached to the proposal. */
			metadata: string;
			/**
			 * title is the title of the proposal.
			 *
			 * Since: cosmos-sdk 0.47
			 */
			title: string;
			/**
			 * summary is the summary of the proposal
			 *
			 * Since: cosmos-sdk 0.47
			 */
			summary: string;
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1.MsgSubmitProposal";
		/** messages are the arbitrary messages to be executed if proposal passes. */
		messages: Proposal.Message.Data[];
		/** initial_deposit is the deposit value that must be paid at proposal submission. */
		initial_deposit: Coins.Data;
		/** proposer is the account address of the proposer. */
		proposer: AccAddress;
		/** metadata is any arbitrary metadata attached to the proposal. */
		metadata: string;
		/**
		 * title is the title of the proposal.
		 *
		 * Since: cosmos-sdk 0.47
		 */
		title: string;
		/**
		 * summary is the summary of the proposal
		 *
		 * Since: cosmos-sdk 0.47
		 */
		summary: string;
	}
	type Proto = MsgSubmitProposal_pb;
}
/**
 * Vote for a proposal
 */
export declare class MsgVote extends JSONSerializable<MsgVote.Amino, MsgVote.Data, MsgVote.Proto> {
	proposal_id: number;
	voter: AccAddress;
	option: VoteOption$1;
	/**
	 * @param proposal_id ID of proposal to vote on
	 * @param voter voter's account address
	 * @param option one of voting options
	 */
	constructor(proposal_id: number, voter: AccAddress, option: VoteOption$1);
	static fromAmino(data: MsgVote.Amino, _?: boolean): MsgVote;
	toAmino(_?: boolean): MsgVote.Amino;
	static fromData(data: MsgVote.Data, _?: boolean): MsgVote;
	toData(_?: boolean): MsgVote.Data;
	static fromProto(proto: MsgVote.Proto, _?: boolean): MsgVote;
	toProto(_?: boolean): MsgVote.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgVote;
}
export declare namespace MsgVote {
	const Option: typeof VoteOption$1;
	type Option = VoteOption$1;
	interface Amino {
		type: "cosmos-sdk/v1/MsgVote";
		value: {
			proposal_id: string;
			voter: AccAddress;
			option: VoteOption$1;
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1.MsgVote";
		proposal_id: string;
		voter: AccAddress;
		option: Option;
	}
	type Proto = MsgVote_pb;
}
/**
 * Add a deposit for a proposal
 */
export declare class MsgDeposit extends JSONSerializable<MsgDeposit.Amino, MsgDeposit.Data, MsgDeposit.Proto> {
	proposal_id: number;
	depositor: AccAddress;
	amount: Coins;
	/**
	 * @param proposal_id Id of porposal to deposit to
	 * @param depositor depositor's account address
	 * @param amount amount to deposit
	 */
	constructor(proposal_id: number, depositor: AccAddress, amount: Coins.Input);
	static fromAmino(data: MsgDeposit.Amino, _?: boolean): MsgDeposit;
	toAmino(_?: boolean): MsgDeposit.Amino;
	static fromData(data: MsgDeposit.Data, _?: boolean): MsgDeposit;
	toData(_?: boolean): MsgDeposit.Data;
	static fromProto(proto: MsgDeposit.Proto, _?: boolean): MsgDeposit;
	toProto(_?: boolean): MsgDeposit.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgDeposit;
}
export declare namespace MsgDeposit {
	interface Amino {
		type: "cosmos-sdk/v1/MsgDeposit";
		value: {
			proposal_id: string;
			depositor: AccAddress;
			amount: Coins.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1.MsgDeposit";
		proposal_id: string;
		depositor: AccAddress;
		amount: Coins.Data;
	}
	type Proto = MsgDeposit_pb;
}
/**
 * Stores vote information for a proposal
 */
export declare class Vote extends JSONSerializable<Vote.Amino, Vote.Data, Vote.Proto> {
	proposal_id: number;
	voter: AccAddress;
	options: WeightedVoteOption[];
	Option: typeof VoteOption$1;
	/**
	 * @param proposal_id ID of proposal to vote on
	 * @param voter voter's account address
	 * @param options voting options
	 */
	constructor(proposal_id: number, voter: AccAddress, options: WeightedVoteOption[]);
	static fromAmino(data: Vote.Amino, _?: boolean): Vote;
	toAmino(_?: boolean): Vote.Amino;
	static fromData(data: Vote.Data, _?: boolean): Vote;
	toData(_?: boolean): Vote.Data;
	static fromProto(proto: Vote.Proto, _?: boolean): Vote;
	toProto(_?: boolean): Vote.Proto;
}
export declare namespace Vote {
	const Option: typeof VoteOption$1;
	type Option = VoteOption$1;
	interface Amino {
		proposal_id: string;
		voter: AccAddress;
		options: WeightedVoteOption.Amino[];
	}
	interface Data {
		proposal_id: string;
		voter: AccAddress;
		options: WeightedVoteOption.Data[];
	}
	type Proto = Vote_pb$1;
}
export declare class WeightedVoteOption extends JSONSerializable<WeightedVoteOption.Amino, WeightedVoteOption.Data, WeightedVoteOption.Proto> {
	option: VoteOption$1;
	weight: Dec;
	constructor(option: VoteOption$1, weight: Numeric.Input);
	static fromAmino(data: WeightedVoteOption.Amino, _?: boolean): WeightedVoteOption;
	toAmino(_?: boolean): WeightedVoteOption.Amino;
	static fromData(data: WeightedVoteOption.Data, _?: boolean): WeightedVoteOption;
	toData(_?: boolean): WeightedVoteOption.Data;
	static fromProto(proto: WeightedVoteOption.Proto, _?: boolean): WeightedVoteOption;
	toProto(_?: boolean): WeightedVoteOption.Proto;
}
export declare namespace WeightedVoteOption {
	interface Amino {
		option: VoteOption$1;
		weight: string;
	}
	interface Data {
		option: VoteOption$1;
		weight: string;
	}
	type Proto = WeightedVoteOption_pb$1;
}
/**
 * Weighted vote for a proposal
 */
export declare class MsgVoteWeighted extends JSONSerializable<MsgVoteWeighted.Amino, MsgVoteWeighted.Data, MsgVoteWeighted.Proto> {
	proposal_id: number;
	voter: AccAddress;
	options: WeightedVoteOption[];
	/**
	 * @param proposal_id ID of proposal to vote on
	 * @param voter voter's account address
	 * @param option one of voting options
	 */
	constructor(proposal_id: number, voter: AccAddress, options: WeightedVoteOption[]);
	static fromAmino(data: MsgVoteWeighted.Amino, _?: boolean): MsgVoteWeighted;
	toAmino(_?: boolean): MsgVoteWeighted.Amino;
	static fromData(data: MsgVoteWeighted.Data, _?: boolean): MsgVoteWeighted;
	toData(_?: boolean): MsgVoteWeighted.Data;
	static fromProto(proto: MsgVoteWeighted.Proto, _?: boolean): MsgVoteWeighted;
	toProto(_?: boolean): MsgVoteWeighted.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgVoteWeighted;
}
export declare namespace MsgVoteWeighted {
	interface Amino {
		type: "cosmos-sdk/v1/MsgVoteWeighted";
		value: {
			proposal_id: string;
			voter: AccAddress;
			options: WeightedVoteOption.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1.MsgVoteWeighted";
		proposal_id: string;
		voter: AccAddress;
		options: WeightedVoteOption.Data[];
	}
	type Proto = MsgVoteWeighted_pb;
}
/**
 * Proposals submited throught the legacy governance module v1beta1
 */
export declare class MsgExecLegacyContent extends JSONSerializable<MsgExecLegacyContent.Amino, MsgExecLegacyContent.Data, MsgExecLegacyContent.Proto> {
	authority: AccAddress;
	content?: Any$1 | undefined;
	/**
	 * @param content Any content type being the proto
	 * @param authority the authority to execute the content (e.g. normally the governance module)
	 */
	constructor(authority: AccAddress, content?: Any$1 | undefined);
	static fromAmino(data: MsgExecLegacyContent.Amino, _?: boolean): MsgExecLegacyContent;
	toAmino(_?: boolean): MsgExecLegacyContent.Amino;
	static fromData(data: MsgExecLegacyContent.Data, _?: boolean): MsgExecLegacyContent;
	toData(_?: boolean): MsgExecLegacyContent.Data;
	static fromProto(proto: MsgExecLegacyContent.Proto, _?: boolean): MsgExecLegacyContent;
	toProto(_?: boolean): MsgExecLegacyContent.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgExecLegacyContent;
}
export declare namespace MsgExecLegacyContent {
	interface Amino {
		type: "cosmos-sdk/v1/MsgExecLegacyContent";
		value: {
			content?: Any$1;
			authority: AccAddress;
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1.MsgExecLegacyContent";
		content?: any;
		authority: AccAddress;
	}
	type Proto = MsgExecLegacyContent_pb;
}
export type GovMsg = MsgDeposit | MsgSubmitProposal | MsgVote | MsgVoteWeighted | MsgExecLegacyContent;
export declare namespace GovMsg {
	type Amino = MsgDeposit.Amino | MsgSubmitProposal.Amino | MsgVote.Amino | MsgVoteWeighted.Amino | MsgExecLegacyContent.Amino;
	type Data = MsgDeposit.Data | MsgSubmitProposal.Data | MsgVote.Data | MsgVoteWeighted.Data | MsgExecLegacyContent.Data;
	type Proto = MsgDeposit.Proto | MsgSubmitProposal.Proto | MsgVote.Proto | MsgVoteWeighted.Proto | MsgExecLegacyContent.Proto;
}
/**
 * Stores information pertaining to a submitted proposal, such as its status and time of
 * the voting period
 * @deprecated Please use v1.Proposal instead
 */
declare class Proposal$1 extends JSONSerializable<Proposal$1.Amino, Proposal$1.Data, Proposal$1.Proto> {
	id: number;
	content: Proposal$1.Content | undefined;
	status: ProposalStatus;
	final_tally_result: Proposal$1.FinalTallyResult;
	submit_time: Date;
	deposit_end_time: Date;
	total_deposit: Coins;
	voting_start_time: Date;
	voting_end_time: Date;
	/**
	 *
	 * @param id proposal's ID
	 * @param content content of the proposal
	 * @param status proposal's status
	 * @param final_tally_result tally result
	 * @param submit_time time proposal was submitted and deposit period started
	 * @param deposit_end_time time deposit period will end
	 * @param total_deposit amount of coins deposited by all users
	 * @param voting_start_time time voting period will start
	 * @param voting_end_time time voting period will end
	 */
	constructor(id: number, content: Proposal$1.Content | undefined, status: ProposalStatus, final_tally_result: Proposal$1.FinalTallyResult, submit_time: Date, deposit_end_time: Date, total_deposit: Coins, voting_start_time: Date, voting_end_time: Date);
	static fromAmino(data: Proposal$1.Amino, isClassic?: boolean): Proposal$1;
	toAmino(isClassic?: boolean): Proposal$1.Amino;
	static fromData(data: Proposal$1.Data, isClassic?: boolean): Proposal$1;
	toData(isClassic?: boolean): Proposal$1.Data;
	static fromProto(data: Proposal$1.Proto, isClassic?: boolean): Proposal$1;
	toProto(isClassic?: boolean): Proposal$1.Proto;
}
declare namespace Proposal$1 {
	const Status: typeof ProposalStatus;
	type Status = ProposalStatus;
	interface FinalTallyResult {
		yes: Int;
		abstain: Int;
		no: Int;
		no_with_veto: Int;
	}
	type Content = TextProposal | CommunityPoolSpendProposal | ParameterChangeProposal | SoftwareUpgradeProposal | CancelSoftwareUpgradeProposal | MsgCreateAllianceProposal | MsgUpdateAllianceProposal | MsgDeleteAllianceProposal | ClientUpdateProposal | ClearAdminProposal | ExecuteContractProposal | InstantiateContractProposal | MigrateContractProposal | PinCodesProposal | StoreCodeProposal | SudoContractProposal | UnpinCodesProposal | UpdateAdminProposal | UpdateInstantiateConfigProposal;
	namespace Content {
		type Amino = TextProposal.Amino | CommunityPoolSpendProposal.Amino | ParameterChangeProposal.Amino | SoftwareUpgradeProposal.Amino | CancelSoftwareUpgradeProposal.Amino | MsgCreateAllianceProposal.Amino | MsgUpdateAllianceProposal.Amino | MsgDeleteAllianceProposal.Amino | ClientUpdateProposal.Amino | ClearAdminProposal.Amino | ExecuteContractProposal.Amino | InstantiateContractProposal.Amino | MigrateContractProposal.Amino | PinCodesProposal.Amino | StoreCodeProposal.Amino | SudoContractProposal.Amino | UnpinCodesProposal.Amino | UpdateAdminProposal.Amino | UpdateInstantiateConfigProposal.Amino | undefined;
		type Data = TextProposal.Data | CommunityPoolSpendProposal.Data | ParameterChangeProposal.Data | SoftwareUpgradeProposal.Data | CancelSoftwareUpgradeProposal.Data | MsgCreateAllianceProposal.Data | MsgUpdateAllianceProposal.Data | MsgDeleteAllianceProposal.Data | ClientUpdateProposal.Data | ClearAdminProposal.Data | ExecuteContractProposal.Data | InstantiateContractProposal.Data | MigrateContractProposal.Data | PinCodesProposal.Data | StoreCodeProposal.Data | SudoContractProposal.Data | UnpinCodesProposal.Data | UpdateAdminProposal.Data | UpdateInstantiateConfigProposal.Data | undefined;
		type Proto = TextProposal.Proto | CommunityPoolSpendProposal.Proto | ParameterChangeProposal.Proto | SoftwareUpgradeProposal.Proto | CancelSoftwareUpgradeProposal.Proto | MsgCreateAllianceProposal.Proto | MsgUpdateAllianceProposal.Proto | MsgDeleteAllianceProposal.Proto | ClientUpdateProposal.Proto | ClearAdminProposal.Proto | ExecuteContractProposal.Proto | InstantiateContractProposal.Proto | MigrateContractProposal.Proto | PinCodesProposal.Proto | StoreCodeProposal.Proto | SudoContractProposal.Proto | UnpinCodesProposal.Proto | UpdateAdminProposal.Proto | UpdateInstantiateConfigProposal.Proto | undefined;
		function fromAmino(amino: Proposal$1.Content.Amino, isClassic?: boolean): Proposal$1.Content | undefined;
		function fromData(data: Proposal$1.Content.Data, isClassic?: boolean): Proposal$1.Content | undefined;
		function fromProto(anyProto: Any$1, isClassic?: boolean): Proposal$1.Content;
	}
	interface Amino {
		content: Content.Amino;
		id: string;
		status: number;
		final_tally_result: {
			yes: string;
			abstain: string;
			no: string;
			no_with_veto: string;
		};
		submit_time: string;
		deposit_end_time: string;
		total_deposit: Coins.Amino;
		voting_start_time: string;
		voting_end_time: string;
	}
	interface Data {
		content: Content.Data;
		proposal_id: string;
		status: string;
		final_tally_result: {
			yes: string;
			abstain: string;
			no: string;
			no_with_veto: string;
		};
		submit_time: string;
		deposit_end_time: string;
		total_deposit: Coins.Data;
		voting_start_time: string;
		voting_end_time: string;
	}
	type Proto = Proposal_pb;
}
/**
 * Submit a proposal alongside an initial deposit.
 * @deprecated Please use v1.MsgSubmitProposal instead
 */
declare class MsgSubmitProposal$1 extends JSONSerializable<MsgSubmitProposal$1.Amino, MsgSubmitProposal$1.Data, MsgSubmitProposal$1.Proto> {
	content: Proposal$1.Content;
	proposer: AccAddress;
	initial_deposit: Coins;
	/**
	 * @param content proposal content to submit
	 * @param initial_deposit deposit provided
	 * @param proposer proposer's account address
	 */
	constructor(content: Proposal$1.Content, initial_deposit: Coins.Input, proposer: AccAddress);
	static fromAmino(data: MsgSubmitProposal$1.Amino, isClassic?: boolean): MsgSubmitProposal$1;
	toAmino(isClassic?: boolean): MsgSubmitProposal$1.Amino;
	static fromData(data: MsgSubmitProposal$1.Data, isClassic?: boolean): MsgSubmitProposal$1;
	toData(isClassic?: boolean): MsgSubmitProposal$1.Data;
	static fromProto(proto: MsgSubmitProposal$1.Proto, isClassic?: boolean): MsgSubmitProposal$1;
	toProto(isClassic?: boolean): MsgSubmitProposal$1.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgSubmitProposal$1;
}
declare namespace MsgSubmitProposal$1 {
	interface Amino {
		type: "gov/MsgSubmitProposal" | "cosmos-sdk/MsgSubmitProposal";
		value: {
			content: Proposal$1.Content.Amino;
			initial_deposit: Coins.Amino;
			proposer: AccAddress;
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1beta1.MsgSubmitProposal";
		content: Proposal$1.Content.Data;
		initial_deposit: Coins.Data;
		proposer: AccAddress;
	}
	type Proto = MsgSubmitProposal_pb$1;
}
/**
 * Vote for a proposal
 * @deprecated Please use v1.MsgVote instead
 */
declare class MsgVote$1 extends JSONSerializable<MsgVote$1.Amino, MsgVote$1.Data, MsgVote$1.Proto> {
	proposal_id: number;
	voter: AccAddress;
	option: VoteOption;
	/**
	 * @param proposal_id ID of proposal to vote on
	 * @param voter voter's account address
	 * @param option one of voting options
	 */
	constructor(proposal_id: number, voter: AccAddress, option: VoteOption);
	static fromAmino(data: MsgVote$1.Amino, _?: boolean): MsgVote$1;
	toAmino(isClassic?: boolean): MsgVote$1.Amino;
	static fromData(data: MsgVote$1.Data, _?: boolean): MsgVote$1;
	toData(_?: boolean): MsgVote$1.Data;
	static fromProto(proto: MsgVote$1.Proto, _?: boolean): MsgVote$1;
	toProto(_?: boolean): MsgVote$1.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgVote$1;
}
declare namespace MsgVote$1 {
	const Option: typeof VoteOption;
	type Option = VoteOption;
	interface Amino {
		type: "gov/MsgVote" | "cosmos-sdk/MsgVote";
		value: {
			proposal_id: string;
			voter: AccAddress;
			option: VoteOption;
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1beta1.MsgVote";
		proposal_id: string;
		voter: AccAddress;
		option: Option;
	}
	type Proto = MsgVote_pb$1;
}
/**
 * Add a deposit for a proposal
 * @deprecated Please use v1.MsgDeposit instead
 */
declare class MsgDeposit$1 extends JSONSerializable<MsgDeposit$1.Amino, MsgDeposit$1.Data, MsgDeposit$1.Proto> {
	proposal_id: number;
	depositor: AccAddress;
	amount: Coins;
	/**
	 * @param proposal_id Id of porposal to deposit to
	 * @param depositor depositor's account address
	 * @param amount amount to deposit
	 */
	constructor(proposal_id: number, depositor: AccAddress, amount: Coins.Input);
	static fromAmino(data: MsgDeposit$1.Amino, _?: boolean): MsgDeposit$1;
	toAmino(isClassic?: boolean): MsgDeposit$1.Amino;
	static fromData(data: MsgDeposit$1.Data, _?: boolean): MsgDeposit$1;
	toData(_?: boolean): MsgDeposit$1.Data;
	static fromProto(proto: MsgDeposit$1.Proto, _?: boolean): MsgDeposit$1;
	toProto(_?: boolean): MsgDeposit$1.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgDeposit$1;
}
declare namespace MsgDeposit$1 {
	interface Amino {
		type: "gov/MsgDeposit" | "cosmos-sdk/MsgDeposit";
		value: {
			proposal_id: string;
			depositor: AccAddress;
			amount: Coins.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1beta1.MsgDeposit";
		proposal_id: string;
		depositor: AccAddress;
		amount: Coins.Data;
	}
	type Proto = MsgDeposit_pb$1;
}
/**
 * Stores vote information for a proposal
 * @deprecated Please use v1.Vote instead
 */
declare class Vote$1 extends JSONSerializable<Vote$1.Amino, Vote$1.Data, Vote$1.Proto> {
	proposal_id: number;
	voter: AccAddress;
	options: WeightedVoteOption$1[];
	Option: typeof VoteOption;
	/**
	 * @param proposal_id ID of proposal to vote on
	 * @param voter voter's account address
	 * @param options voting options
	 */
	constructor(proposal_id: number, voter: AccAddress, options: WeightedVoteOption$1[]);
	static fromAmino(data: Vote$1.Amino, _?: boolean): Vote$1;
	toAmino(_?: boolean): Vote$1.Amino;
	static fromData(data: Vote$1.Data, _?: boolean): Vote$1;
	toData(_?: boolean): Vote$1.Data;
	static fromProto(proto: Vote$1.Proto, _?: boolean): Vote$1;
	toProto(_?: boolean): Vote$1.Proto;
}
declare namespace Vote$1 {
	const Option: typeof VoteOption;
	type Option = VoteOption;
	interface Amino {
		proposal_id: string;
		voter: AccAddress;
		options: WeightedVoteOption$1.Amino[];
	}
	interface Data {
		proposal_id: string;
		voter: AccAddress;
		options: WeightedVoteOption$1.Data[];
	}
	type Proto = Vote_pb;
}
declare class WeightedVoteOption$1 extends JSONSerializable<WeightedVoteOption$1.Amino, WeightedVoteOption$1.Data, WeightedVoteOption$1.Proto> {
	option: VoteOption;
	weight: Dec;
	constructor(option: VoteOption, weight: Numeric.Input);
	static fromAmino(data: WeightedVoteOption$1.Amino, _?: boolean): WeightedVoteOption$1;
	toAmino(_?: boolean): WeightedVoteOption$1.Amino;
	static fromData(data: WeightedVoteOption$1.Data, _?: boolean): WeightedVoteOption$1;
	toData(_?: boolean): WeightedVoteOption$1.Data;
	static fromProto(proto: WeightedVoteOption$1.Proto, _?: boolean): WeightedVoteOption$1;
	toProto(_?: boolean): WeightedVoteOption$1.Proto;
}
declare namespace WeightedVoteOption$1 {
	interface Amino {
		option: VoteOption;
		weight: string;
	}
	interface Data {
		option: VoteOption;
		weight: string;
	}
	type Proto = WeightedVoteOption_pb;
}
/**
 * Weighted vote for a proposal
 * @deprecated Please use v1.MsgVoteWeighted instead
 */
declare class MsgVoteWeighted$1 extends JSONSerializable<MsgVoteWeighted$1.Amino, MsgVoteWeighted$1.Data, MsgVoteWeighted$1.Proto> {
	proposal_id: number;
	voter: AccAddress;
	options: WeightedVoteOption$1[];
	/**
	 * @param proposal_id ID of proposal to vote on
	 * @param voter voter's account address
	 * @param option one of voting options
	 */
	constructor(proposal_id: number, voter: AccAddress, options: WeightedVoteOption$1[]);
	static fromAmino(data: MsgVoteWeighted$1.Amino, _?: boolean): MsgVoteWeighted$1;
	toAmino(isClassic?: boolean): MsgVoteWeighted$1.Amino;
	static fromData(data: MsgVoteWeighted$1.Data, _?: boolean): MsgVoteWeighted$1;
	toData(_?: boolean): MsgVoteWeighted$1.Data;
	static fromProto(proto: MsgVoteWeighted$1.Proto, _?: boolean): MsgVoteWeighted$1;
	toProto(_?: boolean): MsgVoteWeighted$1.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgVoteWeighted$1;
}
declare namespace MsgVoteWeighted$1 {
	interface Amino {
		type: "gov/MsgVoteWeighted" | "cosmos-sdk/MsgVoteWeighted";
		value: {
			proposal_id: string;
			voter: AccAddress;
			options: WeightedVoteOption$1.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmos.gov.v1beta1.MsgVoteWeighted";
		proposal_id: string;
		voter: AccAddress;
		options: WeightedVoteOption$1.Data[];
	}
	type Proto = MsgVoteWeighted_pb$1;
}
type GovMsg$1 = MsgDeposit$1 | MsgSubmitProposal$1 | MsgVote$1 | MsgVoteWeighted$1;
declare namespace GovMsg$1 {
	type Amino = MsgDeposit$1.Amino | MsgSubmitProposal$1.Amino | MsgVote$1.Amino | MsgVoteWeighted$1.Amino;
	type Data = MsgDeposit$1.Data | MsgSubmitProposal$1.Data | MsgVote$1.Data | MsgVoteWeighted$1.Data;
	type Proto = MsgDeposit$1.Proto | MsgSubmitProposal$1.Proto | MsgVote$1.Proto | MsgVoteWeighted$1.Proto;
}
export declare class StakeAuthorization extends JSONSerializable<any, StakeAuthorization.Data, StakeAuthorization.Proto> {
	authorization_type: AuthorizationType;
	max_tokens?: Coin | undefined;
	allow_list?: StakeAuthorizationValidators | undefined;
	deny_list?: StakeAuthorizationValidators | undefined;
	constructor(authorization_type: AuthorizationType, max_tokens?: Coin | undefined, allow_list?: StakeAuthorizationValidators | undefined, deny_list?: StakeAuthorizationValidators | undefined);
	static fromAmino(_: any, isClassic?: boolean): StakeAuthorizationValidators;
	toAmino(_?: boolean): any;
	static fromData(data: StakeAuthorization.Data, isClassic?: boolean): StakeAuthorization;
	toData(isClassic?: boolean): StakeAuthorization.Data;
	static fromProto(proto: StakeAuthorization.Proto, isClassic?: boolean): StakeAuthorization;
	toProto(isClassic?: boolean): StakeAuthorization.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): StakeAuthorization;
}
export declare class StakeAuthorizationValidators extends JSONSerializable<any, StakeAuthorizationValidators.Data, StakeAuthorizationValidators.Proto> {
	address: AccAddress[];
	constructor(address: AccAddress[]);
	static fromAmino(_: any, isClassic?: boolean): StakeAuthorizationValidators;
	toAmino(_?: boolean): any;
	static fromData(data: StakeAuthorizationValidators.Data, _?: boolean): StakeAuthorizationValidators;
	toData(_?: boolean): StakeAuthorizationValidators.Data;
	static fromProto(proto: StakeAuthorizationValidators.Proto, _?: boolean): StakeAuthorizationValidators;
	toProto(_?: boolean): StakeAuthorizationValidators.Proto;
}
export declare namespace StakeAuthorizationValidators {
	interface Data {
		address: AccAddress[];
	}
	type Proto = StakeAuthorizationValidators_pb;
}
export declare namespace StakeAuthorization {
	type Type = AuthorizationType;
	const Type: typeof AuthorizationType;
	interface Data {
		"@type": "/cosmos.staking.v1beta1.StakeAuthorization";
		max_tokens?: Coin.Data;
		allow_list?: StakeAuthorizationValidators.Data;
		deny_list?: StakeAuthorizationValidators.Data;
		authorization_type: string;
	}
	type Proto = StakeAuthorization_pb;
}
export declare class SendAuthorization extends JSONSerializable<SendAuthorization.Amino, SendAuthorization.Data, SendAuthorization.Proto> {
	spend_limit: Coins;
	constructor(spend_limit: Coins.Input);
	static fromAmino(data: SendAuthorization.Amino, _?: boolean): SendAuthorization;
	toAmino(isClassic?: boolean): SendAuthorization.Amino;
	static fromData(data: SendAuthorization.Data, _?: boolean): SendAuthorization;
	toData(_?: boolean): SendAuthorization.Data;
	static fromProto(proto: SendAuthorization.Proto, _?: boolean): SendAuthorization;
	toProto(_?: boolean): SendAuthorization.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): SendAuthorization;
}
export declare namespace SendAuthorization {
	interface Amino {
		type: "msgauth/SendAuthorization" | "cosmos-sdk/SendAuthorization";
		value: {
			spend_limit: Coins.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.bank.v1beta1.SendAuthorization";
		spend_limit: Coins.Data;
	}
	type Proto = SendAuthorization_pb;
}
export declare class GenericAuthorization extends JSONSerializable<GenericAuthorization.Amino, GenericAuthorization.Data, GenericAuthorization.Proto> {
	msg: string;
	constructor(msg: string);
	static fromAmino(data: GenericAuthorization.Amino, _?: boolean): GenericAuthorization;
	toAmino(isClassic?: boolean): GenericAuthorization.Amino;
	static fromData(data: GenericAuthorization.Data, _?: boolean): GenericAuthorization;
	toData(_?: boolean): GenericAuthorization.Data;
	static fromProto(data: GenericAuthorization.Proto, _?: boolean): GenericAuthorization;
	toProto(_?: boolean): GenericAuthorization.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): GenericAuthorization;
}
export declare namespace GenericAuthorization {
	interface Amino {
		type: "msgauth/GenericAuthorization" | "cosmos-sdk/GenericAuthorization";
		value: {
			msg: string;
		};
	}
	interface Data {
		"@type": "/cosmos.authz.v1beta1.GenericAuthorization";
		msg: string;
	}
	type Proto = GenericAuthorization_pb;
}
export declare class AuthorizationGrant extends JSONSerializable<AuthorizationGrant.Amino, AuthorizationGrant.Data, AuthorizationGrant.Proto> {
	authorization: Authorization;
	expiration: Date;
	constructor(authorization: Authorization, expiration: Date);
	static fromAmino(amino: AuthorizationGrant.Amino, isClassic?: boolean): AuthorizationGrant;
	toAmino(isClassic?: boolean): AuthorizationGrant.Amino;
	static fromData(data: AuthorizationGrant.Data, isClassic?: boolean): AuthorizationGrant;
	toData(isClassic?: boolean): AuthorizationGrant.Data;
	static fromProto(proto: AuthorizationGrant.Proto, isClassic?: boolean): AuthorizationGrant;
	toProto(isClassic?: boolean): AuthorizationGrant.Proto;
}
export declare namespace AuthorizationGrant {
	interface Amino {
		authorization: Authorization.Amino;
		expiration: string;
	}
	interface Data {
		authorization: Authorization.Data;
		expiration: string;
	}
	type Proto = Grant_pb;
}
export type Authorization = SendAuthorization | GenericAuthorization | StakeAuthorization;
export declare namespace Authorization {
	type Amino = SendAuthorization.Amino | GenericAuthorization.Amino;
	type Data = SendAuthorization.Data | GenericAuthorization.Data | StakeAuthorization.Data;
	type Proto = Any$1;
	function fromAmino(data: Authorization.Amino, isClassic?: boolean): Authorization;
	function fromData(data: Authorization.Data, isClassic?: boolean): Authorization;
	function fromProto(proto: Authorization.Proto, isClassic?: boolean): Authorization;
}
export declare class MsgGrantAuthorization extends JSONSerializable<MsgGrantAuthorization.Amino, MsgGrantAuthorization.Data, MsgGrantAuthorization.Proto> {
	granter: AccAddress;
	grantee: AccAddress;
	grant: AuthorizationGrant;
	/**
	 * @param depositor depositor's account address
	 * @param amount coins to fund the community pool
	 */
	constructor(granter: AccAddress, grantee: AccAddress, grant: AuthorizationGrant);
	static fromAmino(data: MsgGrantAuthorization.Amino, isClassic?: boolean): MsgGrantAuthorization;
	toAmino(isClassic?: boolean): MsgGrantAuthorization.Amino;
	static fromData(data: MsgGrantAuthorization.Data, isClassic?: boolean): MsgGrantAuthorization;
	toData(isClassic?: boolean): MsgGrantAuthorization.Data;
	static fromProto(data: MsgGrantAuthorization.Proto, isClassic?: boolean): MsgGrantAuthorization;
	toProto(isClassic?: boolean): MsgGrantAuthorization.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgGrantAuthorization;
}
export declare namespace MsgGrantAuthorization {
	interface Amino {
		type: "msgauth/MsgGrantAuthorization" | "cosmos-sdk/MsgGrant";
		value: {
			granter: AccAddress;
			grantee: AccAddress;
			grant: AuthorizationGrant.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.authz.v1beta1.MsgGrant";
		granter: AccAddress;
		grantee: AccAddress;
		grant: AuthorizationGrant.Data;
	}
	type Proto = MsgGrant_pb;
}
export declare class MsgRevokeAuthorization extends JSONSerializable<MsgRevokeAuthorization.Amino, MsgRevokeAuthorization.Data, MsgRevokeAuthorization.Proto> {
	granter: AccAddress;
	grantee: AccAddress;
	msg_type_url: string;
	/**
	 * @param granter authorization granter
	 * @param grantee authorization grantee
	 * @param authorization_msg_type type of message to revoke
	 */
	constructor(granter: AccAddress, grantee: AccAddress, msg_type_url: string);
	static fromAmino(data: MsgRevokeAuthorization.Amino, _?: boolean): MsgRevokeAuthorization;
	toAmino(isClassic?: boolean): MsgRevokeAuthorization.Amino;
	static fromData(data: MsgRevokeAuthorization.Data, _?: boolean): MsgRevokeAuthorization;
	toData(_?: boolean): MsgRevokeAuthorization.Data;
	static fromProto(proto: MsgRevokeAuthorization.Proto, _?: boolean): MsgRevokeAuthorization;
	toProto(_?: boolean): MsgRevokeAuthorization.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgRevokeAuthorization;
}
export declare namespace MsgRevokeAuthorization {
	interface Amino {
		type: "msgauth/MsgRevokeAuthorization" | "cosmos-sdk/MsgRevoke";
		value: {
			granter: AccAddress;
			grantee: AccAddress;
			msg_type_url: string;
		};
	}
	interface Data {
		"@type": "/cosmos.authz.v1beta1.MsgRevoke";
		granter: AccAddress;
		grantee: AccAddress;
		msg_type_url: string;
	}
	type Proto = MsgRevoke_pb;
}
export declare class MsgExecAuthorized extends JSONSerializable<MsgExecAuthorized.Amino, MsgExecAuthorized.Data, MsgExecAuthorized.Proto> {
	grantee: AccAddress;
	msgs: Msg[];
	/**
	 * @param grantee authorization grantee
	 * @param msgs list of messages to execute
	 */
	constructor(grantee: AccAddress, msgs: Msg[]);
	static fromAmino(data: MsgExecAuthorized.Amino, isClassic?: boolean): MsgExecAuthorized;
	toAmino(isClassic?: boolean): MsgExecAuthorized.Amino;
	static fromData(proto: MsgExecAuthorized.Data, isClassic?: boolean): MsgExecAuthorized;
	toData(isClassic?: boolean): MsgExecAuthorized.Data;
	static fromProto(proto: MsgExecAuthorized.Proto, isClassic?: boolean): MsgExecAuthorized;
	toProto(isClassic?: boolean): MsgExecAuthorized.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgExecAuthorized;
}
export declare namespace MsgExecAuthorized {
	interface Amino {
		type: "msgauth/MsgExecAuthorized" | "cosmos-sdk/MsgExec";
		value: {
			grantee: AccAddress;
			msgs: Msg.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmos.authz.v1beta1.MsgExec";
		grantee: AccAddress;
		msgs: Msg.Data[];
	}
	type Proto = MsgExec_pb;
}
export type MsgAuthMsg = MsgGrantAuthorization | MsgRevokeAuthorization | MsgExecAuthorized;
export declare namespace MsgAuthMsg {
	type Amino = MsgGrantAuthorization.Amino | MsgRevokeAuthorization.Amino | MsgExecAuthorized.Amino;
	type Data = MsgGrantAuthorization.Data | MsgRevokeAuthorization.Data | MsgExecAuthorized.Data;
	type Proto = MsgGrantAuthorization.Proto | MsgRevokeAuthorization.Proto | MsgExecAuthorized.Proto;
}
/**
 * A validator can be jailed by the blockchain if misbehavior is detected, such as
 * double-signing or having missed too many vote periods in the Oracle ballot.
 *
 * This is done to protect delegators' funds from getting slashed further, until the
 * validator's issues have been addressed. A jailed validator cannot participate in
 * block rewards, and must be manually unjailed by submitting this message.
 */
export declare class MsgUnjail extends JSONSerializable<MsgUnjail.Amino, MsgUnjail.Data, MsgUnjail.Proto> {
	address: ValAddress;
	/**
	 * @param address validator's operator address
	 */
	constructor(address: ValAddress);
	static fromAmino(data: MsgUnjail.Amino, _?: boolean): MsgUnjail;
	toAmino(isClassic?: boolean): MsgUnjail.Amino;
	static fromData(proto: MsgUnjail.Data, _?: boolean): MsgUnjail;
	toData(_?: boolean): MsgUnjail.Data;
	static fromProto(proto: MsgUnjail.Proto, _?: boolean): MsgUnjail;
	toProto(_?: boolean): MsgUnjail.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgUnjail;
}
export declare namespace MsgUnjail {
	interface Amino {
		type: "slashing/MsgUnjail" | "cosmos-sdk/MsgUnjail";
		value: {
			address: ValAddress;
		};
	}
	interface Data {
		"@type": "/cosmos.slashing.v1beta1.MsgUnjail";
		address: ValAddress;
	}
	type Proto = MsgUnjail_pb;
}
export type SlashingMsg = MsgUnjail;
export declare namespace SlashingMsg {
	type Amino = MsgUnjail.Amino;
	type Data = MsgUnjail.Data;
	type Proto = MsgUnjail.Proto;
}
/**
 * A delegator can submit this message to send more Luna to be staked through a
 * validator delegate.
 */
export declare class MsgDelegate extends JSONSerializable<MsgDelegate.Amino, MsgDelegate.Data, MsgDelegate.Proto> {
	delegator_address: AccAddress;
	validator_address: ValAddress;
	amount: Coin;
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_address validator's operator address
	 * @param amount amount of LUNA to be sent for delegation
	 */
	constructor(delegator_address: AccAddress, validator_address: ValAddress, amount: Coin);
	static fromAmino(data: MsgDelegate.Amino, _?: boolean): MsgDelegate;
	toAmino(isClassic?: boolean): MsgDelegate.Amino;
	static fromProto(proto: MsgDelegate.Proto, _?: boolean): MsgDelegate;
	toProto(_?: boolean): MsgDelegate.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgDelegate;
	static fromData(data: MsgDelegate.Data, _?: boolean): MsgDelegate;
	toData(_?: boolean): MsgDelegate.Data;
}
export declare namespace MsgDelegate {
	interface Amino {
		type: "staking/MsgDelegate" | "cosmos-sdk/MsgDelegate";
		value: {
			delegator_address: AccAddress;
			validator_address: ValAddress;
			amount: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.staking.v1beta1.MsgDelegate";
		delegator_address: AccAddress;
		validator_address: ValAddress;
		amount: Coin.Data;
	}
	type Proto = MsgDelegate_pb;
}
/**
 * A delegator can undelegate an amount of bonded Luna, and will begin the unbonding
 * process for those funds. The unbonding process takes 21 days to complete, during
 * which the Luna cannot be transacted or swapped.
 */
export declare class MsgUndelegate extends JSONSerializable<MsgUndelegate.Amino, MsgUndelegate.Data, MsgUndelegate.Proto> {
	delegator_address: AccAddress;
	validator_address: ValAddress;
	amount: Coin;
	/**
	 * @param delegator_address delegator's account address
	 * @param validator_address validator's operator address
	 * @param amount Luna to be undelegated
	 */
	constructor(delegator_address: AccAddress, validator_address: ValAddress, amount: Coin);
	static fromAmino(data: MsgUndelegate.Amino, _?: boolean): MsgUndelegate;
	toAmino(isClassic?: boolean): MsgUndelegate.Amino;
	static fromProto(proto: MsgUndelegate.Proto, _?: boolean): MsgUndelegate;
	toProto(_?: boolean): MsgUndelegate.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgUndelegate;
	static fromData(data: MsgUndelegate.Data, _?: boolean): MsgUndelegate;
	toData(_?: boolean): MsgUndelegate.Data;
}
export declare namespace MsgUndelegate {
	interface Amino {
		type: "staking/MsgUndelegate" | "cosmos-sdk/MsgUndelegate";
		value: {
			delegator_address: AccAddress;
			validator_address: ValAddress;
			amount: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.staking.v1beta1.MsgUndelegate";
		delegator_address: AccAddress;
		validator_address: ValAddress;
		amount: Coin.Data;
	}
	type Proto = MsgUndelegate_pb;
}
/**
 * A delegator can choose to redelegate their bonded Luna and transfer a delegation
 * amount from one validator to another. Unlike undelegating, redelegations do not incur
 * a 21-day unbonding period and happen immediately.
 */
export declare class MsgBeginRedelegate extends JSONSerializable<MsgBeginRedelegate.Amino, MsgBeginRedelegate.Data, MsgBeginRedelegate.Proto> {
	delegator_address: AccAddress;
	validator_src_address: ValAddress;
	validator_dst_address: ValAddress;
	amount: Coin;
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_src_address validator to undelegate from
	 * @param validator_dst_address validator to delegate to
	 * @param amount LUNA to be redelegated
	 */
	constructor(delegator_address: AccAddress, validator_src_address: ValAddress, validator_dst_address: ValAddress, amount: Coin);
	static fromAmino(data: MsgBeginRedelegate.Amino, _?: boolean): MsgBeginRedelegate;
	toAmino(isClassic?: boolean): MsgBeginRedelegate.Amino;
	static fromData(data: MsgBeginRedelegate.Data, _?: boolean): MsgBeginRedelegate;
	toData(_?: boolean): MsgBeginRedelegate.Data;
	static fromProto(proto: MsgBeginRedelegate.Proto, _?: boolean): MsgBeginRedelegate;
	toProto(_?: boolean): MsgBeginRedelegate.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgBeginRedelegate;
}
export declare namespace MsgBeginRedelegate {
	interface Amino {
		type: "staking/MsgBeginRedelegate" | "cosmos-sdk/MsgBeginRedelegate";
		value: {
			delegator_address: AccAddress;
			validator_src_address: ValAddress;
			validator_dst_address: ValAddress;
			amount: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.staking.v1beta1.MsgBeginRedelegate";
		delegator_address: AccAddress;
		validator_src_address: ValAddress;
		validator_dst_address: ValAddress;
		amount: Coin.Data;
	}
	type Proto = MsgBeginRedelegate_pb;
}
export type PublicKey = SimplePublicKey | LegacyAminoMultisigPublicKey | ValConsPublicKey | InjectivePubKey;
export declare namespace PublicKey {
	type Amino = SimplePublicKey.Amino | LegacyAminoMultisigPublicKey.Amino | ValConsPublicKey.Amino | InjectivePubKey.Amino;
	type Data = SimplePublicKey.Data | LegacyAminoMultisigPublicKey.Data | ValConsPublicKey.Data | InjectivePubKey.Data;
	type Proto = Any$1;
	function fromAmino(data: PublicKey.Amino): PublicKey;
	function fromData(data: PublicKey.Data): PublicKey;
	function fromProto(pubkeyAny: PublicKey.Proto): PublicKey;
}
export declare class SimplePublicKey extends JSONSerializable<SimplePublicKey.Amino, SimplePublicKey.Data, SimplePublicKey.Proto> {
	key: string;
	constructor(key: string);
	static fromAmino(data: SimplePublicKey.Amino): SimplePublicKey;
	toAmino(): SimplePublicKey.Amino;
	static fromData(data: SimplePublicKey.Data): SimplePublicKey;
	toData(): SimplePublicKey.Data;
	static fromProto(pubkeyProto: SimplePublicKey.Proto): SimplePublicKey;
	toProto(): SimplePublicKey.Proto;
	packAny(): Any$1;
	static unpackAny(pubkeyAny: Any$1): SimplePublicKey;
	encodeAminoPubkey(): Uint8Array;
	rawAddress(): Uint8Array;
	address(prefix: string): string;
	pubkeyAddress(prefix: string): string;
}
export declare namespace SimplePublicKey {
	interface Amino {
		type: "tendermint/PubKeySecp256k1";
		value: string;
	}
	interface Data {
		"@type": "/cosmos.crypto.secp256k1.PubKey";
		key: string;
	}
	type Proto = PubKey_pb;
}
export declare class InjectivePubKey extends JSONSerializable<InjectivePubKey.Amino, InjectivePubKey.Data, InjectivePubKey.Proto> {
	key: string;
	constructor(key: string);
	static fromAmino(data: InjectivePubKey.Amino): InjectivePubKey;
	toAmino(): InjectivePubKey.Amino;
	static fromData(data: InjectivePubKey.Data): InjectivePubKey;
	toData(): InjectivePubKey.Data;
	static fromProto(pubkeyProto: InjectivePubKey.Proto): InjectivePubKey;
	toProto(): InjectivePubKey.Proto;
	packAny(): Any$1;
	static unpackAny(pubkeyAny: Any$1): InjectivePubKey;
	encodeAminoPubkey(): Uint8Array;
	rawEthAddress(): Uint8Array;
	address(prefix: string): string;
	pubkeyAddress(prefix: string): string;
}
export declare namespace InjectivePubKey {
	interface Amino {
		type: "tendermint/PubKeySecp256k1";
		value: string;
	}
	interface Data {
		"@type": "/injective.crypto.v1beta1.ethsecp256k1.PubKey";
		key: string;
	}
	type Proto = PubKey_pb;
}
export declare class LegacyAminoMultisigPublicKey extends JSONSerializable<LegacyAminoMultisigPublicKey.Amino, LegacyAminoMultisigPublicKey.Data, LegacyAminoMultisigPublicKey.Proto> {
	threshold: number;
	pubkeys: SimplePublicKey[];
	constructor(threshold: number, pubkeys: SimplePublicKey[]);
	encodeAminoPubkey(): Uint8Array;
	rawAddress(): Uint8Array;
	address(prefix: string): string;
	pubkeyAddress(prefix: string): string;
	static fromAmino(data: LegacyAminoMultisigPublicKey.Amino): LegacyAminoMultisigPublicKey;
	toAmino(): LegacyAminoMultisigPublicKey.Amino;
	static fromData(data: LegacyAminoMultisigPublicKey.Data): LegacyAminoMultisigPublicKey;
	toData(): LegacyAminoMultisigPublicKey.Data;
	static fromProto(pubkeyProto: LegacyAminoMultisigPublicKey.Proto): LegacyAminoMultisigPublicKey;
	toProto(): LegacyAminoMultisigPublicKey.Proto;
	packAny(): Any$1;
	static unpackAny(pubkeyAny: Any$1): LegacyAminoMultisigPublicKey;
}
export declare namespace LegacyAminoMultisigPublicKey {
	interface Amino {
		type: "tendermint/PubKeyMultisigThreshold";
		value: {
			threshold: string;
			pubkeys: SimplePublicKey.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmos.crypto.multisig.LegacyAminoPubKey";
		threshold: string;
		public_keys: SimplePublicKey.Data[];
	}
	type Proto = LegacyAminoPubKey_pb;
}
export declare class ValConsPublicKey extends JSONSerializable<ValConsPublicKey.Amino, ValConsPublicKey.Data, ValConsPublicKey.Proto> {
	key: string;
	constructor(key: string);
	static fromAmino(data: ValConsPublicKey.Amino): ValConsPublicKey;
	toAmino(): ValConsPublicKey.Amino;
	static fromData(data: ValConsPublicKey.Data): ValConsPublicKey;
	toData(): ValConsPublicKey.Data;
	static fromProto(pubkeyProto: ValConsPublicKey.Proto): ValConsPublicKey;
	toProto(): ValConsPublicKey.Proto;
	packAny(): Any$1;
	static unpackAny(pubkeyAny: Any$1): ValConsPublicKey;
	encodeAminoPubkey(): Uint8Array;
	rawAddress(): Uint8Array;
	address(prefix: string): string;
	pubkeyAddress(prefix: string): string;
}
export declare namespace ValConsPublicKey {
	interface Amino {
		type: "tendermint/PubKeyEd25519";
		value: string;
	}
	interface Data {
		"@type": "/cosmos.crypto.ed25519.PubKey";
		key: string;
	}
	type Proto = PubKey_pb;
}
/**
 * Stores information fetched from the blockchain about the current status of a validator.
 * As an end user, you will not have to create an instance of this class, one will be
 * generated for you to store information about a validator polled from the API functions
 * in [[StakingAPI]].
 */
export declare class Validator extends JSONSerializable<Validator.Amino, Validator.Data, Validator.Proto> {
	operator_address: ValAddress;
	consensus_pubkey: ValConsPublicKey;
	jailed: boolean;
	status: BondStatus;
	tokens: Int;
	delegator_shares: Dec;
	description: Validator.Description;
	unbonding_height: number;
	unbonding_time: Date;
	commission: Validator.Commission;
	min_self_delegation: Int;
	/**
	 *
	 * @param operator_address validator's operator address
	 * @param consensus_pubkey validator's consensus public key
	 * @param jailed whether the current validator is jailed
	 * @param status unbonded `0`, unbonding `1`, bonded `2`
	 * @param tokens total Luna from all delegations (including self)
	 * @param delegator_shares total shares of all delegators
	 * @param description validator's delegate description
	 * @param unbonding_height if unbonding, height at which this validator began unbonding
	 * @param unbonding_time if unbonding, min time for the validator to complete unbonding
	 * @param commission validator commission
	 * @param min_self_delegation minimum self delegation
	 */
	constructor(operator_address: ValAddress, consensus_pubkey: ValConsPublicKey, jailed: boolean, status: BondStatus, tokens: Int, delegator_shares: Dec, description: Validator.Description, unbonding_height: number, unbonding_time: Date, commission: Validator.Commission, min_self_delegation: Int);
	toAmino(): Validator.Amino;
	static fromAmino(data: Validator.Amino): Validator;
	toData(): Validator.Data;
	static fromData(data: Validator.Data): Validator;
	toProto(): Validator.Proto;
	static fromProto(data: Validator.Proto): Validator;
}
export declare namespace Validator {
	const Status: typeof BondStatus;
	type Status = BondStatus;
	interface Amino {
		operator_address: ValAddress;
		consensus_pubkey: ValConsPublicKey.Amino;
		jailed: boolean;
		status: BondStatus;
		tokens: string;
		delegator_shares: string;
		description: Description.Amino;
		unbonding_height: string;
		unbonding_time: string;
		commission: Commission.Amino;
		min_self_delegation: string;
	}
	interface Data {
		operator_address: ValAddress;
		consensus_pubkey: ValConsPublicKey.Data;
		jailed: boolean;
		status: BondStatus;
		tokens: string;
		delegator_shares: string;
		description: Description.Data;
		unbonding_height: string;
		unbonding_time: string;
		commission: Commission.Data;
		min_self_delegation: string;
	}
	type Proto = Validator_pb;
	class Description extends JSONSerializable<Description.Amino, Description.Data, Description.Proto> {
		moniker: string;
		identity: string;
		website: string;
		details: string;
		security_contact: string;
		/**
		 * @param moniker Identifying name, e.g. "Hashed"
		 * @param identity time at which commission was last updated
		 * @param website validator's website
		 * @param details long description
		 * @param security_contact validator's contact
		 */
		constructor(moniker: string, identity: string, website: string, details: string, security_contact: string);
		toAmino(): Description.Amino;
		static fromAmino(data: Description.Amino): Description;
		toData(): Description.Data;
		static fromData(data: Description.Data): Description;
		toProto(): Description.Proto;
		static fromProto(proto: Description.Proto): Description;
	}
	namespace Description {
		interface Amino {
			moniker: string;
			identity: string;
			website: string;
			details: string;
			security_contact: string;
		}
		interface Data {
			moniker: string;
			identity: string;
			website: string;
			details: string;
			security_contact: string;
		}
		type Proto = Description_pb;
	}
	class CommissionRates extends JSONSerializable<CommissionRates.Amino, CommissionRates.Data, CommissionRates.Proto> {
		rate: Dec;
		max_rate: Dec;
		max_change_rate: Dec;
		/**
		 * @param rate current commission rate
		 * @param max_rate max commission rate
		 * @param max_change_rate max percentage commission can change in 24hrs
		 */
		constructor(rate: Dec, max_rate: Dec, max_change_rate: Dec);
		static fromAmino(data: CommissionRates.Amino): CommissionRates;
		toAmino(): Validator.CommissionRates.Amino;
		static fromData(data: CommissionRates.Data): CommissionRates;
		toData(): Validator.CommissionRates.Data;
		static fromProto(proto: CommissionRates.Proto): CommissionRates;
		toProto(): Validator.CommissionRates.Proto;
	}
	namespace CommissionRates {
		interface Amino {
			rate: string;
			max_rate: string;
			max_change_rate: string;
		}
		interface Data {
			rate: string;
			max_rate: string;
			max_change_rate: string;
		}
		type Proto = CommissionRates_pb;
	}
	class Commission extends JSONSerializable<Commission.Amino, Commission.Data, Commission.Proto> {
		commission_rates: CommissionRates;
		update_time: Date;
		/**
		 * @param commission_rates commission rates
		 * @param update_time time at which commission was last updated
		 */
		constructor(commission_rates: CommissionRates, update_time: Date);
		toAmino(): Commission.Amino;
		static fromAmino(data: Commission.Amino): Commission;
		toData(): Commission.Data;
		static fromData(data: Commission.Data): Commission;
		toProto(): Commission.Proto;
		static fromProto(proto: Commission.Proto): Commission;
	}
	namespace Commission {
		interface Amino {
			commission_rates: CommissionRates.Amino;
			update_time: string;
		}
		interface Data {
			commission_rates: CommissionRates.Data;
			update_time: string;
		}
		type Proto = Commission_pb;
	}
}
/**
 * For new validators, this message registers a validator address to be a delegate on
 * the blockchain.
 */
export declare class MsgCreateValidator extends JSONSerializable<MsgCreateValidator.Amino, MsgCreateValidator.Data, MsgCreateValidator.Proto> {
	description: Validator.Description;
	commission: Validator.CommissionRates;
	min_self_delegation: Int;
	delegator_address: AccAddress;
	validator_address: ValAddress;
	pubkey: ValConsPublicKey;
	value: Coin;
	/**
	 *
	 * @param description validator's delegate information
	 * @param commission validator's commission policy
	 * @param min_self_delegation minimum self delegation
	 * @param delegator_address validator's account address
	 * @param validator_address validator's operator address
	 * @param pubkey validator's consensus public key
	 * @param value amount to use for self-delegation
	 */
	constructor(description: Validator.Description, commission: Validator.CommissionRates, min_self_delegation: Int, delegator_address: AccAddress, validator_address: ValAddress, pubkey: ValConsPublicKey, value: Coin);
	static fromAmino(data: MsgCreateValidator.Amino, _?: boolean): MsgCreateValidator;
	toAmino(isClassic?: boolean): MsgCreateValidator.Amino;
	static fromData(data: MsgCreateValidator.Data, _?: boolean): MsgCreateValidator;
	toData(_?: boolean): MsgCreateValidator.Data;
	static fromProto(proto: MsgCreateValidator.Proto, _?: boolean): MsgCreateValidator;
	toProto(_?: boolean): MsgCreateValidator.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgCreateValidator;
}
export declare namespace MsgCreateValidator {
	interface Amino {
		type: "staking/MsgCreateValidator" | "cosmos-sdk/MsgCreateValidator";
		value: {
			description: Validator.Description;
			commission: Validator.CommissionRates.Amino;
			min_self_delegation: string;
			delegator_address: AccAddress;
			validator_address: ValAddress;
			pubkey: ValConsPublicKey.Amino;
			value: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.staking.v1beta1.MsgCreateValidator";
		description: Validator.Description;
		commission: Validator.CommissionRates.Data;
		min_self_delegation: string;
		delegator_address: AccAddress;
		validator_address: ValAddress;
		pubkey: ValConsPublicKey.Data;
		value: Coin.Data;
	}
	type Proto = MsgCreateValidator_pb;
}
/**
 * A validator can edit its delegate information, such as moniker, website, commission
 * rate, etc.
 *
 * You must use special or sentinel values to inform that you want to leave the current
 * field untouched. For `Description`,` you should start with [[MsgEditValidator.DESC_DO_NOT_MODIFY]] and
 * change each field you wish to modify individually.
 */
export declare class MsgEditValidator extends JSONSerializable<MsgEditValidator.Amino, MsgEditValidator.Data, MsgEditValidator.Proto> {
	description: Validator.Description;
	validator_address: ValAddress;
	commission_rate?: Dec | undefined;
	min_self_delegation?: Int | undefined;
	/**
	 * @param Description new description to apply
	 * @param address new address to apply
	 * @param commission_rate new commission rates to apply
	 * @param min_self_delegation new min self delegation
	 */
	constructor(description: Validator.Description, validator_address: ValAddress, commission_rate?: Dec | undefined, min_self_delegation?: Int | undefined);
	static fromAmino(data: MsgEditValidator.Amino, _?: boolean): MsgEditValidator;
	toAmino(isClassic?: boolean): MsgEditValidator.Amino;
	static fromProto(data: MsgEditValidator.Proto, _?: boolean): MsgEditValidator;
	toProto(_?: boolean): MsgEditValidator.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgEditValidator;
	static fromData(data: MsgEditValidator.Data, _?: boolean): MsgEditValidator;
	toData(_?: boolean): MsgEditValidator.Data;
}
export declare namespace MsgEditValidator {
	const DESC_DO_NOT_MODIFY: Validator.Description.Amino;
	interface Amino {
		type: "staking/MsgEditValidator" | "cosmos-sdk/MsgEditValidator";
		value: {
			description: Validator.Description.Amino;
			validator_address: ValAddress;
			commission_rate?: string;
			min_self_delegation?: string;
		};
	}
	interface Data {
		"@type": "/cosmos.staking.v1beta1.MsgEditValidator";
		description: Validator.Description.Data;
		validator_address: ValAddress;
		commission_rate?: string;
		min_self_delegation?: string;
	}
	type Proto = MsgEditValidator_pb;
}
/**
 * When a user wants to cancel the unbonding this messaage can be used
 */
export declare class MsgCancelUnbondingDelegation extends JSONSerializable<MsgCancelUnbondingDelegation.Amino, MsgCancelUnbondingDelegation.Data, MsgCancelUnbondingDelegation.Proto> {
	delegator_address: string;
	validator_address: string;
	creation_height: Long$1;
	amount?: Coin | undefined;
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_src_address source validator to cancel the undelegation from
	 * @param validator_dst_address destination validator to cancel the undelegation from
	 * @param amount amount of luna to cancel the undelegation from
	 */
	constructor(delegator_address: string, validator_address: string, creation_height: Long$1, amount?: Coin | undefined);
	static fromAmino(data: MsgCancelUnbondingDelegation.Amino, _?: boolean): MsgCancelUnbondingDelegation;
	toAmino(isClassic?: boolean): MsgCancelUnbondingDelegation.Amino;
	static fromData(data: MsgCancelUnbondingDelegation.Data, _?: boolean): MsgCancelUnbondingDelegation;
	toData(_?: boolean): MsgCancelUnbondingDelegation.Data;
	static fromProto(proto: MsgCancelUnbondingDelegation.Proto, _?: boolean): MsgCancelUnbondingDelegation;
	toProto(_?: boolean): MsgCancelUnbondingDelegation.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgCancelUnbondingDelegation;
}
export declare namespace MsgCancelUnbondingDelegation {
	interface Amino {
		type: "staking/MsgCancelUnbondingDelegation" | "cosmos-sdk/MsgCancelUnbondingDelegation";
		value: {
			delegator_address: string;
			validator_address: string;
			creation_height: Long$1;
			amount?: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
		delegator_address: string;
		validator_address: string;
		creation_height: Long$1;
		amount?: Coin.Data;
	}
	type Proto = MsgCancelUnbondingDelegation_pb;
}
export type StakingMsg = MsgDelegate | MsgUndelegate | MsgBeginRedelegate | MsgCreateValidator | MsgEditValidator | MsgCancelUnbondingDelegation;
export declare namespace StakingMsg {
	type Amino = MsgDelegate.Amino | MsgUndelegate.Amino | MsgBeginRedelegate.Amino | MsgCreateValidator.Amino | MsgEditValidator.Amino | MsgCancelUnbondingDelegation.Amino;
	type Data = MsgDelegate.Data | MsgUndelegate.Data | MsgBeginRedelegate.Data | MsgCreateValidator.Data | MsgEditValidator.Data | MsgCancelUnbondingDelegation.Data;
	type Proto = MsgDelegate.Proto | MsgUndelegate.Proto | MsgBeginRedelegate.Proto | MsgCreateValidator.Proto | MsgEditValidator.Proto | MsgCancelUnbondingDelegation.Proto;
}
/**
 * Period defines a length of time and amount of coins that will vest.
 */
export declare class Period extends JSONSerializable<Period.Amino, Period.Data, Period.Proto> {
	length: number;
	amount: Coins;
	/**
	 * @param length
	 * @param amount
	 */
	constructor(length: number, amount: Coins.Input);
	static fromAmino(data: Period.Amino, _?: boolean): Period;
	toAmino(_?: boolean): Period.Amino;
	static fromData(data: Period.Data, _?: boolean): Period;
	toData(_?: boolean): Period.Data;
	static fromProto(proto: Period.Proto, _?: boolean): Period;
	toProto(_?: boolean): Period.Proto;
}
export declare namespace Period {
	interface Amino {
		length: string;
		amount: Coins.Amino;
	}
	interface Data {
		length: string;
		amount: Coins.Data;
	}
	type Proto = Period_pb;
}
/**
 * CreatePeriodicVestingAccount defines a method that enables creating a periodic vesting account.
 */
export declare class MsgCreatePeriodicVestingAccount extends JSONSerializable<MsgCreatePeriodicVestingAccount.Amino, MsgCreatePeriodicVestingAccount.Data, MsgCreatePeriodicVestingAccount.Proto> {
	from_address: AccAddress;
	to_address: AccAddress;
	start_time: number;
	vesting_periods: Period[];
	/**
	 * @param from_address sender's address
	 * @param to_address recipient's address
	 */
	constructor(from_address: AccAddress, to_address: AccAddress, start_time: number, vesting_periods: Period[]);
	static fromAmino(data: MsgCreatePeriodicVestingAccount.Amino, isClassic?: boolean): MsgCreatePeriodicVestingAccount;
	toAmino(isClassic?: boolean): MsgCreatePeriodicVestingAccount.Amino;
	static fromData(data: MsgCreatePeriodicVestingAccount.Data, isClassic?: boolean): MsgCreatePeriodicVestingAccount;
	toData(isClassic?: boolean): MsgCreatePeriodicVestingAccount.Data;
	static fromProto(proto: MsgCreatePeriodicVestingAccount.Proto, isClassic?: boolean): MsgCreatePeriodicVestingAccount;
	toProto(isClassic?: boolean): MsgCreatePeriodicVestingAccount.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgCreatePeriodicVestingAccount;
}
export declare namespace MsgCreatePeriodicVestingAccount {
	interface Amino {
		type: "cosmos-sdk/MsgCreatePeriodicVestingAccount";
		value: {
			from_address: AccAddress;
			to_address: AccAddress;
			start_time: string;
			vesting_periods: Period.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount";
		from_address: AccAddress;
		to_address: AccAddress;
		start_time: string;
		vesting_periods: Period.Data[];
	}
	type Proto = MsgCreatePeriodicVestingAccount_pb;
}
/**
 * MsgCreateVestingAccount defines a message that enables creating a vesting account.
 */
export declare class MsgCreateVestingAccount extends JSONSerializable<MsgCreateVestingAccount.Amino, MsgCreateVestingAccount.Data, MsgCreateVestingAccount.Proto> {
	from_address: AccAddress;
	to_address: AccAddress;
	end_time: number;
	delayed: boolean;
	amount: Coins;
	/**
	 * @param from_address sender's address
	 * @param to_address recipient's address
	 * @param amount value of the transaction
	 */
	constructor(from_address: AccAddress, to_address: AccAddress, amount: Coins.Input, end_time: number, delayed: boolean);
	static fromAmino(data: MsgCreateVestingAccount.Amino, isClassic?: boolean): MsgCreateVestingAccount;
	toAmino(isClassic?: boolean): MsgCreateVestingAccount.Amino;
	static fromData(data: MsgCreateVestingAccount.Data, isClassic?: boolean): MsgCreateVestingAccount;
	toData(isClassic?: boolean): MsgCreateVestingAccount.Data;
	static fromProto(proto: MsgCreateVestingAccount.Proto, isClassic?: boolean): MsgCreateVestingAccount;
	toProto(isClassic?: boolean): MsgCreateVestingAccount.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgCreateVestingAccount;
}
export declare namespace MsgCreateVestingAccount {
	interface Amino {
		type: "cosmos-sdk/MsgCreateVestingAccount";
		value: {
			from_address: AccAddress;
			to_address: AccAddress;
			amount: Coins.Amino;
			end_time: string;
			delayed: boolean;
		};
	}
	interface Data {
		"@type": "/cosmos.vesting.v1beta1.MsgCreateVestingAccount";
		from_address: AccAddress;
		to_address: AccAddress;
		amount: Coins.Data;
		end_time: string;
		delayed: boolean;
	}
	type Proto = MsgCreateVestingAccount_pb;
}
/**
 * DonateAllVestingTokens defines a method that enables donating all vesting
 */
export declare class MsgDonateAllVestingTokens extends JSONSerializable<MsgDonateAllVestingTokens.Amino, MsgDonateAllVestingTokens.Data, MsgDonateAllVestingTokens.Proto> {
	from_address: AccAddress;
	/**
	 * @param from_address donor's address
	 */
	constructor(from_address: AccAddress);
	static fromAmino(data: MsgDonateAllVestingTokens.Amino, isClassic?: boolean): MsgDonateAllVestingTokens;
	toAmino(isClassic?: boolean): MsgDonateAllVestingTokens.Amino;
	static fromData(data: MsgDonateAllVestingTokens.Data, isClassic?: boolean): MsgDonateAllVestingTokens;
	toData(isClassic?: boolean): MsgDonateAllVestingTokens.Data;
	static fromProto(proto: MsgDonateAllVestingTokens.Proto, isClassic?: boolean): MsgDonateAllVestingTokens;
	toProto(isClassic?: boolean): MsgDonateAllVestingTokens.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgDonateAllVestingTokens;
}
export declare namespace MsgDonateAllVestingTokens {
	interface Amino {
		type: "cosmos-sdk/MsgDonateAllVestingTokens";
		value: {
			from_address: AccAddress;
		};
	}
	interface Data {
		"@type": "/cosmos.vesting.v1beta1.MsgDonateAllVestingTokens";
		from_address: AccAddress;
	}
	type Proto = MsgDonateAllVestingTokens_pb;
}
export type VestingMsg = MsgCreatePeriodicVestingAccount | MsgCreateVestingAccount | MsgDonateAllVestingTokens;
export declare namespace VestingMsg {
	type Amino = MsgCreatePeriodicVestingAccount.Amino | MsgCreateVestingAccount.Amino | MsgDonateAllVestingTokens.Amino;
	type Data = MsgCreatePeriodicVestingAccount.Data | MsgCreateVestingAccount.Data | MsgDonateAllVestingTokens.Data;
	type Proto = MsgCreatePeriodicVestingAccount.Proto | MsgCreateVestingAccount.Proto | MsgDonateAllVestingTokens.Proto;
}
/**
 * A delegator can withdraw currently outstanding rewards accrued
 * from their delegation toward a validator by submitting the following message
 * to te x/alliance module.
 *
 * The rewards will be deposited to their Withdraw Address.
 */
export declare class MsgClaimDelegationRewards extends JSONSerializable<MsgClaimDelegationRewards.Amino, MsgClaimDelegationRewards.Data, MsgClaimDelegationRewards.Proto> {
	delegator_address: AccAddress;
	validator_address: ValAddress;
	denom: string;
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_address validator's operator address
	 * @param denom alliance denom to claim rewards for (e.g. ibc/AAE7E4 or uluna...)
	 */
	constructor(delegator_address: AccAddress, validator_address: ValAddress, denom: string);
	static fromAmino(data: MsgClaimDelegationRewards.Amino, _?: boolean): MsgClaimDelegationRewards;
	toAmino(_?: boolean): MsgClaimDelegationRewards.Amino;
	static fromData(proto: MsgClaimDelegationRewards.Data, _?: boolean): MsgClaimDelegationRewards;
	toData(_?: boolean): MsgClaimDelegationRewards.Data;
	static fromProto(proto: MsgClaimDelegationRewards.Proto, _?: boolean): MsgClaimDelegationRewards;
	toProto(_?: boolean): MsgClaimDelegationRewards.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgClaimDelegationRewards;
}
export declare namespace MsgClaimDelegationRewards {
	interface Amino {
		type: "alliance/MsgClaimDelegationRewards";
		value: {
			delegator_address: AccAddress;
			validator_address: ValAddress;
			denom: string;
		};
	}
	interface Data {
		"@type": "/alliance.alliance.MsgClaimDelegationRewards";
		delegator_address: AccAddress;
		validator_address: ValAddress;
		denom: string;
	}
	type Proto = MsgClaimDelegationRewards_pb;
}
/**
 * A delegator can submit this message to send more alliance assets
 * to be staked through the alliance module in a validator.
 */
declare class MsgDelegate$1 extends JSONSerializable<MsgDelegate$1.Amino, MsgDelegate$1.Data, MsgDelegate$1.Proto> {
	delegator_address: AccAddress;
	validator_address: ValAddress;
	amount: Coin;
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_address validator's operator address
	 * @param amount amount of alliance assets to be sent for delegation
	 */
	constructor(delegator_address: AccAddress, validator_address: ValAddress, amount: Coin);
	static fromAmino(data: MsgDelegate$1.Amino, _?: boolean): MsgDelegate$1;
	toAmino(_?: boolean): MsgDelegate$1.Amino;
	static fromProto(proto: MsgDelegate$1.Proto, _?: boolean): MsgDelegate$1;
	toProto(_?: boolean): MsgDelegate$1.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgDelegate$1;
	static fromData(data: MsgDelegate$1.Data, _?: boolean): MsgDelegate$1;
	toData(_?: boolean): MsgDelegate$1.Data;
}
declare namespace MsgDelegate$1 {
	interface Amino {
		type: "alliance/MsgDelegate";
		value: {
			delegator_address: AccAddress;
			validator_address: ValAddress;
			amount: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/alliance.alliance.MsgDelegate";
		delegator_address: AccAddress;
		validator_address: ValAddress;
		amount: Coin.Data;
	}
	type Proto = MsgDelegate_pb$1;
}
/**
 * A delegator can choose to redelegate their bonded alliance assets
 * and transfer a delegation from one validator to another. Unlike
 * undelegating, redelegations do not incur a 21-day unbonding period
 * and happen immediately.
 */
declare class MsgRedelegate extends JSONSerializable<MsgRedelegate.Amino, MsgRedelegate.Data, MsgRedelegate.Proto> {
	delegator_address: AccAddress;
	validator_src_address: ValAddress;
	validator_dst_address: ValAddress;
	amount: Coin;
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_src_address validator to undelegate from
	 * @param validator_dst_address validator to delegate to
	 * @param amount amount of alliance assets to be redelegated
	 */
	constructor(delegator_address: AccAddress, validator_src_address: ValAddress, validator_dst_address: ValAddress, amount: Coin);
	static fromAmino(data: MsgRedelegate.Amino, _?: boolean): MsgRedelegate;
	toAmino(_?: boolean): MsgRedelegate.Amino;
	static fromData(data: MsgRedelegate.Data, _?: boolean): MsgRedelegate;
	toData(_?: boolean): MsgRedelegate.Data;
	static fromProto(proto: MsgRedelegate.Proto, _?: boolean): MsgRedelegate;
	toProto(_?: boolean): MsgRedelegate.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgRedelegate;
}
declare namespace MsgRedelegate {
	interface Amino {
		type: "alliance/MsgRedelegate";
		value: {
			delegator_address: AccAddress;
			validator_src_address: ValAddress;
			validator_dst_address: ValAddress;
			amount: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/alliance.alliance.MsgRedelegate";
		delegator_address: AccAddress;
		validator_src_address: ValAddress;
		validator_dst_address: ValAddress;
		amount: Coin.Data;
	}
	type Proto = MsgRedelegate_pb;
}
/**
 * A delegator can undelegate an amount of bonded alliance tokens
 * form the x/alliance module, and will begin the unbonding process
 * for those funds. The unbonding process takes 21 days to complete,
 * during which the Luna cannot be transacted or swapped.
 */
declare class MsgUndelegate$1 extends JSONSerializable<MsgUndelegate$1.Amino, MsgUndelegate$1.Data, MsgUndelegate$1.Proto> {
	delegator_address: AccAddress;
	validator_address: ValAddress;
	amount: Coin;
	/**
	 * @param delegator_address delegator's account address
	 * @param validator_address validator's operator address
	 * @param amount alliance assets to be undelegated
	 */
	constructor(delegator_address: AccAddress, validator_address: ValAddress, amount: Coin);
	static fromAmino(data: MsgUndelegate$1.Amino, _?: boolean): MsgUndelegate$1;
	toAmino(_?: boolean): MsgUndelegate$1.Amino;
	static fromProto(proto: MsgUndelegate$1.Proto, _?: boolean): MsgUndelegate$1;
	toProto(_?: boolean): MsgUndelegate$1.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgUndelegate$1;
	static fromData(data: MsgUndelegate$1.Data, _?: boolean): MsgUndelegate$1;
	toData(_?: boolean): MsgUndelegate$1.Data;
}
declare namespace MsgUndelegate$1 {
	interface Amino {
		type: "alliance/MsgUndelegate";
		value: {
			delegator_address: AccAddress;
			validator_address: ValAddress;
			amount: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/alliance.alliance.MsgUndelegate";
		delegator_address: AccAddress;
		validator_address: ValAddress;
		amount: Coin.Data;
	}
	type Proto = MsgUndelegate_pb$1;
}
export type AllianceMsg = MsgClaimDelegationRewards | MsgDelegate$1 | MsgRedelegate | MsgUndelegate$1 | MsgCreateAlliance | MsgDeleteAlliance | MsgUpdateAlliance;
declare namespace AllianceMsg {
	type Data = MsgClaimDelegationRewards.Data | MsgDelegate$1.Data | MsgRedelegate.Data | MsgUndelegate$1.Data | MsgCreateAlliance.Data | MsgDeleteAlliance.Data | MsgUpdateAlliance.Data;
	type Proto = MsgClaimDelegationRewards.Proto | MsgDelegate$1.Proto | MsgRedelegate.Proto | MsgUndelegate$1.Proto | MsgCreateAlliance.Proto | MsgDeleteAlliance.Proto | MsgUpdateAlliance.Proto;
	type Amino = MsgClaimDelegationRewards.Amino | MsgDelegate$1.Amino | MsgRedelegate.Amino | MsgUndelegate$1.Amino | MsgCreateAlliance.Amino | MsgDeleteAlliance.Amino | MsgUpdateAlliance.Amino;
}
/**
 * A delegator can submit this message to send more alliance assets
 * to be staked through the alliance module in a validator.
 */
export declare class MsgAminoCustom extends JSONSerializable<MsgAminoCustom.Amino, MsgAminoCustom.Data, {}> {
	aminoMsg: MsgAminoCustom.Amino;
	/**
	 *
	 * @param delegatorAddress delegator's account address
	 * @param validatorAddress validator's operator address
	 * @param amount amount of alliance assets to be sent for delegation
	 */
	constructor(aminoMsg: MsgAminoCustom.Amino);
	toAmino(_?: boolean): MsgAminoCustom.Amino;
	static fromAmino(data: MsgAminoCustom.Amino, _?: boolean): MsgAminoCustom;
	toProto(_?: boolean): {};
	packAny(_?: boolean): {};
	static unpackAny(msgAny: {}, _?: boolean): {};
	static fromData(data: MsgAminoCustom.Data, _?: boolean): MsgAminoCustom;
	toData(_?: boolean): MsgAminoCustom.Data;
}
export declare namespace MsgAminoCustom {
	interface Data {
		"@type": "MsgCustomAmino";
		msg: MsgAminoCustom.Amino;
	}
	interface Amino {
		type: string;
		value: Object;
	}
}
export type CustomMsg = MsgAminoCustom;
export declare namespace CustomMsg {
	type Amino = MsgAminoCustom.Amino;
	type Data = MsgAminoCustom.Data;
}
export declare class MsgStoreCode extends JSONSerializable<MsgStoreCode.Amino, MsgStoreCode.Data, MsgStoreCode.Proto> {
	sender: AccAddress;
	wasm_byte_code: string;
	instantiate_permission?: AccessConfig | undefined;
	/**
	 * @param sender code creator
	 * @param wasm_byte_code base64-encoded bytecode contents
	 * @param instantiate_permission  InstantiatePermission access control to apply on contract creation, optional. v2 supported only
	 */
	constructor(sender: AccAddress, wasm_byte_code: string, instantiate_permission?: AccessConfig | undefined);
	static fromAmino(data: MsgStoreCode.AminoV2 | MsgStoreCode.AminoV1, _?: boolean): MsgStoreCode;
	toAmino(_?: boolean): MsgStoreCode.AminoV2;
	static fromProto(proto: MsgStoreCode.Proto, _?: boolean): MsgStoreCode;
	toProto(_?: boolean): MsgStoreCode.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgStoreCode;
	static fromData(data: MsgStoreCode.DataV2 | MsgStoreCode.DataV1, _?: boolean): MsgStoreCode;
	toData(_?: boolean): MsgStoreCode.Data;
}
export declare namespace MsgStoreCode {
	interface AminoV1 {
		type: "wasm/MsgStoreCode";
		value: {
			sender: AccAddress;
			wasm_byte_code: string;
		};
	}
	interface AminoV2 {
		type: "wasm/MsgStoreCode";
		value: {
			sender: AccAddress;
			wasm_byte_code: string;
			instantiate_permission?: AccessConfig.Amino;
		};
	}
	type Amino = AminoV1 | AminoV2;
	interface DataV1 {
		"@type": "/terra.wasm.v1beta1.MsgStoreCode";
		sender: AccAddress;
		wasm_byte_code: string;
	}
	interface DataV2 {
		"@type": "/cosmwasm.wasm.v1.MsgStoreCode";
		sender: AccAddress;
		wasm_byte_code: string;
		instantiate_permission?: AccessConfig.Data;
	}
	type Data = DataV1 | DataV2;
	type Proto = MsgStoreCode_legacy_pb | MsgStoreCode_pb;
}
export declare class MsgMigrateCode extends JSONSerializable<MsgMigrateCode.Amino, MsgMigrateCode.Data, MsgMigrateCode.Proto> {
	sender: AccAddress;
	code_id: number;
	wasm_byte_code: string;
	/**
	 * @param sender code migrator address
	 * @param code_id reference to the code on the blockchain
	 * @param wasm_byte_code base64-encoded bytecode contents
	 */
	constructor(sender: AccAddress, code_id: number, wasm_byte_code: string);
	static fromAmino(_data: MsgMigrateCode.Amino, _?: boolean): MsgMigrateCode;
	toAmino(_?: boolean): MsgMigrateCode.Amino;
	static fromProto(_proto: MsgMigrateCode.Proto, _?: boolean): MsgMigrateCode;
	toProto(_?: boolean): MsgMigrateCode.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(_msgAny: Any$1, _?: boolean): MsgMigrateCode;
	static fromData(_data: MsgMigrateCode.Data, _?: boolean): MsgMigrateCode;
	toData(_?: boolean): MsgMigrateCode.Data;
}
export declare namespace MsgMigrateCode {
	interface Amino {
		type: "wasm/MsgMigrateCode";
		value: {
			code_id: string;
			sender: AccAddress;
			wasm_byte_code: string;
		};
	}
	interface Data {
		"@type": "/terra.wasm.v1beta1.MsgMigrateCode";
		code_id: string;
		sender: AccAddress;
		wasm_byte_code: string;
	}
	type Proto = MsgMigrateCode_legacy_pb;
}
export declare class MsgInstantiateContract extends JSONSerializable<MsgInstantiateContract.Amino, MsgInstantiateContract.Data, MsgInstantiateContract.Proto> {
	sender: AccAddress;
	admin: AccAddress | undefined;
	code_id: number;
	init_msg: object | string;
	label?: string | undefined;
	init_coins: Coins;
	/**
	 * @param sender is a sender address
	 * @param admin is an optional contract admin address who can migrate the contract, put empty string to disable migration
	 * @param code_id is the reference to the stored WASM code
	 * @param init_msg json encoded message to be passed to the contract on instantiation
	 * @param init_coins are transferred to the contract on execution
	 * @param label label for the contract. v2 supported only
	 */
	constructor(sender: AccAddress, admin: AccAddress | undefined, code_id: number, init_msg: object | string, init_coins?: Coins.Input, label?: string | undefined);
	static fromAmino(data: MsgInstantiateContract.Amino, _?: boolean): MsgInstantiateContract;
	toAmino(_?: boolean): MsgInstantiateContract.Amino;
	static fromProto(proto: MsgInstantiateContract.Proto, _?: boolean): MsgInstantiateContract;
	toProto(_?: boolean): MsgInstantiateContract.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgInstantiateContract;
	static fromData(data: MsgInstantiateContract.Data, _?: boolean): MsgInstantiateContract;
	toData(_?: boolean): MsgInstantiateContract.Data;
}
export declare namespace MsgInstantiateContract {
	interface AminoV1 {
		type: "wasm/MsgInstantiateContract";
		value: {
			sender: AccAddress;
			admin?: AccAddress;
			code_id: string;
			init_msg: object | string;
			init_coins: Coins.Amino;
		};
	}
	interface AminoV2 {
		type: "wasm/MsgInstantiateContract";
		value: {
			sender: AccAddress;
			admin?: AccAddress;
			code_id: string;
			label?: string;
			msg: object | string;
			funds: Coins.Amino;
		};
	}
	interface DataV1 {
		"@type": "/terra.wasm.v1beta1.MsgInstantiateContract";
		sender: AccAddress;
		admin: AccAddress;
		code_id: string;
		init_msg: object | string;
		init_coins: Coins.Data;
	}
	interface DataV2 {
		"@type": "/cosmwasm.wasm.v1.MsgInstantiateContract";
		sender: AccAddress;
		admin: AccAddress;
		code_id: string;
		label?: string;
		msg: object | string;
		funds: Coins.Data;
	}
	type Amino = AminoV1 | AminoV2;
	type Data = DataV1 | DataV2;
	type Proto = MsgInstantiateContract_legacy_pb | MsgInstantiateContract_pb;
}
export declare class MsgExecuteContract extends JSONSerializable<MsgExecuteContract.Amino, MsgExecuteContract.Data, MsgExecuteContract.Proto> {
	sender: AccAddress;
	contract: AccAddress;
	execute_msg: object | string;
	coins: Coins;
	/**
	 * @param sender contract user
	 * @param contract contract address
	 * @param execute_msg HandleMsg to pass as arguments for contract invocation
	 * @param coins coins to be sent to contract
	 */
	constructor(sender: AccAddress, contract: AccAddress, execute_msg: object | string, coins?: Coins.Input);
	static fromAmino(data: MsgExecuteContract.Amino, _?: boolean): MsgExecuteContract;
	toAmino(_?: boolean): MsgExecuteContract.Amino;
	static fromProto(proto: MsgExecuteContract.Proto, _?: boolean): MsgExecuteContract;
	toProto(_?: boolean): MsgExecuteContract.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgExecuteContract;
	static fromData(data: MsgExecuteContract.Data, _?: boolean): MsgExecuteContract;
	toData(_?: boolean): MsgExecuteContract.Data;
}
export declare namespace MsgExecuteContract {
	interface AminoV1 {
		type: "wasm/MsgExecuteContract";
		value: {
			sender: AccAddress;
			contract: AccAddress;
			execute_msg: object | string;
			coins: Coins.Amino;
		};
	}
	interface AminoV2 {
		type: "wasm/MsgExecuteContract";
		value: {
			sender: AccAddress;
			contract: AccAddress;
			msg: object | string;
			funds: Coins.Amino;
		};
	}
	interface DataV1 {
		"@type": "/terra.wasm.v1beta1.MsgExecuteContract";
		sender: AccAddress;
		contract: AccAddress;
		execute_msg: object | string;
		coins: Coins.Data;
	}
	interface DataV2 {
		"@type": "/cosmwasm.wasm.v1.MsgExecuteContract";
		sender: AccAddress;
		contract: AccAddress;
		msg: object | string;
		funds: Coins.Data;
	}
	type Amino = AminoV1 | AminoV2;
	type Data = DataV1 | DataV2;
	type Proto = MsgExecuteContract_legacy_pb | MsgExecuteContract_pb;
}
export declare class MsgMigrateContract extends JSONSerializable<MsgMigrateContract.Amino, MsgMigrateContract.Data, MsgMigrateContract.Proto> {
	admin: AccAddress;
	contract: AccAddress;
	new_code_id: number;
	migrate_msg: object | string;
	/**
	 * @param admin contract admin
	 * @param contract contract address to be migrated from
	 * @param new_code_id reference to the new code on the blockchain
	 * @param migrate_msg JSON message to configure the migrate state of the contract
	 */
	constructor(admin: AccAddress, contract: AccAddress, new_code_id: number, migrate_msg: object | string);
	static fromAmino(data: MsgMigrateContract.Amino, _?: boolean): MsgMigrateContract;
	toAmino(_?: boolean): MsgMigrateContract.Amino;
	static fromProto(proto: MsgMigrateContract.Proto, _?: boolean): MsgMigrateContract;
	toProto(_?: boolean): MsgMigrateContract.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgMigrateContract;
	static fromData(data: MsgMigrateContract.Data, _?: boolean): MsgMigrateContract;
	toData(_?: boolean): MsgMigrateContract.Data;
}
export declare namespace MsgMigrateContract {
	interface AminoV1 {
		type: "wasm/MsgMigrateContract";
		value: {
			admin: AccAddress;
			contract: AccAddress;
			new_code_id: string;
			migrate_msg: object | string;
		};
	}
	interface AminoV2 {
		type: "wasm/MsgMigrateContract";
		value: {
			sender: AccAddress;
			contract: AccAddress;
			code_id: string;
			msg: object | string;
		};
	}
	interface DataV1 {
		"@type": "/terra.wasm.v1beta1.MsgMigrateContract";
		admin: AccAddress;
		contract: AccAddress;
		new_code_id: string;
		migrate_msg: object | string;
	}
	interface DataV2 {
		"@type": "/cosmwasm.wasm.v1.MsgMigrateContract";
		sender: AccAddress;
		contract: AccAddress;
		code_id: string;
		msg: object | string;
	}
	type Amino = AminoV1 | AminoV2;
	type Data = DataV1 | DataV2;
	type Proto = MsgMigrateContract_legacy_pb | MsgMigrateContract_pb;
}
export declare class MsgUpdateContractAdmin extends JSONSerializable<MsgUpdateContractAdmin.Amino, MsgUpdateContractAdmin.Data, MsgUpdateContractAdmin.Proto> {
	admin: AccAddress;
	new_admin: AccAddress;
	contract: AccAddress;
	/**
	 * @param admin contract admin
	 * @param new_admin new admin
	 * @param contract contract address
	 */
	constructor(admin: AccAddress, new_admin: AccAddress, contract: AccAddress);
	static fromAmino(data: MsgUpdateContractAdmin.Amino, isClassic?: boolean): MsgUpdateContractAdmin;
	toAmino(isClassic?: boolean): MsgUpdateContractAdmin.Amino;
	static fromProto(proto: MsgUpdateContractAdmin.Proto, isClassic?: boolean): MsgUpdateContractAdmin;
	toProto(isClassic?: boolean): MsgUpdateContractAdmin.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgUpdateContractAdmin;
	static fromData(data: MsgUpdateContractAdmin.Data, isClassic?: boolean): MsgUpdateContractAdmin;
	toData(isClassic?: boolean): MsgUpdateContractAdmin.Data;
}
export declare namespace MsgUpdateContractAdmin {
	interface AminoV1 {
		type: "wasm/MsgUpdateContractAdmin";
		value: {
			admin: AccAddress;
			new_admin: AccAddress;
			contract: AccAddress;
		};
	}
	interface AminoV2 {
		type: "wasm/MsgUpdateAdmin";
		value: {
			sender: AccAddress;
			new_admin: AccAddress;
			contract: AccAddress;
		};
	}
	interface DataV1 {
		"@type": "/terra.wasm.v1beta1.MsgUpdateContractAdmin";
		admin: AccAddress;
		new_admin: AccAddress;
		contract: AccAddress;
	}
	interface DataV2 {
		"@type": "/cosmwasm.wasm.v1.MsgUpdateAdmin";
		sender: AccAddress;
		new_admin: AccAddress;
		contract: AccAddress;
	}
	type Amino = AminoV1 | AminoV2;
	type Data = DataV1 | DataV2;
	type Proto = MsgUpdateContractAdmin_legacy_pb | MsgUpdateAdmin_pb;
}
export declare class MsgClearContractAdmin extends JSONSerializable<MsgClearContractAdmin.Amino, MsgClearContractAdmin.Data, MsgClearContractAdmin.Proto> {
	admin: AccAddress;
	contract: AccAddress;
	/**
	 * @param admin contract admin
	 * @param contract contract address
	 */
	constructor(admin: AccAddress, contract: AccAddress);
	static fromAmino(data: MsgClearContractAdmin.Amino, _?: boolean): MsgClearContractAdmin;
	toAmino(_?: boolean): MsgClearContractAdmin.Amino;
	static fromProto(data: MsgClearContractAdmin.Proto, _?: boolean): MsgClearContractAdmin;
	toProto(_?: boolean): MsgClearContractAdmin.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgClearContractAdmin;
	static fromData(data: MsgClearContractAdmin.Data, _?: boolean): MsgClearContractAdmin;
	toData(_?: boolean): MsgClearContractAdmin.Data;
}
export declare namespace MsgClearContractAdmin {
	interface AminoV1 {
		type: "wasm/MsgClearContractAdmin";
		value: {
			admin: AccAddress;
			contract: AccAddress;
		};
	}
	interface AminoV2 {
		type: "wasm/MsgClearAdmin";
		value: {
			sender: AccAddress;
			contract: AccAddress;
		};
	}
	interface DataV1 {
		"@type": "/terra.wasm.v1beta1.MsgClearContractAdmin";
		admin: string;
		contract: string;
	}
	interface DataV2 {
		"@type": "/cosmwasm.wasm.v1.MsgClearAdmin";
		sender: string;
		contract: string;
	}
	type Amino = AminoV1 | AminoV2;
	type Data = DataV1 | DataV2;
	type Proto = MsgClearContractAdmin_legacy_pb | MsgClearAdmin_pb;
}
export type WasmMsg = MsgStoreCode | MsgMigrateCode | MsgInstantiateContract | MsgExecuteContract | MsgMigrateContract | MsgUpdateContractAdmin | MsgClearContractAdmin;
export declare namespace WasmMsg {
	type Amino = MsgStoreCode.Amino | MsgMigrateCode.Amino | MsgInstantiateContract.Amino | MsgExecuteContract.Amino | MsgMigrateContract.Amino | MsgUpdateContractAdmin.Amino | MsgClearContractAdmin.Amino;
	type Data = MsgStoreCode.Data | MsgMigrateCode.Data | MsgInstantiateContract.Data | MsgExecuteContract.Data | MsgMigrateContract.Data | MsgUpdateContractAdmin.Data | MsgClearContractAdmin.Data;
	type Proto = MsgStoreCode.Proto | MsgMigrateCode.Proto | MsgInstantiateContract.Proto | MsgExecuteContract.Proto | MsgMigrateContract.Proto | MsgUpdateContractAdmin.Proto | MsgClearContractAdmin.Proto;
}
/**
 * MsgCreateDenom defines the message structure for the CreateDenom gRPC service
 * method. It allows an account to create a new denom. It requires a sender
 * address and a sub denomination. The (sender_address, sub_denomination) tuple
 * must be unique and cannot be re-used.
 *
 * The resulting denom created is defined as
 * <factory/{creatorAddress}/{subdenom}>. The resulting denom's admin is
 * originally set to be the creator, but this can be changed later. The token
 * denom does not indicate the current admin.
 */
export declare class MsgCreateDenom extends JSONSerializable<MsgCreateDenom.Amino, MsgCreateDenom.Data, MsgCreateDenom.Proto> {
	sender: AccAddress;
	subdenom: string;
	/**
	 *
	 * @param sender internal account or external sender address
	 * @param subdenom can be up to 44 "alphanumeric" characters long.
	 */
	constructor(sender: AccAddress, subdenom: string);
	toAmino(_?: boolean): MsgCreateDenom.Amino;
	static fromProto(proto: MsgCreateDenom.Proto, _?: boolean): MsgCreateDenom;
	toProto(_?: boolean): MsgCreateDenom.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgCreateDenom;
	static fromData(data: MsgCreateDenom.Data, _?: boolean): MsgCreateDenom;
	toData(_?: boolean): MsgCreateDenom.Data;
	static fromAmino(data: MsgCreateDenom.Amino): MsgCreateDenom;
}
export declare namespace MsgCreateDenom {
	interface Amino {
		type: "osmosis/tokenfactory/create-denom";
		value: {
			sender: AccAddress;
			subdenom: string;
		};
	}
	interface Data {
		"@type": "/osmosis.tokenfactory.v1beta1.MsgCreateDenom";
		sender: AccAddress;
		subdenom: string;
	}
	type Proto = MsgCreateDenom_pb;
}
/**
 * MsgBurn is the sdk.Msg type for allowing an admin account to burn
 * a token.  For now, we only support burning from the sender account.
 */
export declare class MsgBurn extends JSONSerializable<MsgBurn.Amino, MsgBurn.Data, MsgBurn.Proto> {
	sender: AccAddress;
	amount?: Coin | undefined;
	/**
	 *
	 * @param sender internal account or external sender address
	 * @param amount amount of coins to burn
	 */
	constructor(sender: AccAddress, amount?: Coin | undefined);
	toAmino(_?: boolean): MsgBurn.Amino;
	static fromProto(proto: MsgBurn.Proto, _?: boolean): MsgBurn;
	toProto(_?: boolean): MsgBurn.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgBurn;
	static fromData(data: MsgBurn.Data, _?: boolean): MsgBurn;
	toData(_?: boolean): MsgBurn.Data;
	static fromAmino(data: MsgBurn.Amino): MsgBurn;
}
export declare namespace MsgBurn {
	interface Amino {
		type: "osmosis/tokenfactory/burn";
		value: {
			sender: AccAddress;
			amount?: Coin;
		};
	}
	interface Data {
		"@type": "/osmosis.tokenfactory.v1beta1.MsgBurn";
		sender: AccAddress;
		amount?: Coin;
	}
	type Proto = MsgBurn_pb;
}
export declare class MsgChangeAdmin extends JSONSerializable<MsgChangeAdmin.Amino, MsgChangeAdmin.Data, MsgChangeAdmin.Proto> {
	sender: AccAddress;
	newAdmin: AccAddress;
	denom: string;
	/**
	 *
	 * @param sender current admin
	 * @param newAdmin new admin
	 * @param denom denom to change its admin
	 */
	constructor(sender: AccAddress, newAdmin: AccAddress, denom: string);
	toAmino(_?: boolean): MsgChangeAdmin.Amino;
	static fromProto(proto: MsgChangeAdmin.Proto, _?: boolean): MsgChangeAdmin;
	toProto(_?: boolean): MsgChangeAdmin.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgChangeAdmin;
	static fromData(data: MsgChangeAdmin.Data, _?: boolean): MsgChangeAdmin;
	toData(_?: boolean): MsgChangeAdmin.Data;
	static fromAmino(data: MsgChangeAdmin.Amino): MsgChangeAdmin;
}
export declare namespace MsgChangeAdmin {
	interface Amino {
		type: "osmosis/tokenfactory/change-admin";
		value: {
			sender: AccAddress;
			newAdmin: AccAddress;
			denom: string;
		};
	}
	interface Data {
		"@type": "/osmosis.tokenfactory.v1beta1.MsgChangeAdmin";
		sender: AccAddress;
		newAdmin: AccAddress;
		denom: string;
	}
	type Proto = MsgChangeAdmin_pb;
}
/**
 * MsgMint is the sdk.Msg type for allowing an admin account to mint
 * more of a token.  For now, we only support minting to the sender account
 */
export declare class MsgMint extends JSONSerializable<MsgMint.Amino, MsgMint.Data, MsgMint.Proto> {
	sender: AccAddress;
	amount?: Coin | undefined;
	/**
	 *
	 * @param sender internal account or external sender address
	 * @param amount amount of coins to mint
	 */
	constructor(sender: AccAddress, amount?: Coin | undefined);
	toAmino(_?: boolean): MsgMint.Amino;
	static fromProto(proto: MsgMint.Proto, _?: boolean): MsgMint;
	toProto(_?: boolean): MsgMint.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgMint;
	static fromData(data: MsgMint.Data, _?: boolean): MsgMint;
	toData(_?: boolean): MsgMint.Data;
	static fromAmino(data: MsgMint.Amino): MsgMint;
}
export declare namespace MsgMint {
	interface Amino {
		type: "osmosis/tokenfactory/mint";
		value: {
			sender: AccAddress;
			amount?: Coin;
		};
	}
	interface Data {
		"@type": "/osmosis.tokenfactory.v1beta1.MsgMint";
		sender: AccAddress;
		amount?: Coin;
	}
	type Proto = MsgMint_pb;
}
/**
 * MsgSetBeforeSendHook allows setting a hook for a specific denom
 * to keep track of the token transfers or block specific transfers.
 */
export declare class MsgSetBeforeSendHook extends JSONSerializable<MsgSetBeforeSendHook.Amino, MsgSetBeforeSendHook.Data, MsgSetBeforeSendHook.Proto> {
	sender: AccAddress;
	denom: string;
	cosmwasmAddress: string;
	/**
	 *
	 * @param sender internal account or external sender address
	 * @param denom with the format factory/terra1address/subdenom
	 * @param cosmwasmAddress the cosmwasm contract address
	 */
	constructor(sender: AccAddress, denom: string, cosmwasmAddress: string);
	toAmino(_?: boolean): MsgSetBeforeSendHook.Amino;
	static fromProto(proto: MsgSetBeforeSendHook.Proto, _?: boolean): MsgSetBeforeSendHook;
	toProto(_?: boolean): MsgSetBeforeSendHook.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgSetBeforeSendHook;
	static fromData(data: MsgSetBeforeSendHook.Data, _?: boolean): MsgSetBeforeSendHook;
	toData(_?: boolean): MsgSetBeforeSendHook.Data;
	static fromAmino(data: MsgSetBeforeSendHook.Amino): MsgSetBeforeSendHook;
}
export declare namespace MsgSetBeforeSendHook {
	interface Amino {
		type: "osmosis/tokenfactory/set-beforesend-hook";
		value: {
			sender: AccAddress;
			denom: string;
			cosmwasmAddress: string;
		};
	}
	interface Data {
		"@type": "/osmosis.tokenfactory.v1beta1.MsgSetBeforeSendHook";
		sender: AccAddress;
		denom: string;
		cosmwasmAddress: string;
	}
	type Proto = MsgSetBeforeSendHook_pb;
}
declare class MsgSetDenomMetadata extends JSONSerializable<MsgSetDenomMetadata.Amino, MsgSetDenomMetadata.Data, MsgSetDenomMetadata.Proto> {
	sender: AccAddress;
	metadata: Metadata;
	/**
	 *
	 * @param sender internal account or external sender address
	 * @param metadata the cosmwasm contract address
	 */
	constructor(sender: AccAddress, metadata: Metadata);
	toAmino(_?: boolean): MsgSetDenomMetadata.Amino;
	static fromProto(proto: MsgSetDenomMetadata.Proto, _?: boolean): MsgSetDenomMetadata;
	toProto(_?: boolean): MsgSetDenomMetadata.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgSetDenomMetadata;
	static fromData(data: MsgSetDenomMetadata.Data, _?: boolean): MsgSetDenomMetadata;
	toData(_?: boolean): MsgSetDenomMetadata.Data;
	static fromAmino(data: MsgSetDenomMetadata.Amino): MsgSetDenomMetadata;
}
declare namespace MsgSetDenomMetadata {
	interface Amino {
		type: "osmosis/tokenfactory/set-metadata";
		value: {
			sender: AccAddress;
			metadata: Metadata;
		};
	}
	interface Data {
		"@type": "/osmosis.tokenfactory.v1beta1.MsgSetDenomMetadata";
		sender: AccAddress;
		metadata: Metadata;
	}
	type Proto = MsgSetDenomMetadata_pb;
}
declare class MsgForceTransfer extends JSONSerializable<MsgForceTransfer.Amino, MsgForceTransfer.Data, MsgForceTransfer.Proto> {
	sender: AccAddress;
	amount: Coin;
	transferFromAddress: AccAddress;
	transferToAddress: AccAddress;
	/**
	 *
	 * @param sender internal account or external sender address
	 * @param metadata the cosmwasm contract address
	 */
	constructor(sender: AccAddress, amount: Coin, transferFromAddress: AccAddress, transferToAddress: AccAddress);
	toAmino(_?: boolean): MsgForceTransfer.Amino;
	static fromProto(proto: MsgForceTransfer.Proto, _?: boolean): MsgForceTransfer;
	toProto(_?: boolean): MsgForceTransfer.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgForceTransfer;
	static fromData(data: MsgForceTransfer.Data, _?: boolean): MsgForceTransfer;
	toData(_?: boolean): MsgForceTransfer.Data;
	static fromAmino(data: MsgForceTransfer.Amino): MsgForceTransfer;
}
declare namespace MsgForceTransfer {
	interface Amino {
		type: "osmosis/tokenfactory/force-transfer";
		value: {
			sender: AccAddress;
			amount: Coin.Amino;
			transferFromAddress: AccAddress;
			transferToAddress: AccAddress;
		};
	}
	interface Data {
		"@type": "/osmosis.tokenfactory.v1beta1.MsgForceTransfer";
		sender: AccAddress;
		amount: Coin.Data;
		transferFromAddress: AccAddress;
		transferToAddress: AccAddress;
	}
	type Proto = MsgForceTransfer_pb;
}
export type TokenFactoryMsg = MsgCreateDenom | MsgBurn | MsgChangeAdmin | MsgMint | MsgSetBeforeSendHook | MsgSetDenomMetadata | MsgForceTransfer | MsgSetDenomMetadata;
export declare namespace TokenFactoryMsg {
	type Amino = MsgCreateDenom.Amino | MsgBurn.Amino | MsgChangeAdmin.Amino | MsgMint.Amino | MsgSetBeforeSendHook.Amino | MsgSetDenomMetadata.Amino | MsgForceTransfer.Amino | MsgSetDenomMetadata.Amino;
	type Data = MsgCreateDenom.Data | MsgBurn.Data | MsgChangeAdmin.Data | MsgMint.Data | MsgSetBeforeSendHook.Data | MsgSetDenomMetadata.Data | MsgForceTransfer.Data | MsgSetDenomMetadata.Data;
	type Proto = MsgCreateDenom.Proto | MsgBurn.Proto | MsgChangeAdmin.Proto | MsgMint.Proto | MsgSetBeforeSendHook.Proto | MsgSetDenomMetadata.Proto | MsgForceTransfer.Proto | MsgSetDenomMetadata.Proto;
}
declare class Height extends JSONSerializable<Height.Amino, Height.Data, Height.Proto> {
	revision_number: number;
	revision_height: number;
	/**
	 * @param revision_number the revision that the client is currently on
	 * @param revision_height the height within the given revision
	 */
	constructor(revision_number: number, revision_height: number);
	static fromAmino(data: Height.Amino): Height;
	toAmino(): Height.Amino;
	static fromData(data: Height.Data): Height;
	toData(): Height.Data;
	static fromProto(proto: Height.Proto): Height;
	toProto(): Height.Proto;
}
declare namespace Height {
	interface Amino {
		revision_number?: string;
		revision_height?: string;
	}
	interface Data {
		revision_number: string;
		revision_height: string;
	}
	type Proto = Height_pb;
}
/**
 * A basic message for transfer [[Coin]] via IBC.
 */
export declare class MsgTransfer extends JSONSerializable<MsgTransfer.Amino, MsgTransfer.Data, MsgTransfer.Proto> {
	source_port: string;
	source_channel: string;
	token?: Coin;
	sender: AccAddress;
	receiver: string;
	timeout_height?: Height;
	timeout_timestamp?: Numeric.Output;
	memo?: string;
	/**
	 * @param source_port the port on which the packet will be sent
	 * @param source_channel  the channel by which the packet will be sent
	 * @param token the tokens to be transferred
	 * @param sender the sender address
	 * @param receiver the recipient address on the destination chain
	 * @param timeout_height Timeout height relative to the current block height. (0 to disable)
	 * @param timeout_timestamp Timeout timestamp (in nanoseconds) relative to the current block timestamp. (0 to disable)
	 * @param memo field can be used to send notes, interact with ibc-hooks, packet-middleware, etc...
	 */
	constructor(source_port: string, source_channel: string, token: Coin | undefined, sender: AccAddress, receiver: string, timeout_height: Height | undefined, timeout_timestamp: Numeric.Input | undefined, memo: string | undefined);
	static fromAmino(data: MsgTransfer.Amino, _?: boolean): MsgTransfer;
	toAmino(_?: boolean): MsgTransfer.Amino;
	static fromData(data: MsgTransfer.Data, _?: boolean): MsgTransfer;
	toData(_?: boolean): MsgTransfer.Data;
	static fromProto(proto: MsgTransfer.Proto, _?: boolean): MsgTransfer;
	toProto(_?: boolean): MsgTransfer.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): MsgTransfer;
}
export declare namespace MsgTransfer {
	interface Amino {
		type: "cosmos-sdk/MsgTransfer";
		value: {
			source_port: string;
			source_channel: string;
			token?: Coin.Amino;
			sender: AccAddress;
			receiver: string;
			timeout_height: Height.Amino;
			timeout_timestamp?: string;
			memo?: string;
		};
	}
	interface Data {
		"@type": "/ibc.applications.transfer.v1.MsgTransfer";
		source_port: string;
		source_channel: string;
		token?: Coin.Data;
		sender: AccAddress;
		receiver: string;
		timeout_height: Height.Data;
		timeout_timestamp: string;
		memo?: string;
	}
	type Proto = MsgTransfer_pb;
}
/**
 *  FungibleTokenPacketData defines a struct for the packet payload
 * See FungibleTokenPacketData spec:
 * https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures
 */
export declare class FungibleTokenPacketData extends JSONSerializable<FungibleTokenPacketData.Amino, FungibleTokenPacketData.Data, FungibleTokenPacketData.Proto> {
	denom: string;
	amount: string;
	sender: string;
	receiver: string;
	/**
	 * @param denom the token denomination to be transferred
	 * @param amount the token amount to be transferred
	 * @param sender the sender address
	 * @param receiver the recipient address on the destination chain
	 */
	constructor(denom: string, amount: string, sender: string, receiver: string);
	static fromAmino(data: FungibleTokenPacketData.Amino): FungibleTokenPacketData;
	toAmino(): FungibleTokenPacketData.Amino;
	static fromData(data: FungibleTokenPacketData.Data): FungibleTokenPacketData;
	toData(): FungibleTokenPacketData.Data;
	static fromProto(proto: FungibleTokenPacketData.Proto): FungibleTokenPacketData;
	toProto(): FungibleTokenPacketData.Proto;
}
export declare namespace FungibleTokenPacketData {
	interface Amino {
		denom: string;
		amount: string;
		sender: string;
		receiver: string;
	}
	interface Data {
		denom: string;
		amount: string;
		sender: string;
		receiver: string;
	}
	type Proto = FungibleTokenPacketData_pb;
}
/**
 * DenomTrace is a monotonically increasing data type
 * that can be compared against another DenomTrace for the purposes of updating and
 * freezing clients
 *
 * Normally the RevisionDenomTrace is incremented at each height while keeping
 * RevisionNumber the same. However some consensus algorithms may choose to
 * reset the height in certain conditions e.g. hard forks, state-machine
 * breaking changes In these cases, the RevisionNumber is incremented so that
 * height continues to be monitonically increasing even as the RevisionDenomTrace
 * gets reset
 */
export declare class DenomTrace extends JSONSerializable<DenomTrace.Amino, DenomTrace.Data, DenomTrace.Proto> {
	path: string;
	base_denom: string;
	/**
	 * @param path the revision that the client is currently on
	 * @param base_denom the height within the given revision
	 */
	constructor(path: string, base_denom: string);
	static fromAmino(data: DenomTrace.Amino): DenomTrace;
	toAmino(): DenomTrace.Amino;
	static fromData(data: DenomTrace.Data): DenomTrace;
	toData(): DenomTrace.Data;
	static fromProto(proto: DenomTrace.Proto): DenomTrace;
	toProto(): DenomTrace.Proto;
}
export declare namespace DenomTrace {
	interface Amino {
		path: string;
		base_denom: string;
	}
	interface Data {
		path: string;
		base_denom: string;
	}
	type Proto = DenomTrace_pb;
}
export type IbcTransferMsg = MsgTransfer;
export declare namespace IbcTransferMsg {
	type Data = MsgTransfer.Data;
	type Amino = MsgTransfer.Amino;
	type Proto = MsgTransfer.Proto;
}
/**
 * MsgCreateClient defines a message to create an IBC client
 */
export declare class MsgCreateClient extends JSONSerializable<any, MsgCreateClient.Data, MsgCreateClient.Proto> {
	client_state?: any;
	consensus_state?: any;
	signer: AccAddress;
	/**
	 * @param client_state light client state
	 * @param consensus_state consensus state associated with the client that corresponds to a given
	 * @param signer signer address
	 */
	constructor(client_state: any, consensus_state: any, signer: any);
	static fromAmino(_: any, isClassic?: boolean): MsgCreateClient;
	toAmino(_?: boolean): any;
	static fromData(data: MsgCreateClient.Data, _?: boolean): MsgCreateClient;
	toData(_?: boolean): MsgCreateClient.Data;
	static fromProto(proto: MsgCreateClient.Proto, _?: boolean): MsgCreateClient;
	toProto(_?: boolean): MsgCreateClient.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgCreateClient;
}
export declare namespace MsgCreateClient {
	interface Data {
		"@type": "/ibc.core.client.v1.MsgCreateClient";
		client_state?: any;
		consensus_state?: any;
		signer: AccAddress;
	}
	type Proto = MsgCreateClient_pb;
}
/**
 *  MsgSubmitMisbehaviour defines an sdk.Msg type that submits Evidence for light client misbehaviour.
 */
export declare class MsgSubmitMisbehaviour extends JSONSerializable<any, MsgSubmitMisbehaviour.Data, MsgSubmitMisbehaviour.Proto> {
	client_id: string;
	misbehaviour: any;
	signer: string;
	/**
	 * @param client_id client unique identifier
	 * @param misbehaviour misbehaviour used for freezing the light client
	 * @param signer signer address
	 */
	constructor(client_id: string, misbehaviour: any, signer: string);
	static fromAmino(_: any, isClassic?: boolean): MsgSubmitMisbehaviour;
	toAmino(_?: boolean): any;
	static fromData(data: MsgSubmitMisbehaviour.Data, _?: boolean): MsgSubmitMisbehaviour;
	toData(_?: boolean): MsgSubmitMisbehaviour.Data;
	static fromProto(proto: MsgSubmitMisbehaviour.Proto, _?: boolean): MsgSubmitMisbehaviour;
	toProto(_?: boolean): MsgSubmitMisbehaviour.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgSubmitMisbehaviour;
}
export declare namespace MsgSubmitMisbehaviour {
	interface Data {
		"@type": "/ibc.core.client.v1.MsgSubmitMisbehaviour";
		client_id: string;
		misbehaviour: any;
		signer: AccAddress;
	}
	type Proto = MsgSubmitMisbehaviour_pb;
}
/**
 * MsgUpdateClient defines an sdk.Msg to update a IBC client state using the given header
 */
export declare class MsgUpdateClient extends JSONSerializable<any, MsgUpdateClient.Data, MsgUpdateClient.Proto> {
	client_id: string;
	clientMessage: Any$1 | undefined;
	signer: string;
	/**
	 * @param client_id client unique identifier
	 * @param header header to update the light client
	 * @param signer signer address
	 */
	constructor(client_id: string, clientMessage: Any$1 | undefined, signer: string);
	static fromAmino(_: any, isClassic?: boolean): MsgUpdateClient;
	toAmino(): any;
	static fromData(data: MsgUpdateClient.Data, _?: boolean): MsgUpdateClient;
	toData(_?: boolean): MsgUpdateClient.Data;
	static fromProto(proto: MsgUpdateClient.Proto, _?: boolean): MsgUpdateClient;
	toProto(_?: boolean): MsgUpdateClient.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgUpdateClient;
}
export declare namespace MsgUpdateClient {
	interface Data {
		"@type": "/ibc.core.client.v1.MsgUpdateClient";
		client_id: string;
		clientMessage?: Any$1;
		signer: AccAddress;
	}
	type Proto = MsgUpdateClient_pb;
}
/**
 * MsgUpgradeClient defines an sdk.Msg to upgrade an IBC client to a new client state
 */
export declare class MsgUpgradeClient extends JSONSerializable<any, MsgUpgradeClient.Data, MsgUpgradeClient.Proto> {
	client_id: string;
	client_state: any;
	consensus_state: any;
	proof_upgrade_client: string;
	proof_upgrade_consensus_state: string;
	signer: AccAddress;
	/**
	 * @param client_id client unique identifier
	 * @param client_state  upgraded client state
	 * @param consensus_state upgraded consensus state, only contains enough information to serve as a basis of trust in update logic
	 * @param proof_upgrade_client proof that old chain committed to new client
	 * @param proof_upgrade_consensus_state  proof that old chain committed to new consensus state
	 * @param signer signer address
	 */
	constructor(client_id: string, client_state: any, consensus_state: any, proof_upgrade_client: string, proof_upgrade_consensus_state: string, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgUpgradeClient;
	toAmino(_?: boolean): any;
	static fromData(data: MsgUpgradeClient.Data, _?: boolean): MsgUpgradeClient;
	toData(_?: boolean): MsgUpgradeClient.Data;
	static fromProto(proto: MsgUpgradeClient.Proto, _?: boolean): MsgUpgradeClient;
	toProto(_?: boolean): MsgUpgradeClient.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgUpgradeClient;
}
export declare namespace MsgUpgradeClient {
	interface Data {
		"@type": "/ibc.core.client.v1.MsgUpgradeClient";
		client_id: string;
		client_state: any;
		consensus_state: any;
		proof_upgrade_client: string;
		proof_upgrade_consensus_state: string;
		signer: AccAddress;
	}
	type Proto = MsgUpgradeClient_pb;
}
export type IbcClientMsg = MsgCreateClient | MsgUpdateClient | MsgUpgradeClient | MsgSubmitMisbehaviour;
export declare namespace IbcClientMsg {
	type Data = MsgCreateClient.Data | MsgUpdateClient.Data | MsgUpgradeClient.Data | MsgSubmitMisbehaviour.Data;
	type Proto = MsgCreateClient.Proto | MsgUpdateClient.Proto | MsgUpgradeClient.Proto | MsgSubmitMisbehaviour.Proto;
}
declare class Version$1 extends JSONSerializable<Version$1.Amino, Version$1.Data, Version$1.Proto> {
	identifier: string;
	features: string[];
	/**
	 * @param identifier unique version identifier
	 * @param features list of features compatible with the specified identifier
	 */
	constructor(identifier: string, features: string[]);
	static fromAmino(data: Version$1.Amino): Version$1;
	toAmino(): Version$1.Amino;
	static fromData(data: Version$1.Data): Version$1;
	toData(): Version$1.Data;
	static fromProto(proto: Version$1.Proto): Version$1;
	toProto(): Version$1.Proto;
}
declare namespace Version$1 {
	interface Amino {
		identifier: string;
		features: string[];
	}
	interface Data {
		identifier: string;
		features: string[];
	}
	type Proto = Version_pb;
}
/**
 * MsgConnectionOpenAck defines a msg sent by a Relayer to Chain A to
 * acknowledge the change of connection state to TRYOPEN on Chain B.
 */
export declare class MsgConnectionOpenAck extends JSONSerializable<any, MsgConnectionOpenAck.Data, MsgConnectionOpenAck.Proto> {
	connection_id: string;
	counterparty_connection_id: string;
	version: Version$1 | undefined;
	client_state: any;
	proof_height: Height | undefined;
	proof_try: string;
	proof_client: string;
	proof_consensus: string;
	consensus_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param connection_id
	 * @param counterparty_connection_id
	 * @param version
	 * @param client_state
	 * @param proof_height proof of the initialization the connection on Chain B: `UNITIALIZED -> TRYOPEN`
	 * @param proof_try proof of client state included in message
	 * @param proof_client proof of client consensus state
	 * @param proof_consensus
	 * @param consenesus_height
	 * @param signer signer address
	 */
	constructor(connection_id: string, counterparty_connection_id: string, version: Version$1 | undefined, client_state: any, proof_height: Height | undefined, proof_try: string, proof_client: string, proof_consensus: string, consensus_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgConnectionOpenAck;
	toAmino(_?: boolean): any;
	static fromData(data: MsgConnectionOpenAck.Data, _?: boolean): MsgConnectionOpenAck;
	toData(_?: boolean): MsgConnectionOpenAck.Data;
	static fromProto(proto: MsgConnectionOpenAck.Proto, _?: boolean): MsgConnectionOpenAck;
	toProto(_?: boolean): MsgConnectionOpenAck.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgConnectionOpenAck;
}
export declare namespace MsgConnectionOpenAck {
	interface Data {
		"@type": "/ibc.core.connection.v1.MsgConnectionOpenAck";
		connection_id: string;
		counterparty_connection_id: string;
		version?: Version$1.Data;
		client_state: Any$1;
		proof_height?: Height.Data;
		proof_try: string;
		proof_client: string;
		proof_consensus: string;
		consensus_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgConnectionOpenAck_pb;
}
/**
 * MsgConnectionOpenConfirm defines a msg sent by a Relayer to Chain B to
 * acknowledge the change of connection state to OPEN on Chain A.
 */
export declare class MsgConnectionOpenConfirm extends JSONSerializable<any, MsgConnectionOpenConfirm.Data, MsgConnectionOpenConfirm.Proto> {
	connection_id: string;
	proof_ack: string;
	proof_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param connection_id
	 * @param proof_ack proof for the change of the connection state on Chain A: `INIT -> OPEN`
	 * @param proof_height
	 * @param signer signer address
	 */
	constructor(connection_id: string, proof_ack: string, proof_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgConnectionOpenConfirm;
	toAmino(_?: boolean): any;
	static fromData(data: MsgConnectionOpenConfirm.Data, _?: boolean): MsgConnectionOpenConfirm;
	toData(_?: boolean): MsgConnectionOpenConfirm.Data;
	static fromProto(proto: MsgConnectionOpenConfirm.Proto, _?: boolean): MsgConnectionOpenConfirm;
	toProto(_?: boolean): MsgConnectionOpenConfirm.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgConnectionOpenConfirm;
}
export declare namespace MsgConnectionOpenConfirm {
	interface Data {
		"@type": "/ibc.core.connection.v1.MsgConnectionOpenConfirm";
		connection_id: string;
		proof_ack: string;
		proof_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgConnectionOpenConfirm_pb;
}
declare class MerklePrefix extends JSONSerializable<MerklePrefix.Amino, MerklePrefix.Data, MerklePrefix.Proto> {
	key_prefix: string;
	/**
	 * @param key_prefix
	 */
	constructor(key_prefix: string);
	static fromAmino(data: MerklePrefix.Amino): MerklePrefix;
	toAmino(): MerklePrefix.Amino;
	static fromData(data: MerklePrefix.Data): MerklePrefix;
	toData(): MerklePrefix.Data;
	static fromProto(proto: MerklePrefix.Proto): MerklePrefix;
	toProto(): MerklePrefix.Proto;
}
declare namespace MerklePrefix {
	interface Amino {
		key_prefix: string;
	}
	interface Data {
		key_prefix: string;
	}
	type Proto = MerklePrefix_pb;
}
declare class Counterparty extends JSONSerializable<Counterparty.Amino, Counterparty.Data, Counterparty.Proto> {
	client_id: string;
	connection_id: string;
	prefix?: MerklePrefix | undefined;
	/**
	 * @param client_id identifies the client on the counterparty chain associated with a given connection.
	 * @param connection_id identifies the connection end on the counterparty chain associated with a given connection.
	 * @param prefix commitment merkle prefix of the counterparty chain.
	 */
	constructor(client_id: string, connection_id: string, prefix?: MerklePrefix | undefined);
	static fromAmino(data: Counterparty.Amino): Counterparty;
	toAmino(): Counterparty.Amino;
	static fromData(data: Counterparty.Data): Counterparty;
	toData(): Counterparty.Data;
	static fromProto(proto: Counterparty.Proto): Counterparty;
	toProto(): Counterparty.Proto;
}
declare namespace Counterparty {
	interface Amino {
		client_id: string;
		connection_id: string;
		prefix?: MerklePrefix.Amino;
	}
	interface Data {
		client_id: string;
		connection_id: string;
		prefix?: MerklePrefix.Data;
	}
	type Proto = Counterparty_pb;
}
/**
 * MsgConnectionOpenInit defines the msg sent by an account on Chain A to initialize a connection with Chain B.
 */
export declare class MsgConnectionOpenInit extends JSONSerializable<any, MsgConnectionOpenInit.Data, MsgConnectionOpenInit.Proto> {
	client_id: string;
	counterparty?: Counterparty;
	version?: Version$1;
	delay_period: number;
	signer: AccAddress;
	/**
	 * @param client_id identifier of the port to use
	 * @param counterparty
	 * @param version
	 * @param delay_period
	 * @param signer signer address
	 */
	constructor(client_id: string, delay_period: number, signer: AccAddress, counterparty?: Counterparty, version?: Version$1);
	static fromAmino(_: any, isClassic?: boolean): MsgConnectionOpenInit;
	toAmino(_?: boolean): any;
	static fromData(data: MsgConnectionOpenInit.Data, _?: boolean): MsgConnectionOpenInit;
	toData(_?: boolean): MsgConnectionOpenInit.Data;
	static fromProto(proto: MsgConnectionOpenInit.Proto, _?: boolean): MsgConnectionOpenInit;
	toProto(_?: boolean): MsgConnectionOpenInit.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgConnectionOpenInit;
}
export declare namespace MsgConnectionOpenInit {
	interface Data {
		"@type": "/ibc.core.connection.v1.MsgConnectionOpenInit";
		client_id: string;
		counterparty?: Counterparty.Data;
		version?: Version$1.Data;
		delay_period: string;
		signer: AccAddress;
	}
	type Proto = MsgConnectionOpenInit_pb;
}
/**
 *  MsgConnectionOpenTry defines a msg sent by a Relayer to try to open a connection on Chain B.
 */
export declare class MsgConnectionOpenTry extends JSONSerializable<any, MsgConnectionOpenTry.Data, MsgConnectionOpenTry.Proto> {
	client_id: string;
	previous_connection_id: string;
	client_state: any;
	counterparty: Counterparty | undefined;
	delay_period: number;
	counterparty_versions: Version$1[];
	proof_height: Height | undefined;
	proof_init: string;
	proof_client: string;
	proof_consensus: string;
	consensus_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param client_id in the case of crossing hello's, when both chains call OpenInit, we need the connection identifier of the previous connection in state INIT
	 * @param previous_connection_id
	 * @param client_state
	 * @param counterparty
	 * @param delay_period
	 * @param counterparty_versions
	 * @param proof_height proof of the initialization the connection on Chain A: `UNITIALIZED -> INIT`
	 * @param proof_init proof of client state included in message
	 * @param proof_client proof of client consensus state
	 * @param proof_consensus
	 * @param consensus_height
	 * @param signer signer address
	 */
	constructor(client_id: string, previous_connection_id: string, client_state: any, counterparty: Counterparty | undefined, delay_period: number, counterparty_versions: Version$1[], proof_height: Height | undefined, proof_init: string, proof_client: string, proof_consensus: string, consensus_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgConnectionOpenTry;
	toAmino(_?: boolean): any;
	static fromData(data: MsgConnectionOpenTry.Data, _?: boolean): MsgConnectionOpenTry;
	toData(_?: boolean): MsgConnectionOpenTry.Data;
	static fromProto(proto: MsgConnectionOpenTry.Proto, _?: boolean): MsgConnectionOpenTry;
	toProto(_?: boolean): MsgConnectionOpenTry.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgConnectionOpenTry;
}
export declare namespace MsgConnectionOpenTry {
	interface Data {
		"@type": "/ibc.core.connection.v1.MsgConnectionOpenTry";
		client_id: string;
		previous_connection_id: string;
		client_state: Any$1;
		counterparty?: Counterparty.Data;
		delay_period: string;
		counterparty_versions: Version$1.Data[];
		proof_height?: Height.Data;
		proof_init: string;
		proof_client: string;
		proof_consensus: string;
		consensus_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgConnectionOpenTry_pb;
}
export type IbcConnectionMsg = MsgConnectionOpenInit | MsgConnectionOpenTry | MsgConnectionOpenConfirm | MsgConnectionOpenAck;
export declare namespace IbcConnectionMsg {
	type Data = MsgConnectionOpenInit.Data | MsgConnectionOpenTry.Data | MsgConnectionOpenConfirm.Data | MsgConnectionOpenAck.Data;
	type Proto = MsgConnectionOpenInit.Proto | MsgConnectionOpenTry.Proto | MsgConnectionOpenConfirm.Proto | MsgConnectionOpenAck.Proto;
}
declare class Counterparty$1 extends JSONSerializable<Counterparty$1.Amino, Counterparty$1.Data, Counterparty$1.Proto> {
	port_id: string;
	channel_id: string;
	/**
	 * @param port_id port on the counterparty chain which owns the other end of the channel.
	 * @param channel_id channel end on the counterparty chain
	 */
	constructor(port_id: string, channel_id: string);
	static fromAmino(data: Counterparty$1.Amino): Counterparty$1;
	toAmino(): Counterparty$1.Amino;
	static fromData(data: Counterparty$1.Data): Counterparty$1;
	toData(): Counterparty$1.Data;
	static fromProto(proto: Counterparty$1.Proto): Counterparty$1;
	toProto(): Counterparty$1.Proto;
}
declare namespace Counterparty$1 {
	interface Amino {
		port_id: string;
		channel_id: string;
	}
	interface Data {
		port_id: string;
		channel_id: string;
	}
	type Proto = Counterparty_pb$1;
}
declare class Channel extends JSONSerializable<Channel.Amino, Channel.Data, Channel.Proto> {
	state: State$1;
	ordering: Order;
	counterparty: Counterparty$1 | undefined;
	connection_hops: string[];
	version: string;
	/**
	 * @param state current state of the channel end
	 * @param ordering  whether the channel is ordered or unordered
	 * @param counterparty counterparty channel end
	 * @param connection_hops list of connection identifiers, in order, along which packets sent on this channel will travel
	 * @param version opaque channel version, which is agreed upon during the handshake
	 */
	constructor(state: State$1, ordering: Order, counterparty: Counterparty$1 | undefined, connection_hops: string[], version: string);
	static fromAmino(data: Channel.Amino): Channel;
	toAmino(): Channel.Amino;
	static fromData(data: Channel.Data): Channel;
	toData(): Channel.Data;
	static fromProto(proto: Channel.Proto): Channel;
	toProto(): Channel.Proto;
}
declare namespace Channel {
	interface Amino {
		state: State$1;
		ordering: Order;
		counterparty?: Counterparty$1.Amino;
		connection_hops: string[];
		version: string;
	}
	interface Data {
		state: State$1;
		ordering: Order;
		counterparty?: Counterparty$1.Data;
		connection_hops: string[];
		version: string;
	}
	type Proto = Channel_pb;
}
/**
 * MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake. It is called by a relayer on Chain A.
 */
export declare class MsgChannelOpenInit extends JSONSerializable<any, MsgChannelOpenInit.Data, MsgChannelOpenInit.Proto> {
	port_id: string;
	channel: Channel | undefined;
	signer: AccAddress;
	/**
	 * @param port_id identifier of the port to use
	 * @param channel channel info
	 * @param signer signer address
	 */
	constructor(port_id: string, channel: Channel | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgChannelOpenInit;
	toAmino(_?: boolean): any;
	static fromData(data: MsgChannelOpenInit.Data, _?: boolean): MsgChannelOpenInit;
	toData(_?: boolean): MsgChannelOpenInit.Data;
	static fromProto(proto: MsgChannelOpenInit.Proto, _?: boolean): MsgChannelOpenInit;
	toProto(_?: boolean): MsgChannelOpenInit.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgChannelOpenInit;
}
export declare namespace MsgChannelOpenInit {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgChannelOpenInit";
		port_id: string;
		channel?: Channel.Data;
		signer: AccAddress;
	}
	type Proto = MsgChannelOpenInit_pb;
}
/**
 * MsgChannelOpenTry defines a msg sent by a Relayer to try to open a channel on Chain B
 */
export declare class MsgChannelOpenTry extends JSONSerializable<any, MsgChannelOpenTry.Data, MsgChannelOpenTry.Proto> {
	port_id: string;
	previous_channel_id: string;
	channel: Channel | undefined;
	counterparty_version: string;
	proof_init: string;
	proof_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param port_id identifier of the port to use
	 * @param previous_channel_id
	 * @param channel channel info
	 * @param counterparty_version
	 * @param proof_init
	 * @param proof_height
	 * @param signer signer address
	 */
	constructor(port_id: string, previous_channel_id: string, channel: Channel | undefined, counterparty_version: string, proof_init: string, proof_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgChannelOpenTry;
	toAmino(_?: boolean): any;
	static fromData(data: MsgChannelOpenTry.Data, _?: boolean): MsgChannelOpenTry;
	toData(_?: boolean): MsgChannelOpenTry.Data;
	static fromProto(proto: MsgChannelOpenTry.Proto, _?: boolean): MsgChannelOpenTry;
	toProto(_?: boolean): MsgChannelOpenTry.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgChannelOpenTry;
}
export declare namespace MsgChannelOpenTry {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgChannelOpenTry";
		port_id: string;
		previous_channel_id: string;
		channel?: Channel.Data;
		counterparty_version: string;
		proof_init: string;
		proof_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgChannelOpenTry_pb;
}
/**
 *  MsgChannelOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to OPEN on Chain A.
 */
export declare class MsgChannelOpenConfirm extends JSONSerializable<any, MsgChannelOpenConfirm.Data, MsgChannelOpenConfirm.Proto> {
	port_id: string;
	channel_id: string;
	proof_ack: string;
	proof_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param port_id identifier of the port to use
	 * @param channel_id
	 * @param proof_ack
	 * @param proof_height
	 * @param signer signer address
	 */
	constructor(port_id: string, channel_id: string, proof_ack: string, proof_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgChannelOpenConfirm;
	toAmino(_?: boolean): any;
	static fromData(data: MsgChannelOpenConfirm.Data, _?: boolean): MsgChannelOpenConfirm;
	toData(_?: boolean): MsgChannelOpenConfirm.Data;
	static fromProto(proto: MsgChannelOpenConfirm.Proto, _?: boolean): MsgChannelOpenConfirm;
	toProto(_?: boolean): MsgChannelOpenConfirm.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgChannelOpenConfirm;
}
export declare namespace MsgChannelOpenConfirm {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgChannelOpenConfirm";
		port_id: string;
		channel_id: string;
		proof_ack: string;
		proof_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgChannelOpenConfirm_pb;
}
/**
 * MsgChannelOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of channel state to TRYOPEN on Chain B.
 */
export declare class MsgChannelOpenAck extends JSONSerializable<any, MsgChannelOpenAck.Data, MsgChannelOpenAck.Proto> {
	port_id: string;
	channel_id: string;
	counterparty_channel_id: string;
	counterparty_version: string;
	proof_try: string;
	proof_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param port_id identifier of the port to use
	 * @param channel_id
	 * @param counterparty_channel_id
	 * @param counterparty_version
	 * @param proof_try
	 * @param proof_height
	 * @param signer signer address
	 */
	constructor(port_id: string, channel_id: string, counterparty_channel_id: string, counterparty_version: string, proof_try: string, proof_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgChannelOpenAck;
	toAmino(_?: boolean): any;
	static fromData(data: MsgChannelOpenAck.Data, _?: boolean): MsgChannelOpenAck;
	toData(_?: boolean): MsgChannelOpenAck.Data;
	static fromProto(proto: MsgChannelOpenAck.Proto, _?: boolean): MsgChannelOpenAck;
	toProto(_?: boolean): MsgChannelOpenAck.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgChannelOpenAck;
}
export declare namespace MsgChannelOpenAck {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgChannelOpenAck";
		port_id: string;
		channel_id: string;
		counterparty_channel_id: string;
		counterparty_version: string;
		proof_try: string;
		proof_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgChannelOpenAck_pb;
}
/**
 * MsgChannelCloseInit defines a msg sent by a Relayer to Chain A to close a channel with Chain B.
 */
export declare class MsgChannelCloseInit extends JSONSerializable<any, MsgChannelCloseInit.Data, MsgChannelCloseInit.Proto> {
	port_id: string;
	channel_id: string;
	signer: AccAddress;
	/**
	 * @param port_id identifier of the port to use
	 * @param channel channel info
	 * @param signer signer address
	 */
	constructor(port_id: string, channel_id: string, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgChannelCloseInit;
	toAmino(_?: boolean): any;
	static fromData(data: MsgChannelCloseInit.Data, _?: boolean): MsgChannelCloseInit;
	toData(_?: boolean): MsgChannelCloseInit.Data;
	static fromProto(proto: MsgChannelCloseInit.Proto, _?: boolean): MsgChannelCloseInit;
	toProto(_?: boolean): MsgChannelCloseInit.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgChannelCloseInit;
}
export declare namespace MsgChannelCloseInit {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgChannelCloseInit";
		port_id: string;
		channel_id: string;
		signer: AccAddress;
	}
	type Proto = MsgChannelCloseInit_pb;
}
/**
 * MsgChannelCloseConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to CLOSED on Chain A.
 */
export declare class MsgChannelCloseConfirm extends JSONSerializable<any, MsgChannelCloseConfirm.Data, MsgChannelCloseConfirm.Proto> {
	port_id: string;
	channel_id: string;
	proof_init: string;
	proof_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param port_id identifier of the port to use
	 * @param channel_id
	 * @param proof_init
	 * @param proof_height
	 * @param signer signer address
	 */
	constructor(port_id: string, channel_id: string, proof_init: string, proof_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgChannelCloseConfirm;
	toAmino(_?: boolean): any;
	static fromData(data: MsgChannelCloseConfirm.Data, _?: boolean): MsgChannelCloseConfirm;
	toData(_?: boolean): MsgChannelCloseConfirm.Data;
	static fromProto(proto: MsgChannelCloseConfirm.Proto, _?: boolean): MsgChannelCloseConfirm;
	toProto(_?: boolean): MsgChannelCloseConfirm.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgChannelCloseConfirm;
}
export declare namespace MsgChannelCloseConfirm {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgChannelCloseConfirm";
		port_id: string;
		channel_id: string;
		proof_init: string;
		proof_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgChannelCloseConfirm_pb;
}
declare class Packet extends JSONSerializable<Packet.Amino, Packet.Data, Packet.Proto> {
	sequence: number;
	source_port: string;
	source_channel: string;
	destination_port: string;
	destination_channel: string;
	data: string;
	timeout_height: Height | undefined;
	timeout_timestamp: number;
	/**
	 * @param port_id port on the counterparty chain which owns the other end of the channel.
	 * @param channel_id channel end on the counterparty chain
	 */
	constructor(sequence: number, source_port: string, source_channel: string, destination_port: string, destination_channel: string, data: string, timeout_height: Height | undefined, timeout_timestamp: number);
	static fromAmino(_data: Packet.Amino): Packet;
	toAmino(): Packet.Amino;
	static fromData(_data: Packet.Data): Packet;
	toData(): Packet.Data;
	static fromProto(proto: Packet.Proto): Packet;
	toProto(): Packet.Proto;
}
declare namespace Packet {
	interface Amino {
		sequence: number;
		source_port: string;
		source_channel: string;
		destination_port: string;
		destination_channel: string;
		data: string;
		timeout_height?: Height.Amino;
		timeout_timestamp: number;
	}
	interface Data {
		sequence: number;
		source_port: string;
		source_channel: string;
		destination_port: string;
		destination_channel: string;
		data: string;
		timeout_height?: Height.Data;
		timeout_timestamp: string;
	}
	type Proto = Packet_pb;
}
/**
 * MsgRecvPacket receives incoming IBC packet
 */
export declare class MsgRecvPacket extends JSONSerializable<any, MsgRecvPacket.Data, MsgRecvPacket.Proto> {
	packet: Packet | undefined;
	proof_commitment: string;
	proof_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param packet
	 * @param proof_commitment
	 * @param proof_height
	 * @param signer signer address
	 */
	constructor(packet: Packet | undefined, proof_commitment: string, proof_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgRecvPacket;
	toAmino(_?: boolean): any;
	static fromData(data: MsgRecvPacket.Data, _?: boolean): MsgRecvPacket;
	toData(_?: boolean): MsgRecvPacket.Data;
	static fromProto(proto: MsgRecvPacket.Proto, _?: boolean): MsgRecvPacket;
	toProto(_?: boolean): MsgRecvPacket.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgRecvPacket;
}
export declare namespace MsgRecvPacket {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgRecvPacket";
		packet?: Packet.Data;
		proof_commitment: string;
		proof_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgRecvPacket_pb;
}
/**
 * MsgAcknowledgement receives incoming IBC acknowledgement
 */
export declare class MsgAcknowledgement extends JSONSerializable<any, MsgAcknowledgement.Data, MsgAcknowledgement.Proto> {
	packet: Packet | undefined;
	acknowledgement: string;
	proof_acked: string;
	proof_height: Height | undefined;
	signer: AccAddress;
	/**
	 * @param packet
	 * @param acknowledgement
	 * @param proof_acked
	 * @param proof_height
	 * @param signer signer address
	 */
	constructor(packet: Packet | undefined, acknowledgement: string, proof_acked: string, proof_height: Height | undefined, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgAcknowledgement;
	toAmino(_?: boolean): any;
	static fromData(data: MsgAcknowledgement.Data, _?: boolean): MsgAcknowledgement;
	toData(_?: boolean): MsgAcknowledgement.Data;
	static fromProto(proto: MsgAcknowledgement.Proto, _?: boolean): MsgAcknowledgement;
	toProto(_?: boolean): MsgAcknowledgement.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgAcknowledgement;
}
export declare namespace MsgAcknowledgement {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgAcknowledgement";
		packet?: Packet.Data;
		acknowledgement: string;
		proof_acked: string;
		proof_height?: Height.Data;
		signer: AccAddress;
	}
	type Proto = MsgAcknowledgement_pb;
}
/**
 * MsgTimeout receives timed-out packet
 */
export declare class MsgTimeout extends JSONSerializable<any, MsgTimeout.Data, MsgTimeout.Proto> {
	packet: Packet | undefined;
	proof_unreceived: string;
	proof_height: Height | undefined;
	next_sequence_recv: number;
	signer: AccAddress;
	/**
	 * @param packet
	 * @param proof_unreceived
	 * @param proof_height
	 * @param next_seuqnce_recv
	 * @param signer signer address
	 */
	constructor(packet: Packet | undefined, proof_unreceived: string, proof_height: Height | undefined, next_sequence_recv: number, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgTimeout;
	toAmino(_?: boolean): any;
	static fromData(data: MsgTimeout.Data, _?: boolean): MsgTimeout;
	toData(_?: boolean): MsgTimeout.Data;
	static fromProto(proto: MsgTimeout.Proto, _?: boolean): MsgTimeout;
	toProto(_?: boolean): MsgTimeout.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgTimeout;
}
export declare namespace MsgTimeout {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgTimeout";
		packet?: Packet.Data;
		proof_unreceived: string;
		proof_height?: Height.Data;
		next_sequence_recv: string;
		signer: AccAddress;
	}
	type Proto = MsgTimeout_pb;
}
/**
 * MsgTimeoutOnClose timed-out packet upon counterparty channel closure.
 */
export declare class MsgTimeoutOnClose extends JSONSerializable<any, MsgTimeoutOnClose.Data, MsgTimeoutOnClose.Proto> {
	packet: Packet | undefined;
	proof_unreceived: string;
	proof_close: string;
	proof_height: Height | undefined;
	next_sequence_recv: number;
	signer: AccAddress;
	/**
	 * @param packet
	 * @param proof_unreceived
	 * @param proof_height
	 * @param proof_close
	 * @param next_seuqnce_recv
	 * @param signer signer address
	 */
	constructor(packet: Packet | undefined, proof_unreceived: string, proof_close: string, proof_height: Height | undefined, next_sequence_recv: number, signer: AccAddress);
	static fromAmino(_: any, isClassic?: boolean): MsgTimeoutOnClose;
	toAmino(_?: boolean): any;
	static fromData(data: MsgTimeoutOnClose.Data, _?: boolean): MsgTimeoutOnClose;
	toData(_?: boolean): MsgTimeoutOnClose.Data;
	static fromProto(proto: MsgTimeoutOnClose.Proto, _?: boolean): MsgTimeoutOnClose;
	toProto(_?: boolean): MsgTimeoutOnClose.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgTimeoutOnClose;
}
export declare namespace MsgTimeoutOnClose {
	interface Data {
		"@type": "/ibc.core.channel.v1.MsgTimeoutOnClose";
		packet?: Packet.Data;
		proof_unreceived: string;
		proof_close: string;
		proof_height?: Height.Data;
		next_sequence_recv: string;
		signer: AccAddress;
	}
	type Proto = MsgTimeoutOnClose_pb;
}
export type IbcChannelMsg = MsgChannelOpenInit | MsgChannelOpenTry | MsgChannelOpenConfirm | MsgChannelOpenAck | MsgChannelCloseInit | MsgChannelCloseConfirm | MsgRecvPacket | MsgAcknowledgement | MsgTimeout | MsgTimeoutOnClose;
export declare namespace IbcChannelMsg {
	type Data = MsgChannelOpenInit.Data | MsgChannelOpenTry.Data | MsgChannelOpenConfirm.Data | MsgChannelOpenAck.Data | MsgChannelCloseInit.Data | MsgChannelCloseConfirm.Data | MsgRecvPacket.Data | MsgAcknowledgement.Data | MsgTimeout.Data | MsgTimeoutOnClose.Data;
	type Proto = MsgChannelOpenInit.Proto | MsgChannelOpenTry.Proto | MsgChannelOpenConfirm.Proto | MsgChannelOpenAck.Proto | MsgChannelCloseInit.Proto | MsgChannelCloseConfirm.Proto | MsgRecvPacket.Proto | MsgAcknowledgement.Proto | MsgTimeout.Proto | MsgTimeoutOnClose.Proto;
}
declare class MsgVerifyInvariant extends JSONSerializable<MsgVerifyInvariant.Amino, MsgVerifyInvariant.Data, MsgVerifyInvariant.Proto> {
	sender: AccAddress;
	invariantModuleName: string;
	invariantRoute: string;
	/**
	 * @param sender sender's address
	 * @param invariantModuleName module name to verify invariant
	 * @param invariantRoute route to verify
	 */
	constructor(sender: AccAddress, invariantModuleName: string, invariantRoute: string);
	static fromAmino(data: MsgVerifyInvariant.Amino, _?: boolean): MsgVerifyInvariant;
	toAmino(_?: boolean): MsgVerifyInvariant.Amino;
	static fromData(data: MsgVerifyInvariant.Data, _?: boolean): MsgVerifyInvariant;
	toData(_?: boolean): MsgVerifyInvariant.Data;
	static fromProto(proto: MsgVerifyInvariant.Proto, _?: boolean): MsgVerifyInvariant;
	toProto(_?: boolean): MsgVerifyInvariant.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): MsgVerifyInvariant;
}
declare namespace MsgVerifyInvariant {
	interface Amino {
		type: "crisis/MsgVerifyInvariant" | "cosmos-sdk/MsgVerifyInvariant";
		value: {
			sender: AccAddress;
			invariantModuleName: string;
			invariantRoute: string;
		};
	}
	interface Data {
		"@type": "/cosmos.crisis.v1beta1.MsgVerifyInvariant";
		sender: AccAddress;
		invariantModuleName: string;
		invariantRoute: string;
	}
	type Proto = MsgVerifyInvariant_pb;
}
export type CrisisMsg = MsgVerifyInvariant;
declare namespace CrisisMsg {
	type Amino = MsgVerifyInvariant.Amino;
	type Data = MsgVerifyInvariant.Data;
	type Proto = MsgVerifyInvariant.Proto;
}
declare class MsgAuctionBid extends JSONSerializable<MsgAuctionBid.Amino, MsgAuctionBid.Data, MsgAuctionBid.Proto> {
	bidder: string;
	transactions: Uint8Array[];
	bid?: Coin | undefined;
	/**
	 * @param bidder bidder's address
	 * @param transactions signed transactions to include in the next block
	 * @param bid amount of coin that will be used to bid for the auction
	 */
	constructor(bidder: string, transactions: Uint8Array[], bid?: Coin | undefined);
	static fromAmino(data: MsgAuctionBid.Amino, _?: boolean): MsgAuctionBid;
	toAmino(_?: boolean): MsgAuctionBid.Amino;
	static fromData(data: MsgAuctionBid.Data, _?: boolean): MsgAuctionBid;
	toData(_?: boolean): MsgAuctionBid.Data;
	static fromProto(proto: MsgAuctionBid.Proto, _?: boolean): MsgAuctionBid;
	toProto(_?: boolean): MsgAuctionBid.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): MsgAuctionBid;
}
declare namespace MsgAuctionBid {
	interface Amino {
		type: "pob/MsgAuctionBid";
		value: {
			bidder: AccAddress;
			transactions: Uint8Array[];
			bid?: Coin.Amino;
		};
	}
	interface Data {
		"@type": "/pob.builder.v1.MsgAuctionBid";
		bidder: AccAddress;
		transactions: Uint8Array[];
		bid?: Coin.Data;
	}
	type Proto = MsgAuctionBid_pb;
}
export declare class MsgRegisterFeeShare extends JSONSerializable<MsgRegisterFeeShare.Amino, MsgRegisterFeeShare.Data, MsgRegisterFeeShare.Proto> {
	contract_address: AccAddress;
	deployer_address: AccAddress;
	withdrawer_address: AccAddress;
	constructor(contract_address: AccAddress, deployer_address: AccAddress, withdrawer_address: AccAddress);
	static fromAmino(data: MsgRegisterFeeShare.Amino, _?: boolean): MsgRegisterFeeShare;
	toAmino(_?: boolean): MsgRegisterFeeShare.Amino;
	static fromData(proto: MsgRegisterFeeShare.Data, _?: boolean): MsgRegisterFeeShare;
	toData(_?: boolean): MsgRegisterFeeShare.Data;
	static fromProto(proto: MsgRegisterFeeShare.Proto, _?: boolean): MsgRegisterFeeShare;
	toProto(_?: boolean): MsgRegisterFeeShare.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgRegisterFeeShare;
}
export declare namespace MsgRegisterFeeShare {
	interface Amino {
		type: "juno/MsgRegisterFeeShare";
		value: {
			contract_address: AccAddress;
			deployer_address: AccAddress;
			withdrawer_address: AccAddress;
		};
	}
	interface Data {
		"@type": "/juno.feeshare.v1.MsgRegisterFeeShare";
		contract_address: AccAddress;
		deployer_address: AccAddress;
		withdrawer_address: AccAddress;
	}
	type Proto = MsgRegisterFeeShare_pb;
}
export declare class MsgUpdateFeeShare extends JSONSerializable<MsgUpdateFeeShare.Amino, MsgUpdateFeeShare.Data, MsgUpdateFeeShare.Proto> {
	contract_address: AccAddress;
	deployer_address: AccAddress;
	withdrawer_address: AccAddress;
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_address validator's operator address
	 * @param denom alliance denom to claim rewards for (e.g. ibc/AAE7E4 or uluna...)
	 */
	constructor(contract_address: AccAddress, deployer_address: AccAddress, withdrawer_address: AccAddress);
	static fromAmino(data: MsgUpdateFeeShare.Amino, _?: boolean): MsgUpdateFeeShare;
	toAmino(_?: boolean): MsgUpdateFeeShare.Amino;
	static fromData(proto: MsgUpdateFeeShare.Data, _?: boolean): MsgUpdateFeeShare;
	toData(_?: boolean): MsgUpdateFeeShare.Data;
	static fromProto(proto: MsgUpdateFeeShare.Proto, _?: boolean): MsgUpdateFeeShare;
	toProto(_?: boolean): MsgUpdateFeeShare.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgUpdateFeeShare;
}
export declare namespace MsgUpdateFeeShare {
	interface Amino {
		type: "juno/MsgUpdateFeeShare";
		value: {
			contract_address: AccAddress;
			deployer_address: AccAddress;
			withdrawer_address: AccAddress;
		};
	}
	interface Data {
		"@type": "/juno.feeshare.v1.MsgUpdateFeeShare";
		contract_address: AccAddress;
		deployer_address: AccAddress;
		withdrawer_address: AccAddress;
	}
	type Proto = MsgUpdateFeeShare_pb;
}
export declare class MsgCancelFeeShare extends JSONSerializable<MsgCancelFeeShare.Amino, MsgCancelFeeShare.Data, MsgCancelFeeShare.Proto> {
	contract_address: AccAddress;
	deployer_address: AccAddress;
	constructor(contract_address: AccAddress, deployer_address: AccAddress);
	static fromAmino(data: MsgCancelFeeShare.Amino, _?: boolean): MsgCancelFeeShare;
	toAmino(_?: boolean): MsgCancelFeeShare.Amino;
	static fromData(proto: MsgCancelFeeShare.Data, _?: boolean): MsgCancelFeeShare;
	toData(_?: boolean): MsgCancelFeeShare.Data;
	static fromProto(proto: MsgCancelFeeShare.Proto, _?: boolean): MsgCancelFeeShare;
	toProto(_?: boolean): MsgCancelFeeShare.Proto;
	packAny(_?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, _?: boolean): MsgCancelFeeShare;
}
export declare namespace MsgCancelFeeShare {
	interface Amino {
		type: "juno/MsgCancelFeeShare";
		value: {
			contract_address: AccAddress;
			deployer_address: AccAddress;
		};
	}
	interface Data {
		"@type": "/juno.feeshare.v1.MsgCancelFeeShare";
		contract_address: AccAddress;
		deployer_address: AccAddress;
	}
	type Proto = MsgCancelFeeShare_pb;
}
export type FeeshareMsg = MsgRegisterFeeShare | MsgUpdateFeeShare | MsgCancelFeeShare;
export declare namespace FeeshareMsg {
	type Amino = MsgRegisterFeeShare.Amino | MsgUpdateFeeShare.Amino | MsgCancelFeeShare.Amino;
	type Data = MsgRegisterFeeShare.Data | MsgUpdateFeeShare.Data | MsgCancelFeeShare.Data;
	type Proto = MsgRegisterFeeShare.Proto | MsgUpdateFeeShare.Proto | MsgCancelFeeShare.Proto;
}
declare class MsgRegisterInterchainAccount extends JSONSerializable<MsgRegisterInterchainAccount.Amino, MsgRegisterInterchainAccount.Data, MsgRegisterInterchainAccount.Proto> {
	owner: AccAddress;
	connectionId: string;
	version: string;
	/**
	 * @param owner sender's address
	 * @param connectionId ibc connection id
	 * @param version of the interchain account
	 */
	constructor(owner: AccAddress, connectionId: string, version: string);
	static fromAmino(data: MsgRegisterInterchainAccount.Amino, _?: boolean): MsgRegisterInterchainAccount;
	toAmino(_?: boolean): MsgRegisterInterchainAccount.Amino;
	static fromData(data: MsgRegisterInterchainAccount.Data, _?: boolean): MsgRegisterInterchainAccount;
	toData(_?: boolean): MsgRegisterInterchainAccount.Data;
	static fromProto(proto: MsgRegisterInterchainAccount.Proto, _?: boolean): MsgRegisterInterchainAccount;
	toProto(_?: boolean): MsgRegisterInterchainAccount.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): MsgRegisterInterchainAccount;
}
declare namespace MsgRegisterInterchainAccount {
	interface Amino {
		value: {};
	}
	interface Data {
		"@type": "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount";
		owner: AccAddress;
		connection_id: string;
		version: string;
	}
	type Proto = MsgRegisterInterchainAccount_pb;
}
declare class CosmosTx extends JSONSerializable<{}, CosmosTx.Data, CosmosTx.Proto> {
	messages: Msg[];
	/**
	 * @param messages all proto messages that are part of the transaction
	 */
	constructor(messages: Msg[]);
	static fromAmino(data: CosmosTx.Amino, _?: boolean): CosmosTx;
	toAmino(_?: boolean): CosmosTx.Amino;
	static fromData(data: CosmosTx.Data, _?: boolean): CosmosTx;
	toData(_?: boolean): CosmosTx.Data;
	static fromProto(proto: CosmosTx.Proto, _?: boolean): CosmosTx;
	toProto(_?: boolean): CosmosTx.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): CosmosTx;
}
declare namespace CosmosTx {
	export interface Amino {
		value: {};
	}
	type Base64String = string;
	export type Data = Base64String;
	export type Proto = CosmosTx_pb;
	export {};
}
declare class InterchainAccountPacketData extends JSONSerializable<{}, InterchainAccountPacketData.Data, InterchainAccountPacketData.Proto> {
	data: CosmosTx;
	memo: string;
	type: Type;
	/**
	 * @param data to be executed on host chain
	 * @param memo for the transaction to be executed on host chain
	 * @param type by default is **TYPE_EXECUTE_TX** which means that the Msg is converted from proto TYPE_UNSPECIFIED, TYPE_EXECUTE_TX or UNRECOGNIZED
	 */
	constructor(data: CosmosTx, memo?: string, type?: Type);
	static fromAmino(data: InterchainAccountPacketData.Amino, _?: boolean): InterchainAccountPacketData;
	toAmino(_?: boolean): InterchainAccountPacketData.Amino;
	static fromData(packetData: InterchainAccountPacketData.Data, _?: boolean): InterchainAccountPacketData;
	toData(_?: boolean): InterchainAccountPacketData.Data;
	static fromProto(proto: InterchainAccountPacketData.Proto, _?: boolean): InterchainAccountPacketData;
	toProto(_?: boolean): InterchainAccountPacketData.Proto;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(msgAny: Any$1, isClassic?: boolean): InterchainAccountPacketData;
}
declare namespace InterchainAccountPacketData {
	export interface Amino {
		value: {};
	}
	type Base64String = string;
	export interface Data {
		type: Type;
		data: Base64String;
		memo: string;
	}
	export type Proto = InterchainAccountPacketData_pb;
	export {};
}
declare class MsgSendTx extends JSONSerializable<{}, MsgSendTx.Data, MsgSendTx.Proto> {
	owner: AccAddress;
	connectionId: string;
	relativeTimeout: Long$1;
	packetData?: InterchainAccountPacketData | undefined;
	/**
	 * @param owner sender's address
	 * @param connectionId ibc connection id
	 * @param version of the interchain account
	 */
	constructor(owner: AccAddress, connectionId: string, relativeTimeout: Long$1, packetData?: InterchainAccountPacketData | undefined);
	static fromAmino(data: MsgSendTx.Amino, _?: boolean): MsgSendTx;
	toAmino(_?: boolean): MsgSendTx.Amino;
	static fromData(data: MsgSendTx.Data, _?: boolean): MsgSendTx;
	toData(_?: boolean): MsgSendTx.Data;
	static fromProto(proto: MsgSendTx.Proto, _?: boolean): MsgSendTx;
	toProto(_?: boolean): MsgSendTx.Proto;
	packAny(isClassic?: boolean): Any;
	static unpackAny(msgAny: Any, isClassic?: boolean): MsgSendTx;
}
declare namespace MsgSendTx {
	interface Amino {
		value: {};
	}
	interface Data {
		"@type": "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx";
		owner: AccAddress;
		connection_id: string;
		relative_timeout: string;
		packet_data?: InterchainAccountPacketData.Data;
	}
	type Proto = MsgSendTx_pb;
}
export type ICAMsg = MsgRegisterInterchainAccount | MsgSendTx;
declare namespace ICAMsg {
	type Amino = MsgRegisterInterchainAccount.Amino | MsgSendTx.Amino;
	type Data = MsgRegisterInterchainAccount.Data | MsgSendTx.Data;
	type Proto = MsgRegisterInterchainAccount.Proto | MsgSendTx.Proto;
}
export type Msg = BankMsg | DistributionMsg | FeeGrantMsg | GovMsg | GovMsg$1 | MsgAuthMsg | SlashingMsg | StakingMsg | VestingMsg | WasmMsg | IbcTransferMsg | IbcClientMsg | IbcConnectionMsg | IbcChannelMsg | ICAMsg | AllianceMsg | CustomMsg | CrisisMsg | MsgAuctionBid | FeeshareMsg | TokenFactoryMsg;
export declare namespace Msg {
	type Amino = BankMsg.Amino | DistributionMsg.Amino | FeeGrantMsg.Amino | GovMsg.Amino | GovMsg$1.Amino | MsgAuthMsg.Amino | SlashingMsg.Amino | StakingMsg.Amino | VestingMsg.Amino | WasmMsg.Amino | IbcTransferMsg.Amino | AllianceMsg.Amino | CustomMsg.Amino | CrisisMsg.Amino | MsgAuctionBid.Amino | FeeshareMsg.Amino | TokenFactoryMsg.Amino;
	type Data = BankMsg.Data | DistributionMsg.Data | FeeGrantMsg.Data | GovMsg.Data | GovMsg$1.Data | MsgAuthMsg.Data | SlashingMsg.Data | StakingMsg.Data | VestingMsg.Data | WasmMsg.Data | IbcTransferMsg.Data | IbcClientMsg.Data | IbcConnectionMsg.Data | IbcChannelMsg.Data | ICAMsg.Data | AllianceMsg.Data | CustomMsg.Data | CrisisMsg.Data | MsgAuctionBid.Data | FeeshareMsg.Data | TokenFactoryMsg.Data;
	type Proto = BankMsg.Proto | DistributionMsg.Proto | FeeGrantMsg.Proto | GovMsg.Proto | GovMsg$1.Proto | MsgAuthMsg.Proto | SlashingMsg.Proto | StakingMsg.Proto | VestingMsg.Proto | WasmMsg.Proto | IbcTransferMsg.Proto | ICAMsg.Proto | IbcClientMsg.Proto | IbcConnectionMsg.Proto | IbcChannelMsg.Proto | AllianceMsg.Proto | CrisisMsg.Proto | MsgAuctionBid.Proto | FeeshareMsg.Proto | TokenFactoryMsg.Proto;
	function fromAmino(data: Msg.Amino, isClassic?: boolean): Msg;
	function fromData(data: Msg.Data, isClassic?: boolean): Msg;
	function fromProto(proto: Any$1, isClassic?: boolean): Msg;
}
/**
 * A transaction must include a fee, otherwise it will be rejected.
 */
export declare class Fee extends JSONSerializable<Fee.Amino, Fee.Data, Fee.Proto> {
	readonly gas_limit: number;
	payer?: string | undefined;
	granter?: string | undefined;
	/** Fee amount to be paid */
	readonly amount: Coins;
	/**
	 * Creates a new Fee object.
	 * @param gas gas limit
	 * @param amount amount to be paid to validator
	 */
	constructor(gas_limit: number, amount: Coins.Input, payer?: string | undefined, granter?: string | undefined);
	static fromAmino(data: Fee.Amino): Fee;
	toAmino(): Fee.Amino;
	static fromData(data: Fee.Data): Fee;
	toData(): Fee.Data;
	static fromProto(proto: Fee.Proto): Fee;
	toProto(): Fee.Proto;
	/**
	 * Gets the minimum gas prices implied by the fee. Minimum gas prices are `fee amount / gas`.
	 */
	gasPrices(): Coins;
}
export declare namespace Fee {
	interface Amino {
		gas: string;
		amount: Coins.Amino;
	}
	interface Data {
		gas_limit: string;
		payer: string;
		granter: string;
		amount: Coins.Data;
	}
	type Proto = Fee_pb;
}
declare class CompactBitArray {
	extra_bits_stored: number;
	elems: Buffer;
	constructor(extra_bits_stored: number, elems: Buffer);
	static fromBits(bits: number): CompactBitArray;
	count(): number;
	getIndex(i: number): boolean;
	setIndex(i: number, v: boolean): boolean;
	numTrueBitsBefore(index: number): number;
	static fromData(data: CompactBitArray.Data): CompactBitArray;
	toData(): CompactBitArray.Data;
	static fromProto(proto: CompactBitArray.Proto): CompactBitArray;
	toProto(): CompactBitArray.Proto;
}
declare namespace CompactBitArray {
	interface Data {
		extra_bits_stored: number;
		elems: string;
	}
	type Proto = CompactBitArray_pb;
}
export declare class SignatureV2 {
	public_key: PublicKey;
	data: SignatureV2.Descriptor;
	sequence: number;
	constructor(public_key: PublicKey, data: SignatureV2.Descriptor, sequence: number);
	static fromData(data: SignatureV2.Data): SignatureV2;
	toData(): SignatureV2.Data;
	static fromAmino(data: SignatureV2.Amino): SignatureV2;
}
export declare namespace SignatureV2 {
	const SignMode: typeof SignMode_pb;
	type SignMode = SignMode_pb;
	interface Amino {
		signature: string;
		pub_key: PublicKey.Amino;
	}
	interface Data {
		public_key: PublicKey.Data;
		data: Descriptor.Data;
		sequence: string;
	}
	class Descriptor {
		single?: Descriptor.Single;
		multi?: Descriptor.Multi;
		constructor(data: Descriptor.Single | Descriptor.Multi);
		static fromData(data: Descriptor.Data): Descriptor;
		toData(): Descriptor.Data;
		toModeInfoAndSignature(): [
			ModeInfo,
			Uint8Array
		];
	}
	namespace Descriptor {
		interface Data {
			single?: Descriptor.Single.Data;
			multi?: Descriptor.Multi.Data;
		}
		class Single {
			mode: SignMode;
			signature: string;
			constructor(mode: SignMode, signature: string);
			static fromData(data: Single.Data): Single;
			toData(): Single.Data;
		}
		namespace Single {
			interface Data {
				mode: string;
				signature: string;
			}
		}
		class Multi {
			bitarray: CompactBitArray;
			signatures: Descriptor[];
			constructor(bitarray: CompactBitArray, signatures: Descriptor[]);
			static fromData(data: Multi.Data): Multi;
			toData(): Multi.Data;
		}
		namespace Multi {
			interface Data {
				bitarray: CompactBitArray.Data;
				signatures: Descriptor.Data[];
			}
		}
	}
}
export interface AuthParams {
	max_memo_characters: number;
	tx_sig_limit: number;
	tx_size_cost_per_byte: number;
	sig_verify_cost_ed25519: number;
	sig_verify_cost_secp256k1: number;
}
export declare namespace AuthParams {
	interface Data {
		max_memo_characters: string;
		tx_sig_limit: string;
		tx_size_cost_per_byte: string;
		sig_verify_cost_ed25519: string;
		sig_verify_cost_secp256k1: string;
	}
}
export declare class AuthAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Query the modules acccounts information
	 *
	 * @param address address of account to look up
	 */
	moduleAccountsInfo(chainID: string, params?: APIParams): Promise<Array<ModuleAccount>>;
	/**
	 * Query a specific module acccount information
	 *
	 * @param address address of account to look up
	 */
	moduleAccountInfo(chainID: string, moduleName: string, params?: APIParams): Promise<ModuleAccount>;
	/**
	 * Looks up the account information using its Terra account address. If the account has
	 * vesting, it will be one of [LazyGradedVestingAccount, DelayedVestingAccount, PeriodicVestingAccount, ContinuousVestingAccount]
	 *
	 * @param address address of account to look up
	 */
	accountInfo(address: AccAddress, params?: APIParams): Promise<Account>;
	parameters(chainID: string, params?: APIParams): Promise<AuthParams>;
}
export interface SendEnabled {
	denom: string;
	enabled: boolean;
}
export declare namespace SendEnabled {
	interface Data {
		denom: string;
		enabled: boolean;
	}
}
export interface BankParams {
	send_enabled: SendEnabled[];
	default_send_enabled: boolean;
}
export declare namespace BankParams {
	interface Data {
		send_enabled: SendEnabled.Data[];
		default_send_enabled: boolean;
	}
}
export declare class BankAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Query parameters of the bank module,
	 * @param chainID chain id
	 * @returns params of the bank module
	 */
	params(chainID: string, params?: APIParams): Promise<BankParams>;
	/**
	 * Look up the balance of an account by its address.
	 * @param address address of account to look up.
	 */
	balance(address: AccAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[
		Coins,
		Pagination
	]>;
	/**
	 * Lqueries the spenable balance of all coins for a single account.
	 * @param address address of account to look up.
	 */
	spendableBalances(address: AccAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[
		Coins,
		Pagination
	]>;
	/**
	 * Get the total supply of tokens in circulation for all denominations.
	 * @param chainID chain id
	 */
	total(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<[
		Coins,
		Pagination
	]>;
	/**
	 * Get the total supply of tokens in circulation for all denom.
	 * @param chainID chain id
	 * @param denom denom of the coin
	 */
	supplyByDenom(chainID: string, denom: string): Promise<Coin>;
}
export interface DistributionParams {
	/**
	 * Community tax rate.
	 */
	community_tax: Dec;
	/**
	 * Base reward for proposer of block.
	 */
	base_proposer_reward: Dec;
	/**
	 * Bonus reward for proposer of block.
	 */
	bonus_proposer_reward: Dec;
	/**
	 * Whether withdrawals are currently enabled.
	 */
	withdraw_addr_enabled: boolean;
}
export declare namespace DistributionParams {
	interface Data {
		community_tax: string;
		base_proposer_reward: string;
		bonus_proposer_reward: string;
		withdraw_addr_enabled: boolean;
	}
}
/**
 * Holds the resonse of delegator rewards query
 */
export interface Rewards {
	/**
	 * An object that maps validator addresses to corresponding rewards earned with that validator
	 */
	rewards: {
		[validator: string]: Coins;
	};
	/**
	 * Total cumulative rewards across delegations with all validators
	 */
	total: Coins;
}
export declare namespace Rewards {
	interface Data {
		rewards: {
			validator_address: ValAddress;
			reward: Coins.Data;
		}[];
		total: Coins.Data;
	}
}
export declare class DistributionAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Gets a delegator's rewards.
	 * @param delegator delegator's account address
	 */
	rewards(delegator: AccAddress, params?: APIParams): Promise<Rewards>;
	/**
	 * Gets a validator's rewards.
	 * @param validator validator's operator address
	 */
	validatorCommission(validator: ValAddress, params?: APIParams): Promise<Coins>;
	/**
	 * Gets a validator's slashing events.
	 * @param validator validator's operator address
	 */
	validatorSlashingEvents(validator: ValAddress, params?: APIParams): Promise<[
		any[],
		Pagination
	]>;
	/**
	 * Gets the withdraw address of a delegator, the address to which rewards are withdrawn.
	 * @param delegator
	 */
	withdrawAddress(delegator: AccAddress, params?: APIParams): Promise<AccAddress>;
	/**
	 * Gets the current value of the community pool.
	 * @param chainID chain id
	 */
	communityPool(chainID: string, params?: APIParams): Promise<Coins>;
	/**
	 * Gets the current distribution parameters.
	 * @param chainID chain id
	 */
	parameters(chainID: string, params?: APIParams): Promise<DistributionParams>;
}
export declare class FeeGrantAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	allowances(grantee: AccAddress, params?: Partial<PaginationOptions>): Promise<{
		allowances: {
			granter: AccAddress;
			grantee: AccAddress;
			allowance: Allowance;
		}[];
		pagination: Pagination;
	}>;
	allowance(granter: AccAddress, grantee: AccAddress): Promise<Allowance>;
	allowancesByGranter(granter: AccAddress, params?: Partial<PaginationOptions>): Promise<{
		allowances: {
			granter: AccAddress;
			grantee: AccAddress;
			allowance: Allowance;
		}[];
		pagination: Pagination;
	}>;
}
export interface GovParams {
	/**
	 * Current deposit parameters
	 */
	deposit_params: DepositParams$1;
	/**
	 * current voting parameters
	 */
	voting_params: VotingParams$1;
	/**
	 * current tally paramaters
	 */
	tally_params: TallyParams$1;
}
export declare namespace GovParams {
	interface Data {
		deposit_params: DepositParams$1.Data;
		voting_params: VotingParams$1.Data;
		tally_params: TallyParams$1.Data;
	}
}
interface DepositParams$1 {
	/** Minimum deposit to enter voting. */
	min_deposit: Coins;
	/** Amount of time (in seconds) a proposal can take to acquire the necessary deposits to enter voting stage, after being submitted. */
	max_deposit_period: number;
}
declare namespace DepositParams$1 {
	interface Data {
		min_deposit: Coins.Data;
		max_deposit_period: string;
	}
}
interface VotingParams$1 {
	/** Amount of time (in seconds) a proposal can take to get votes once voting has begun. */
	voting_period: number;
}
declare namespace VotingParams$1 {
	interface Data {
		voting_period: string;
	}
}
interface TallyParams$1 {
	/** Ratio of total staked tokens that need to have participated in the vote. */
	quorum: Dec;
	/** Ratio of participating tokens that have voted in favor of the proposal. */
	threshold: Dec;
	/** Ratio of participating votes with `NoWithVeto` (after excluding `Abstain` votes) to veto the proposal. */
	veto_threshold: Dec;
}
declare namespace TallyParams$1 {
	interface Data {
		quorum: string;
		threshold: string;
		veto_threshold: string;
	}
}
export interface Tally {
	yes: Int;
	no: Int;
	abstain: Int;
	no_with_veto: Int;
}
export declare namespace Tally {
	interface Data {
		yes: string;
		no: string;
		abstain: string;
		no_with_veto: string;
	}
}
export declare class LegacyGovAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Gets all proposals.
	 * @param chainID chain id
	 */
	proposals(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<[
		Proposal[],
		Pagination
	]>;
	/**
	 * Get a specific proposal by its ID
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	proposal(proposalId: number, chainID: string, params?: APIParams): Promise<Proposal>;
	/**
	 * Get the proposal's proposer
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	proposer(proposalId: number, chainID: string): Promise<AccAddress>;
	/**
	 * Get the proposal's initial deposit
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	initialDeposit(proposalId: number, chainID: string): Promise<Coins>;
	/**
	 * Get the deposits for a proposal
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	deposits(proposalId: number, chainID: string, _params?: Partial<PaginationOptions & APIParams>): Promise<[
		Deposit[],
		Pagination
	]>;
	searchProposalCreationTx(proposalId: number, chainID: string): Promise<Tx.Data>;
	/**
	 * Get the current votes for a proposal
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	votes(proposalId: number, chainID: string, _params?: Partial<PaginationOptions & APIParams>): Promise<[
		Vote[],
		Pagination
	]>;
	/**
	 * Gets the current tally for a proposal.
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	tally(proposalId: number, chainID: string, params?: APIParams): Promise<Tally>;
	/** Gets the Gov module's deposit parameters */
	depositParameters(chainID: string, params?: APIParams): Promise<DepositParams$1>;
	/** Gets the Gov module's voting parameters */
	votingParameters(chainID: string, params?: APIParams): Promise<VotingParams$1>;
	/** Gets teh Gov module's tally parameters */
	tallyParameters(chainID: string, params?: APIParams): Promise<TallyParams$1>;
	/** Gets the Gov module's current parameters  */
	parameters(chainID: string, params?: APIParams): Promise<GovParams>;
}
export declare class AuthzAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Get the message authorization grants for a specific granter and grantee
	 */
	grants(granter: AccAddress, grantee: AccAddress, msgTypeUrl?: string, params?: APIParams): Promise<[
		AuthorizationGrant[],
		Pagination
	]>;
	/**
	 * get list of `GrantAuthorization`, granted by granter.
	 */
	granter(granter: AccAddress, params?: APIParams): Promise<[
		AuthorizationGrant[],
		Pagination
	]>;
	/**
	 * get list of `GrantAuthorization`, by grantee.
	 */
	grantee(grantee: AccAddress, params?: APIParams): Promise<[
		AuthorizationGrant[],
		Pagination
	]>;
}
export interface SlashingParams {
	/** Number of blocks over which missed blocks are tallied for downtime. */
	signed_blocks_window: number;
	/** If a validator misses more than this number, they will be penalized and jailed for downtime. */
	min_signed_per_window: Dec;
	/** Amount of time in seconds after which a jailed validator can be unjailed. */
	downtime_jail_duration: number;
	/** Ratio of funds slashed for a double-sign infraction. */
	slash_fraction_double_sign: Dec;
	/** Ratio of funds slashed for a downtime infraction. */
	slash_fraction_downtime: Dec;
}
export declare namespace SlashingParams {
	interface Data {
		signed_blocks_window: string;
		min_signed_per_window: string;
		downtime_jail_duration: string;
		slash_fraction_double_sign: string;
		slash_fraction_downtime: string;
	}
}
export interface SigningInfo {
	/** Validator's consensus address. */
	address: ValConsAddress;
	/** Number of blocks over which missed blocks are tallied for downtime. */
	start_height: number;
	/** If a validator misses more than this number, they will be penalized and jailed for downtime. */
	index_offset: number;
	/** If the current validator is jailed, this value represents when they can submit a [[MsgUnjail]] to unjail themselves. */
	jailed_until: Date;
	/** Whether or not the validator is "tombstoned", meaning they are forever barred from joining the validator process. */
	tombstoned: boolean;
	/** Number of blocks the validator has missed for the current signed blocks window. */
	missed_blocks_counter: number;
}
export declare namespace SigningInfo {
	interface Data {
		address: string;
		start_height: string;
		index_offset: string;
		jailed_until: string;
		tombstoned: boolean;
		missed_blocks_counter: string;
	}
}
export declare class SlashingAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Gets all signing info, or just the signing info of a particular validator.
	 *
	 * @param valConsPubKey validator's consensus public key
	 */
	signingInfo(valConsAddress: ValConsAddress, params?: APIParams): Promise<SigningInfo>;
	signingInfos(chainID: string, params?: APIParams): Promise<SigningInfo[]>;
	/**
	 * Gets the current Slashing module's parameters.
	 */
	parameters(chainID: string, params?: APIParams): Promise<SlashingParams>;
}
/**
 * Stores information about the status of a delegation between a delegator and validator, fetched from the blockchain.
 */
export declare class Delegation extends JSONSerializable<Delegation.Amino, Delegation.Data, Delegation.Proto> {
	delegator_address: AccAddress;
	validator_address: ValAddress;
	shares: Dec;
	balance: Coin;
	/**
	 * @param delegator_address 	delegator's account address
	 * @param validator_address 	validator's operator address
	 * @param shares 	delegator's shares
	 * @param balance balance of the delegation
	 */
	constructor(delegator_address: AccAddress, validator_address: ValAddress, shares: Dec, balance: Coin);
	static fromAmino(data: Delegation.Amino): Delegation;
	toAmino(): Delegation.Amino;
	static fromData(data: Delegation.Data): Delegation;
	toData(): Delegation.Data;
	static fromProto(proto: Delegation.Proto): Delegation;
	toProto(): Delegation.Proto;
}
export declare namespace Delegation {
	interface Amino {
		delegation: {
			delegator_address: AccAddress;
			validator_address: ValAddress;
			shares: string;
		};
		balance: Coin.Amino;
	}
	interface Data {
		delegation: {
			delegator_address: AccAddress;
			validator_address: ValAddress;
			shares: string;
		};
		balance: Coin.Data;
	}
	type Proto = DelegationResponse_pb;
}
/**
 * A redelegation is when a delegator decides to stop staking with one validator and
 * transfer their delegation to another validator. Rather than unbonding (which takes
 * some time) and re-staking, the funds can be redelegated immediately if a
 * [[Redelegation.Entry]] can be created.
 *
 * A redelegation, like an unbonding delegation, is implemented through
 * [[Redelegation.Entry]] objects, limited by the `max_entry` parameter in the staking
 * module params. For each pair of source and target validators, you cannot redelegate
 * more times than the amount of entries. Entries are cleared when the redelegation is
 * completed, the same amount of time as unbonding.
 */
export declare class Redelegation extends JSONSerializable<Redelegation.Amino, Redelegation.Data, Redelegation.Proto> {
	delegator_address: AccAddress;
	validator_src_address: ValAddress;
	validator_dst_address: ValAddress;
	entries: Redelegation.Entry[];
	/**
	 *
	 * @param delegator_address delegator's account address
	 * @param validator_src_address source validator's operator address (from)
	 * @param validator_dst_address target validator's operator address (to)
	 * @param entries entries
	 */
	constructor(delegator_address: AccAddress, validator_src_address: ValAddress, validator_dst_address: ValAddress, entries: Redelegation.Entry[]);
	static fromAmino(data: Redelegation.Amino): Redelegation;
	toAmino(): Redelegation.Amino;
	static fromData(data: Redelegation.Data): Redelegation;
	toData(): Redelegation.Data;
	static fromProto(data: Redelegation.Proto): Redelegation;
	toProto(): Redelegation.Proto;
}
export declare namespace Redelegation {
	interface Amino {
		redelegation: {
			delegator_address: AccAddress;
			validator_src_address: ValAddress;
			validator_dst_address: ValAddress;
		};
		entries: Redelegation.Entry.Amino[];
	}
	interface Data {
		redelegation: {
			delegator_address: AccAddress;
			validator_src_address: ValAddress;
			validator_dst_address: ValAddress;
		};
		entries: Redelegation.Entry.Data[];
	}
	type Proto = RedelegationResponse_pb;
	class Entry extends JSONSerializable<Entry.Amino, Entry.Data, Entry.Proto> {
		initial_balance: Int;
		balance: Int;
		shares_dst: Dec;
		creation_height: number;
		completion_time: Date;
		/**
		 *
		 * @param initial_balance balance of delegation prior to initiating redelegation
		 * @param shares_dst
		 * @param creation_height 	height of blockchain when entry was created
		 * @param completion_time time when redelegation entry will be removed
		 */
		constructor(initial_balance: Int, balance: Int, shares_dst: Dec, creation_height: number, completion_time: Date);
		toAmino(): Entry.Amino;
		static fromAmino(data: Entry.Amino): Entry;
		toData(): Entry.Data;
		static fromData(data: Entry.Data): Entry;
		toProto(): Entry.Proto;
		static fromProto(proto: Entry.Proto): Entry;
	}
	namespace Entry {
		interface Amino {
			redelegation_entry: {
				creation_height: number;
				completion_time: string;
				initial_balance: string;
				shares_dst: string;
			};
			balance: string;
		}
		interface Data {
			redelegation_entry: {
				creation_height: number;
				completion_time: string;
				initial_balance: string;
				shares_dst: string;
			};
			balance: string;
		}
		type Proto = RedelegationEntryResponse_pb;
	}
}
export interface StakingParams {
	/** Amount of time, in seconds, for bonded staking tokens to be unbonded. */
	unbonding_time: number;
	/** Max number of validators for the validating set (delegates). */
	max_validators: number;
	/** Maximum entries for unbonding delegations and redelegations. */
	max_entries: number;
	historical_entries: number;
	/** The denomination used as the staking token (probably Luna). */
	bond_denom: Denom;
}
export declare namespace StakingParams {
	interface Data {
		unbonding_time: string;
		max_validators: number;
		max_entries: number;
		historical_entries: number;
		bond_denom: Denom;
	}
}
export interface StakingPool {
	/** amount of tokens are bonded, including those that are currently unbonding */
	bonded_tokens: Coin;
	/** amount of tokens that are not bonded */
	not_bonded_tokens: Coin;
}
export declare namespace StakingPool {
	interface Data {
		bonded_tokens: string;
		not_bonded_tokens: string;
	}
}
export declare class StakingAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Queries all delegations, filtering by delegator, validator, or both.
	 *
	 * At least one of the parameters must be defined.
	 * @param delegator delegator's account address
	 * @param validator validator's operator address
	 */
	delegations(delegator?: AccAddress, validator?: ValAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[
		Delegation[],
		Pagination
	]>;
	/**
	 * Gets the delegation between a delegator and validator, if it exists.
	 * @param delegator delegator's account address
	 * @param validator validator's operator address
	 */
	delegation(delegator: AccAddress, validator: ValAddress): Promise<Delegation>;
	/**
	 * Queries all unbonding delegations, filtering by delegator, validator, or both.
	 *
	 * At least one of the parameters must be defined.
	 * @param delegator delegator's account address
	 * @param validator validator's operator address
	 */
	unbondingDelegations(delegator?: AccAddress, validator?: ValAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[
		UnbondingDelegation[],
		Pagination
	]>;
	/**
	 * Gets the unbonding delegation between a delegator and validator, if it exists.
	 * @param delegator delegator's account address
	 * @param validator validator's operator address
	 */
	unbondingDelegation(delegator?: AccAddress, validator?: ValAddress): Promise<UnbondingDelegation>;
	/**
	 * Queries all redelegations, filterable by delegator, source validator, and target validator.
	 * @param delegator delegator's account address
	 * @param validatorSrc source validator's operator address (from).
	 * @param validatorDst destination validator's operator address (to).
	 */
	redelegations(delegator: AccAddress, validatorSrc?: ValAddress, validatorDst?: ValAddress, _params?: Partial<PaginationOptions & APIParams>): Promise<[
		Redelegation[],
		Pagination
	]>;
	/**
	 * Gets all bonded validators for a delegator given its address.
	 * @param delegator delegator's account address
	 */
	bondedValidators(delegator: AccAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[
		Validator[],
		Pagination
	]>;
	/**
	 * Get all current registered validators, including validators that are not currently in the validating set.
	 * @param chainID chain ID
	 */
	validators(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<[
		Validator[],
		Pagination
	]>;
	/**
	 * Gets the validator information for a specific validator.
	 * @param validator validator's operator address
	 */
	validator(validator: ValAddress, params?: APIParams): Promise<Validator>;
	/**
	 * Gets the current staking pool.
	 * @param chainID chain ID
	 */
	pool(chainID: string, params?: APIParams): Promise<StakingPool>;
	/**
	 * Gets the current Staking module's parameters.
	 * @param chainID chain ID
	 */
	parameters(chainID: string, params?: APIParams): Promise<StakingParams>;
}
export declare class TendermintAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Gets the node's information.
	 * @param chainID chain id
	 */
	nodeInfo(chainID: string, params?: APIParams): Promise<object>;
	/**
	 * Gets whether the node is currently in syncing mode to catch up with blocks.
	 * @param chainID chain id
	 */
	syncing(chainID: string, params?: APIParams): Promise<boolean>;
	/**
	 * Gets the validator (delegates) set at the specific height. If no height is given, the current set is returned.
	 * @param chainID chain id
	 * @param height block height
	 */
	validatorSet(chainID: string, height?: number, params?: APIParams): Promise<[
		DelegateValidator[],
		Pagination
	]>;
	/**
	 * Gets the block information at the specified height. If no height is given, the latest block is returned.
	 * @param chainID chain id
	 * @param height block height.
	 */
	blockInfo(chainID: string, height?: number, params?: APIParams): Promise<BlockInfo>;
}
declare class AbsoluteTxPosition extends JSONSerializable<AbsoluteTxPosition.Amino, AbsoluteTxPosition.Data, AbsoluteTxPosition.Proto> {
	block_height: number;
	tx_index: number;
	/**
	 * @param block_height
	 * @param tx_index
	 */
	constructor(block_height: number, tx_index: number);
	static fromAmino(data: AbsoluteTxPosition.Amino): AbsoluteTxPosition;
	toAmino(): AbsoluteTxPosition.Amino;
	static fromData(data: AbsoluteTxPosition.Data): AbsoluteTxPosition;
	toData(): AbsoluteTxPosition.Data;
	static fromProto(proto: AbsoluteTxPosition.Proto): AbsoluteTxPosition;
	toProto(): AbsoluteTxPosition.Proto;
}
declare namespace AbsoluteTxPosition {
	interface Amino {
		block_height: string;
		tx_index: string;
	}
	interface Data {
		block_height: string;
		tx_index: string;
	}
	type Proto = AbsoluteTxPosition_pb;
}
declare class HistoryEntry extends JSONSerializable<HistoryEntry.Amino, HistoryEntry.Data, HistoryEntry.Proto> {
	operation: ContractCodeHistoryOperationType;
	code_id: number;
	updated: AbsoluteTxPosition | undefined;
	msg: object | string;
	/**
	 * @param operation access type
	 * @param code_id
	 */
	constructor(operation: ContractCodeHistoryOperationType, code_id: number, updated: AbsoluteTxPosition | undefined, msg: object | string);
	static fromAmino(data: HistoryEntry.Amino): HistoryEntry;
	toAmino(): HistoryEntry.Amino;
	static fromData(data: HistoryEntry.Data): HistoryEntry;
	toData(): HistoryEntry.Data;
	static fromProto(proto: HistoryEntry.Proto): HistoryEntry;
	toProto(): HistoryEntry.Proto;
}
declare namespace HistoryEntry {
	interface Amino {
		operation: string;
		code_id: string;
		updated?: AbsoluteTxPosition.Amino;
		msg: object | string;
	}
	interface Data {
		operation: string;
		code_id: string;
		updated?: AbsoluteTxPosition.Data;
		msg: object | string;
	}
	type Proto = HistoryEntry_pb;
}
/**
 *
 */
export declare class AccessTypeParam extends JSONSerializable<AccessTypeParam.Amino, AccessTypeParam.Data, AccessTypeParam.Proto> {
	value: AccessType;
	/**
	 * @param value access type
	 */
	constructor(value: AccessType);
	static fromAmino(data: AccessTypeParam.Amino): AccessTypeParam;
	toAmino(): AccessTypeParam.Amino;
	static fromData(data: AccessTypeParam.Data): AccessTypeParam;
	toData(): AccessTypeParam.Data;
	static fromProto(proto: AccessTypeParam.Proto): AccessTypeParam;
	toProto(): AccessTypeParam.Proto;
}
export declare namespace AccessTypeParam {
	interface Amino {
		value: string;
	}
	interface Data {
		value: string;
	}
	type Proto = AccessTypeParam_pb;
}
export interface CodeInfo {
	code_id: number;
	code_hash: string;
	creator: AccAddress;
	instantiate_config?: AccessConfig;
}
export declare namespace CodeInfo {
	interface DataV1 {
		code_id: string;
		code_hash: string;
		creator: AccAddress;
	}
	interface DataV2 {
		code_id: string;
		data_hash: string;
		creator: AccAddress;
		instantiate_permission?: AccessConfig.Data;
	}
}
export interface ContractInfo {
	code_id: number;
	address?: AccAddress;
	creator: AccAddress;
	admin?: AccAddress;
	init_msg?: any;
	label?: string;
	created?: AbsoluteTxPosition;
	ibc_port_id?: string;
}
export declare namespace ContractInfo {
	interface DataV1 {
		code_id: string;
		address: AccAddress;
		creator: AccAddress;
		admin: AccAddress;
		init_msg: any;
	}
	interface DataV2 {
		code_id: string;
		creator: AccAddress;
		admin: AccAddress;
		label?: string;
		created?: AbsoluteTxPosition.Data;
		ibc_port_id?: string;
	}
}
export interface PinnedCodes {
	code_ids: number[];
}
export declare namespace PinnedCodes {
	interface Data {
		code_ids: string[];
	}
}
export interface QueryResult {
	data: string;
}
export declare namespace QueryResult {
	interface Data {
		data: string;
	}
}
export interface Model {
	key: string;
	value: string;
}
export declare namespace Model {
	interface Data {
		key: string;
		value: string;
	}
}
export declare class WasmAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	codeInfo(codeID: number, chainID: string, params?: APIParams): Promise<CodeInfo>;
	contractInfo(contractAddress: AccAddress, params?: APIParams): Promise<ContractInfo>;
	contractQuery<T>(contractAddress: AccAddress, query: object | string, params?: APIParams): Promise<T>;
	params(chainID: string): Promise<{
		params: Params;
	}>;
	pinnedCodes(chainID: string, params?: APIParams): Promise<PinnedCodes>;
	rawContractState(contractAddress: AccAddress, query_data: string, params?: APIParams): Promise<QueryResult>;
	smartContractState(contractAddress: AccAddress, query_data: object | string, params?: APIParams): Promise<QueryResult>;
	contractHistory(contractAddress: AccAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[
		HistoryEntry[],
		Pagination
	]>;
	contractStates(contractAddress: AccAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[
		Model[],
		Pagination
	]>;
	allCodes(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<[
		CodeInfo[],
		Pagination
	]>;
}
export interface MintingParams {
	mint_denom: Denom;
	inflation_rate_change: Dec;
	inflation_max: Dec;
	inflation_min: Dec;
	goal_bonded: Dec;
	blocks_per_year: number;
}
export declare namespace MintingParams {
	interface Data {
		mint_denom: string;
		inflation_rate_change: string;
		inflation_max: string;
		inflation_min: string;
		goal_bonded: string;
		blocks_per_year: string;
	}
}
export declare class MintAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Gets the current minting inflation value
	 */
	inflation(chainID: string, params?: APIParams): Promise<Dec>;
	/**
	 * Gets the current minting annual provisions value
	 */
	annualProvisions(chainID: string, params?: APIParams): Promise<Dec>;
	/**
	 * Gets the current minting module's parameters.
	 */
	parameters(chainID: string, params?: APIParams): Promise<MintingParams>;
}
export interface DenomsFromCreatorResponse {
	denoms: string[];
}
export interface AuthorityMetadataResponse {
	authority_metadata: {
		admin: AccAddress;
	};
}
export interface BeforeSendHookResponse {
	before_send_hook: {
		cosmwasm_address: AccAddress;
	};
}
export declare class TokenFactory extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	params(chainID: string): Promise<QueryParamsResponse>;
	denomsFromCreator(creator: AccAddress): Promise<DenomsFromCreatorResponse>;
	authorityMetadata(chainID: string, denom: string): Promise<AuthorityMetadataResponse>;
	beforeSendHook(chainID: string, denom: string): Promise<BeforeSendHookResponse>;
}
declare class IdentifiedClientState extends JSONSerializable<IdentifiedClientState.Amino, IdentifiedClientState.Data, IdentifiedClientState.Proto> {
	client_id: string;
	client_state: any;
	/**
	 * @param client_id client identifier
	 * @param client_state client state
	 */
	constructor(client_id: string, client_state: any);
	static fromAmino(data: IdentifiedClientState.Amino): IdentifiedClientState;
	toAmino(): IdentifiedClientState.Amino;
	static fromData(data: IdentifiedClientState.Data): IdentifiedClientState;
	toData(): IdentifiedClientState.Data;
	static fromProto(proto: IdentifiedClientState.Proto): IdentifiedClientState;
	toProto(): IdentifiedClientState.Proto;
}
declare namespace IdentifiedClientState {
	interface Amino {
		client_id: string;
		client_state: any;
	}
	interface Data {
		client_id: string;
		client_state: any;
	}
	type Proto = IdentifiedClientState_pb;
}
declare class ConsensusStateWithHeight extends JSONSerializable<ConsensusStateWithHeight.Amino, ConsensusStateWithHeight.Data, ConsensusStateWithHeight.Proto> {
	height: Height | undefined;
	consensus_state: any;
	/**
	 * @param height consensus state height
	 * @param consensus_state consensus state
	 */
	constructor(height: Height | undefined, consensus_state: any);
	static fromAmino(data: ConsensusStateWithHeight.Amino): ConsensusStateWithHeight;
	toAmino(): ConsensusStateWithHeight.Amino;
	static fromData(data: ConsensusStateWithHeight.Data): ConsensusStateWithHeight;
	toData(): ConsensusStateWithHeight.Data;
	static fromProto(proto: ConsensusStateWithHeight.Proto): ConsensusStateWithHeight;
	toProto(): ConsensusStateWithHeight.Proto;
}
declare namespace ConsensusStateWithHeight {
	interface Amino {
		height?: Height.Amino;
		consensus_state: any;
	}
	interface Data {
		height?: Height.Data;
		consensus_state: any;
	}
	type Proto = ConsensusStateWithHeight_pb;
}
declare class ClientConsensusStates extends JSONSerializable<ClientConsensusStates.Amino, ClientConsensusStates.Data, ClientConsensusStates.Proto> {
	client_id: string;
	consensus_states: ConsensusStateWithHeight[];
	/**
	 * @param client_id client identifier
	 * @param consensus_states consensus states and their heights associated with the client
	 */
	constructor(client_id: string, consensus_states: ConsensusStateWithHeight[]);
	static fromAmino(data: ClientConsensusStates.Amino): ClientConsensusStates;
	toAmino(): ClientConsensusStates.Amino;
	static fromData(data: ClientConsensusStates.Data): ClientConsensusStates;
	toData(): ClientConsensusStates.Data;
	static fromProto(proto: ClientConsensusStates.Proto): ClientConsensusStates;
	toProto(): ClientConsensusStates.Proto;
}
declare namespace ClientConsensusStates {
	interface Amino {
		client_id: string;
		consensus_states: ConsensusStateWithHeight.Amino[];
	}
	interface Data {
		client_id: string;
		consensus_states: ConsensusStateWithHeight.Data[];
	}
	type Proto = ClientConsensusStates_pb;
}
declare class Params$3 extends JSONSerializable<Params$3.Amino, Params$3.Data, Params$3.Proto> {
	host_enabled: boolean;
	allowed_messages: string[];
	/**
	 * @param host_enabled host_enabled enables or disables the host submodule.
	 */
	constructor(host_enabled: boolean, allowed_messages: string[]);
	static fromAmino(data: Params$3.Amino): Params$3;
	toAmino(): Params$3.Amino;
	static fromData(data: Params$3.Data): Params$3;
	toData(): Params$3.Data;
	static fromProto(proto: Params$3.Proto): Params$3;
	toProto(): Params$3.Proto;
}
declare namespace Params$3 {
	interface Amino {
		host_enabled: boolean;
		allowed_messages: string[];
	}
	interface Data {
		host_enabled: boolean;
		allowed_messages: string[];
	}
	type Proto = Params_pb;
}
declare class IdentifiedChannel extends JSONSerializable<IdentifiedChannel.Amino, IdentifiedChannel.Data, IdentifiedChannel.Proto> {
	state: State$1;
	ordering: Order;
	counterparty: Counterparty$1 | undefined;
	connection_hops: string[];
	version: string;
	port_id: string;
	channel_id: string;
	/**
	 * @param state current state of the channel end
	 * @param ordering  whether the channel is ordered or unordered
	 * @param counterparty counterparty channel end
	 * @param connection_hops list of connection identifiers, in order, along which packets sent on this channel will travel
	 * @param version opaque channel version, which is agreed upon during the handshake
	 * @param port_id the
	 * @param channel_id
	 */
	constructor(state: State$1, ordering: Order, counterparty: Counterparty$1 | undefined, connection_hops: string[], version: string, port_id: string, channel_id: string);
	static fromAmino(data: IdentifiedChannel.Amino): IdentifiedChannel;
	toAmino(): IdentifiedChannel.Amino;
	static fromData(data: IdentifiedChannel.Data): IdentifiedChannel;
	toData(): IdentifiedChannel.Data;
	static fromProto(proto: IdentifiedChannel.Proto): IdentifiedChannel;
	toProto(): IdentifiedChannel.Proto;
}
declare namespace IdentifiedChannel {
	interface Amino {
		state: State$1;
		ordering: Order;
		counterparty?: Counterparty$1.Amino;
		connection_hops: string[];
		version: string;
		port_id: string;
		channel_id: string;
	}
	interface Data {
		state: State$1;
		ordering: Order;
		counterparty?: Counterparty$1.Data;
		connection_hops: string[];
		version: string;
		port_id: string;
		channel_id: string;
	}
	type Proto = IdentifiedChannel_pb;
}
declare class IdentifiedConnection extends JSONSerializable<IdentifiedConnection.Amino, IdentifiedConnection.Data, IdentifiedConnection.Proto> {
	id: string;
	client_id: string;
	versions: Version$1[];
	state: State;
	counterparty: Counterparty | undefined;
	delay_period: number;
	/**
	 * @param id connection identifier
	 * @param client_id client associated with this connection.
	 * @param versions IBC version which can be utilised to determine encodings or protocols for channels or packets utilising this connection
	 * @param state current state of the connection end
	 * @param counterparty counterparty chain associated with this connection
	 * @param delay_period delay period associated with this connection
	 */
	constructor(id: string, client_id: string, versions: Version$1[], state: State, counterparty: Counterparty | undefined, delay_period: number);
	static fromAmino(data: IdentifiedConnection.Amino): IdentifiedConnection;
	toAmino(): IdentifiedConnection.Amino;
	static fromData(data: IdentifiedConnection.Data): IdentifiedConnection;
	toData(): IdentifiedConnection.Data;
	static fromProto(proto: IdentifiedConnection.Proto): IdentifiedConnection;
	toProto(): IdentifiedConnection.Proto;
}
declare namespace IdentifiedConnection {
	interface Amino {
		id: string;
		client_id: string;
		versions: Version$1.Amino[];
		state: string;
		counterparty?: Counterparty.Amino;
		delay_period: string;
	}
	interface Data {
		id: string;
		client_id: string;
		versions: Version$1.Data[];
		state: string;
		counterparty?: Counterparty.Data;
		delay_period: string;
	}
	type Proto = IdentifiedConnection_pb;
}
export interface IbcClientParams {
	allowed_clients: string[];
}
export declare namespace IbcClientParams {
	interface Data {
		allowed_clients: string[];
	}
}
export interface Status {
	status: string;
}
export declare namespace Status {
	interface Data {
		status: string;
	}
}
export interface Port {
	channel: Channel;
	proof: string;
	proof_height: Height;
}
export declare namespace Port {
	interface Data {
		channel: Channel.Data;
		proof: string;
		proof_height: Height.Data;
	}
}
export declare class IbcAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * query all the IBC channels of a chain
	 * @param chainID chain id
	 */
	channels(chainID: string, params?: APIParams): Promise<{
		channels: IdentifiedChannel[];
		pagination: Pagination;
	}>;
	/**
	 * query the information of the port at given channel
	 * @param channel_id channel identifier
	 * @param port_id port name
	 * @param chainID chain id
	 */
	port(channel_id: string, port_id: string, chainID: string, params?: APIParams): Promise<Port>;
	/**
	 *  query all the IBC connections of a chain
	 *  @param chainID chain id
	 */
	connections(chainID: string, params?: APIParams): Promise<[
		IdentifiedConnection[],
		Pagination
	]>;
	/**
	 * query an IBC connection end
	 * @param connection_id connection unique identifier
	 * @param chainID chain id
	 */
	connection(connection_id: string, chainID: string, params?: APIParams): Promise<IdentifiedConnection>;
	/**
	 * query all the channels associated with a connection end
	 * @param connection_id connection unique identifier
	 * @param chainID chain id
	 */
	connectionChannels(connection_id: string, chainID: string, params?: APIParams): Promise<[
		Channel[],
		Height,
		Pagination
	]>;
	/**
	 * Gets the current transfer application parameters.
	 * @param chainID chain id
	 */
	parameters(chainID: string, params?: APIParams): Promise<IbcClientParams>;
	/**
	 * query all the IBC light clients of a chain
	 * @param chainID chain id
	 */
	clientStates(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<[
		IdentifiedClientState[],
		Pagination
	]>;
	/**
	 * query an IBC light client
	 * @param client_id client state unique identifier
	 * @param chainID chain id
	 * @returns
	 */
	clientState(client_id: string, chainID: string, params?: APIParams): Promise<IdentifiedClientState>;
	/**
	 * query the status of an IBC light client
	 * @param client_id client state unique identifier
	 * @param chainID chain id
	 * @returns
	 */
	clientStatus(client_id: string, chainID: string, params?: APIParams): Promise<Status>;
	/**
	 * query all the consensus state associated with a given client
	 * @param client_id client identifier
	 * @param chainID chain id
	 * @returns
	 */
	consensusStates(client_id: string, chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<[
		ClientConsensusStates,
		Pagination
	]>;
	/**
	 * Gets paramaters for interchain account controller.
	 * NOTE: CURRENTLY LCD DOESN'T SERVE THE ENDPOINT
	/*
	public async interchainAccountControllerParameters(
	  params: APIParams = {}
	): Promise<ControllerParams> {
	  return this.c
		.get<{ params: ControllerParams.Data }>(
		  `/ibc/apps/interchain_accounts/controller/v1/params`,
		  params
		)
		.then(({ params: d }) => ControllerParams.fromData(d));
	}
	*/
	/**
	 * Gets paramaters for interchain account host.
	 * @param chainID chain id
	 */
	interchainAccountHostParameters(chainID: string, params?: APIParams): Promise<Params$3>;
}
export interface IbcTransferParams {
	send_enabled: boolean;
	receive_enabled: boolean;
}
export declare namespace IbcTransferParams {
	interface Data {
		send_enabled: boolean;
		receive_enabled: boolean;
	}
}
export declare class IbcTransferAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/** Gets a denomTrace for the hash */
	denomTrace(hash: string, chainID: string): Promise<DenomTrace>;
	/** Gets a list of denomTraces */
	denomTraces(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<[
		DenomTrace[],
		Pagination
	]>;
	/** Gets a denomination hash information */
	denomHash(trace: string, chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<string>;
	/**
	 * Gets the current transfer application parameters.
	 */
	parameters(chainID: string, params?: APIParams): Promise<IbcTransferParams>;
}
export interface ValidatorWithVotingPower {
	validatorInfo: Validator;
	votingPower: number;
	proposerPriority: number;
}
declare class LCDUtils {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Gets current validators and merges their voting power from the validator set query.
	 * @param chainID chain id
	 */
	validatorsWithVotingPower(chainID: string): Promise<{
		[validatorAddress: string]: ValidatorWithVotingPower;
	}>;
}
/**
 * Abstract key interface that provides transaction signing features and Bech32 address
 * and public key derivation from a public key. This allows you to create custom key
 * solutions, such as for various hardware wallets, by implementing signing and calling
 * `super` with the raw public key from within your subclass. See [[MnemonicKey]] for
 * an implementation of a basic mnemonic-based key.
 */
export declare abstract class Key {
	publicKey?: PublicKey | undefined;
	/**
	 * You will need to supply `sign`, which produces a signature for an arbitrary bytes payload
	 * with the ECDSA curve secp256pk1.
	 *
	 * @param payload the data to be signed
	 */
	abstract sign(payload: Buffer, isEthereum?: boolean): Promise<Buffer>;
	/**
	 * Account address.
	 */
	accAddress(prefix: string): AccAddress;
	/**
	 * Validator address.
	 */
	valAddress(prefix: string): ValAddress;
	/**
	 * Called to derive the relevant account and validator addresses and public keys from
	 * the raw compressed public key in bytes.
	 *
	 * @param publicKey raw compressed bytes public key
	 */
	constructor(publicKey?: PublicKey | undefined);
	/**
	 * Signs a [[StdSignMsg]] with the method supplied by the child class.
	 * only used Amino sign
	 *
	 * @param tx sign-message of the transaction to sign
	 */
	createSignatureAmino(tx: SignDoc, isClassic?: boolean): Promise<SignatureV2>;
	/**
	 * Signs a [[SignDoc]] with the method supplied by the child class.
	 *
	 * @param tx sign-message of the transaction to sign
	 */
	createSignature(signDoc: SignDoc, isClassic?: boolean): Promise<SignatureV2>;
	/**
	 * Signs a [[Tx]] and adds the signature to a generated StdTx that is ready to be broadcasted.
	 * @param tx
	 */
	signTx(tx: Tx, options: SignOptions, isClassic?: boolean): Promise<Tx>;
}
export interface SignOptions {
	accountNumber: number;
	sequence: number;
	signMode: SignMode;
	chainID: string;
}
/**
 * An implementation of the Key interfaces that uses a raw private key.
 */
export declare class RawKey extends Key {
	private isInjective?;
	/**
	 * Raw private key, in bytes.
	 */
	privateKey: Buffer;
	constructor(privateKey: Buffer, isInjective?: boolean | undefined);
	ecdsaSign(payload: Buffer): {
		signature: Uint8Array;
		recid: number;
	};
	etherSign(payload: Buffer): {
		signature: Uint8Array;
	};
	sign(payload: Buffer): Promise<Buffer>;
}
export declare const LUNA_COIN_TYPE = 330;
export interface MnemonicKeyOptions {
	/**
	 * Space-separated list of words for the mnemonic key.
	 */
	mnemonic?: string;
	/**
	 * BIP44 account number.
	 */
	account?: number;
	/**
	 * BIP44 index number
	 */
	index?: number;
	/**
	 * Coin type. Default is LUNA, 330.
	 */
	coinType?: number;
}
/**
 * Implements a BIP39 mnemonic wallet with standard key derivation from a word list. Note
 * that this implementation exposes the private key in memory, so it is not advised to use
 * for applications requiring high security.
 */
export declare class MnemonicKey extends RawKey {
	/**
	 * Space-separated mnemonic phrase.
	 */
	mnemonic: string;
	/**
	 * Creates a new signing key from a mnemonic phrase. If no mnemonic is provided, one
	 * will be automatically generated.
	 *
	 * ### Providing a mnemonic
	 *
	 * ```ts
	 * import { MnemonicKey } from 'terra.js';
	 *
	 * const mk = new MnemonicKey({ mnemonic: '...' });
	 * console.log(mk.accAddress);
	 * ```
	 *
	 * ### Generating a random mnemonic
	 *
	 * ```ts
	 * const mk2 = new MnemonicKey();
	 * console.log(mk2.mnemonic);
	 * ```
	 *
	 * @param options
	 */
	constructor(options?: MnemonicKeyOptions);
}
export declare const DEFAULT_COINTYPE = 330;
export interface SeedKeyOptions {
	/**
	 * Buffer containing the seed.
	 */
	seed: Buffer;
	/**
	 * BIP44 account number.
	 */
	account?: number;
	/**
	 * BIP44 index number
	 */
	index?: number;
	/**
	 * Coin type. Default is LUNA, 330.
	 */
	coinType?: number;
}
/**
 * Implements a BIP39 mnemonic wallet with standard key derivation from a word list. Note
 * that this implementation exposes the private key in memory, so it is not advised to use
 * for applications requiring high security.
 */
export declare class SeedKey extends RawKey {
	/**
	 * Buffer containing the seed.
	 */
	seed: Buffer;
	/**
	 * Creates a new signing key from a seed.
	 *
	 * ### Providing a seed
	 *
	 * ```ts
	 * import { SeedKey } from 'terra.js';
	 *
	 * const sk = new SeedKey({ seed: '...' });
	 * console.log(mk.accAddress);
	 * ```
	 *
	 * ### Generating a seed from a mnemonic
	 *
	 * ```ts
	 * const seed = SeedKey.seedFromMnemonic('...);
	 * console.log(seed);
	 * ```
	 *
	 * @param options
	 */
	constructor(options: SeedKeyOptions);
	static seedFromMnemonic(mnemonic: string): Buffer;
}
export declare class Wallet {
	lcd: LCDClient;
	key: Key;
	constructor(lcd: LCDClient, key: Key);
	accountNumberAndSequence(chainID: string): Promise<{
		account_number: number;
		sequence: number;
	}>;
	accountNumber(chainID: string): Promise<number>;
	sequence(chainID: string): Promise<number>;
	createTx(options: CreateTxOptions & {
		sequence?: number;
	}): Promise<Tx>;
	createAndSignTx(options: CreateTxOptions & {
		sequence?: number;
		accountNumber?: number;
		signMode?: SignModeV1 | SignModeV2;
		chainID: string;
	}): Promise<Tx>;
}
export interface AllianceParams {
	reward_delay_time?: string;
	/** Time interval between consecutive applications of `take_rate` */
	take_rate_claim_interval?: string;
	/**
	 * Last application of `take_rate` on assets
	 * @format date-time from golang
	 */
	last_take_rate_claim_time?: string;
}
export interface AllianceValidator {
	validator_addr?: string;
	total_delegation_shares?: V1Beta1DecCoin[];
	validator_shares?: V1Beta1DecCoin[];
	total_staked?: V1Beta1DecCoin[];
}
export interface V1Beta1DecCoin {
	denom?: string;
	amount?: string;
}
/**
* DelegationResponse is equivalent to Delegation except that it contains a
balance in addition to shares which is more suitable for client responses.
*/
export interface AllianceDelegationResponse {
	delegation: AllianceDelegation;
	/**
	 * Coin defines a token with a denomination and an amount.
	 *
	 * NOTE: The amount field is an Int which implements the custom method
	 * signatures required by gogoproto.
	 */
	balance: {
		denom: string;
		amount: string;
	};
}
export interface AllianceRewardHistory {
	denom: string;
	index: string;
}
export interface AllianceDelegation {
	/** delegator_address is the bech32-encoded address of the delegator. */
	delegator_address: string;
	/** validator_address is the bech32-encoded address of the validator. */
	validator_address: string;
	/** denom of token staked */
	denom: string;
	/** shares define the delegation shares received. */
	shares: string;
	reward_history: AllianceRewardHistory[];
	/** @format uint64 */
	last_reward_claim_height: string;
}
interface RewardWeightRange$1 {
	min: string;
	max: string;
}
export interface AllianceAsset {
	/** Denom of the asset. It could either be a native token or an IBC token */
	denom: string;
	/**
	 * The reward weight specifies the ratio of rewards that will be given to each alliance asset
	 * It does not need to sum to 1. rate = weight / total_weight
	 * Native asset is always assumed to have a weight of 1.s
	 */
	reward_weight: string;
	/**
	 * A positive take rate is used for liquid staking derivatives. It defines an rate that is applied per take_rate_interval
	 * that will be redirected to the distribution rewards pool
	 */
	take_rate: string;
	total_tokens: string;
	total_validator_shares: string;
	/** @format date-time */
	reward_start_time: string;
	reward_change_rate: string;
	reward_change_interval: string;
	/** @format date-time */
	last_reward_change_time: string;
	/** set a bound of weight range to limit how much reward weights can scale. */
	reward_weight_range?: RewardWeightRange$1;
	/** flag to check if an asset has completed the initialization process after the reward delay */
	is_initialized: boolean;
}
declare class AllianceAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Query the alliance module params
	 *
	 * @tags Query
	 * @name params
	 * @summary Query the alliance by denom
	 * @request GET:/terra/alliances/params
	 */
	params(chainId: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		params: AllianceParams;
	}>;
	/**
	 * Query all available alliances with pagination
	 *
	 * @tags Query
	 * @name alliances
	 * @summary Query paginated alliances
	 * @request GET:/terra/alliances
	 */
	alliances(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		pagination: Pagination;
		alliances: AllianceAsset[];
	}>;
	/**
	 * Query the alliance by denom where denom can be either the
	 * ibc prefixed hash or any other native asset alliance denom
	 *
	 * @tags Query
	 * @name alliance
	 * @summary Query the alliance by denom
	 * @request GET:/terra/alliances/{denom}
	 */
	alliance(chainId: string, denom: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		alliance: AllianceAsset;
		pagination: Pagination;
	}>;
	/**
	 * Query all paginated alliance delegations
	 *
	 * @tags Query
	 * @name alliancesDelegations
	 * @summary Query all paginated alliance delegations
	 * @request GET:/terra/alliances/delegations
	 */
	alliancesDelegations(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		delegations: AllianceDelegationResponse[];
		pagination: Pagination;
	}>;
	/**
	 * Query all paginated alliance delegations for a specific delegator address
	 *
	 * @tags Query
	 * @name alliancesDelegation
	 * @summary Query all paginated alliance delegations
	 * @request GET:/terra/alliances/delegations/{delegatorAddr}
	 */
	alliancesDelegation(delegatorAddr: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		delegations: AllianceDelegationResponse[];
		pagination: Pagination;
	}>;
	/**
	 * Query all paginated alliance delegations for a delegator addr and validator_addr
	 *
	 * @tags Query
	 * @name alliancesDelegationByValidator
	 * @summary Query all paginated alliance delegations for a delegator addr and validator_addr
	 * @request GET:/terra/alliances/delegations/{delegator_addr}/{validator_addr}
	 */
	alliancesDelegationByValidator(delegatorAddr: string, validatorAddr: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		delegations: AllianceDelegationResponse[];
		pagination: Pagination;
	}>;
	/**
	 * Query a delegation to an alliance by delegator addr, validator_addr and denom
	 * the denom can be both the ibc prefixed denom or any other alliance denom.
	 *
	 * @tags Query
	 * @name allianceDelegation
	 * @summary Query a delegation to an alliance by delegator addr, validator_addr and denom
	 * @request GET:/terra/alliances/delegations/{delegator_addr}/{validator_addr}/{denom}
	 */
	allianceDelegation(delegatorAddr: string, validatorAddr: string, denom: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		delegation: AllianceDelegationResponse[];
		pagination: Pagination;
	}>;
	/**
	 * Query for rewards by delegator addr, validator_addr and denom
	 * where denom can be either the ibc prefixed hash or any other native asset alliance denom
	 *
	 * @tags Query
	 * @name delegatorRewards
	 * @summary Query for rewards by delegator addr, validator_addr and denom
	 * @request GET:/terra/alliances/params
	 */
	delegatorRewards(delegatorAddr: string, validatorAddr: string, denom: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		rewards: Coins;
	}>;
	/**
	 * Query all validators that has alliance assets delegated to them
	 *
	 * @tags Query
	 * @name allianceValidators
	 * @summary Query all paginated alliance validators
	 * @request GET:/terra/alliances/validators
	 */
	alliancesByValidators(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		validators: AllianceValidator;
		pagination: Pagination;
	}>;
	/**
	 * Query an alliance validator that has alliance assets delegated to it
	 *
	 * @tags Query
	 * @name allianceValidators
	 * @summary Query alliance validator
	 * @request GET:/terra/alliances/validators/{validatorAddr}
	 */
	alliancesByValidator(validatorAddr: string, params?: Partial<PaginationOptions & APIParams>): Promise<AllianceValidator>;
}
declare class PobAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Query POB parameters
	 *
	 * @tags Query POB module params
	 * @name params
	 * @summary
	 * @request GET:/terra/alliances/params
	 */
	params(chainId: string): Promise<{
		params: Params$1;
	}>;
}
declare class FeeshareAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Query the feeshare module params
	 *
	 * @tags Query
	 * @name params
	 * @request GET:/juno/feeshare/v1/params
	 */
	params(chainId: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		params: Params$2;
	}>;
	/**
	 * Query all paginated feeshares. When address is not specified, it returns all feeshares,
	 * otherwise it returns the feeshares of the specific address. The address can be either a
	 * contract address, deployer address or withdrawer address.
	 *
	 * @tags Query
	 * @name feeshares
	 * @summary Query all paginated feeshares.
	 * @request GET:/juno/feeshare/v1/fee_shares or GET:/juno/feeshare/v1/fee_shares/${address}
	 */
	feeshares(chainId: string, address?: AccAddress, params?: Partial<PaginationOptions & APIParams>): Promise<QueryFeeSharesResponse>;
}
interface Tally$1 {
	yes_count: Int;
	no_count: Int;
	abstain_count: Int;
	no_with_veto_count: Int;
}
declare namespace Tally$1 {
	interface Data {
		yes_count: string;
		no_count: string;
		abstain_count: string;
		no_with_veto_count: string;
	}
}
export interface GovV1APIParams {
	params: {
		min_deposit: Coins.Input;
		max_deposit_period: string;
		voting_period: string;
		quorum: Decimal.Value;
		threshold: Decimal.Value;
		veto_threshold: Decimal.Value;
		min_initial_deposit_ratio: Decimal.Value;
		burn_vote_quorum: boolean;
		burn_proposal_deposit_prevote: boolean;
		burn_vote_veto: boolean;
	};
}
export type GovV1AllParams = {
	params: GovV1APIParams;
	deposit_params: DepositParams;
	voting_params: VotingParams;
	tally_params: TallyParams;
};
declare class GovV1API extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/** Gets the Gov module's current parameters  */
	params(chainID: string, params?: APIParams): Promise<GovV1AllParams>;
	/** Gets the Gov module's deposit parameters */
	depositParams(chainID: string, params?: APIParams): Promise<{
		deposit_params: DepositParams;
		params: GovV1APIParams;
	}>;
	/** Gets the Gov module's voting parameters */
	votingParams(chainID: string, params?: APIParams): Promise<{
		voting_params: VotingParams;
		params: GovV1APIParams;
	}>;
	/** Gets teh Gov module's tally parameters */
	tallyParams(chainID: string, params?: APIParams): Promise<{
		tally_params: TallyParams;
		params: GovV1APIParams;
	}>;
	/**
	 * Query all proposals using the gov v1 API.
	 */
	proposals(chainID: string, params?: Partial<PaginationOptions & APIParams>): Promise<{
		proposals: Proposal[];
		pagination: Pagination;
	}>;
	/**
	 * Get the deposits for a proposal
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	deposits(chainID: string, proposalId: number, params?: Partial<PaginationOptions & APIParams>): Promise<{
		deposits: Deposit[];
		pagination: Pagination;
	}>;
	/**
	 * Get current deposits for a proposal by voter address
	 * @param proposalId proposal's ID
	 * @param address address of the depositor
	 */
	depositsByAddress(proposalId: number, address: AccAddress): Promise<{
		deposit: Deposit;
	}>;
	/**
	 * Gets the current tally for a proposal.
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	tally(chainID: string, proposalId: number, params?: APIParams): Promise<Tally$1>;
	/**
	 * Get the current votes for a proposal
	 * @param proposalId proposal's ID
	 * @param chainID chain id
	 */
	votes(chainID: string, proposalId: number, _params?: Partial<PaginationOptions & APIParams>): Promise<{
		votes: Vote[];
		pagination: Pagination;
	}>;
	/**
	 * Get current votes for a proposal by voter address
	 * @param proposalId proposal's ID
	 * @param address address of the depositor
	 */
	votesByAddress(proposalId: number, address: AccAddress): Promise<{
		vote: Vote;
	}>;
}
declare class ICAv1API extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Query interchain account host module params
	 *
	 * @tags Query
	 * @name params
	 * @request GET:/ibc/apps/interchain_accounts/host/v1/params
	 */
	hostParams(chainId: string, params?: Partial<APIParams>): Promise<{
		params: HostParams;
	}>;
	/**
	 * Query interchain account controller module params
	 *
	 * @tags Query
	 * @name params
	 * @request GET:/ibc/apps/interchain_accounts/controller/v1/params
	 */
	controllerParams(chainId: string, params?: Partial<APIParams>): Promise<{
		params: ControllerParams;
	}>;
	/**
	 * Returns the interchain account address for a given owner address on a given connection
	 *
	 * @tags Query
	 * @name params
	 * @request GET:/ibc/apps/interchain_accounts/controller/v1/owners/${ownerAddr}/connections/${connectionId}
	 */
	controllerAccountAddress(ownerAddr: AccAddress, connectionId: string, params?: Partial<APIParams>): Promise<QueryInterchainAccountResponse>;
}
declare class ICQv1API extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Query all parameters associated with the icq module.
	 *
	 * @tags Query
	 * @name params
	 * @summary Query icq module params
	 * @request GET:/async-icq/v1/params
	 */
	params(chainId: string, params?: Partial<APIParams>): Promise<{
		params: Params$4;
	}>;
}
export type AxiosConfig = {
	/**
	 * The API key to be included in requests sent to the LCD.
	 */
	apiToken?: string;
};
export interface LCDClientConfig {
	/**
	 * The Axios configuration to use when making requests to the LCD.
	 */
	axiosConfig?: AxiosConfig;
	/**
	 * The base URL to which LCD requests will be made.
	 */
	lcd: string;
	/**
	 * Chain ID of the blockchain to connect to.
	 */
	chainID: string;
	/**
	 * Coins representing the default gas prices to use for fee estimation.
	 */
	gasPrices: Coins.Input;
	/**
	 * Number presenting the default gas adjustment value to use for fee estimation.
	 */
	gasAdjustment: Numeric.Input;
	/**
	 * Bech32 prefix for wallet and contract addresses.
	 */
	prefix: string;
	isClassic?: boolean;
}
/**
 * An object repesenting a connection to a terrad node running the Lite Client Daemon (LCD)
 * server, a REST server providing access to a node.
 *
 * ### Example
 *
 * ```ts
 * import { LCDClient } from '@terra-money/feather.js';
 *
 * const lcd = LCDClient.fromDefaultConfig('mainnet');
 *
 * const balance = await lcd.bank.balance('terra1...'):
 * console.log(balance);
 * ```
 */
export declare class LCDClient {
	config: Record<string, LCDClientConfig>;
	apiRequesters: Record<string, APIRequester>;
	alliance: AllianceAPI;
	auth: AuthAPI;
	bank: BankAPI;
	distribution: DistributionAPI;
	feeGrant: FeeGrantAPI;
	gov: GovV1API;
	legacyGov: LegacyGovAPI;
	mint: MintAPI;
	authz: AuthzAPI;
	slashing: SlashingAPI;
	staking: StakingAPI;
	tendermint: TendermintAPI;
	tokenfactory: TokenFactory;
	wasm: WasmAPI;
	tx: TxAPI;
	ibc: IbcAPI;
	icaV1: ICAv1API;
	icqV1: ICQv1API;
	ibcTransfer: IbcTransferAPI;
	pob: PobAPI;
	feeshare: FeeshareAPI;
	utils: LCDUtils;
	/**
	 * Creates a new LCD client with the specified configuration.
	 *
	 * @param chains network configuration
	 *
	 */
	constructor(chains: Record<string, LCDClientConfig>);
	static fromDefaultConfig(network: "mainnet" | "testnet"): LCDClient;
	/** Creates a new wallet with the Key. */
	wallet(key: Key): Wallet;
}
export type APIParams = Record<string, string | number | null | undefined>;
export interface Pagination {
	next_key: string | null;
	total: number;
}
declare const OrderBy: typeof OrderBy_pb;
export type OrderBy = OrderBy_pb;
export interface PaginationOptions {
	"pagination.limit": string;
	"pagination.offset": string;
	"pagination.key": string;
	"pagination.count_total": "true" | "false";
	"pagination.reverse": "true" | "false";
	order_by: keyof typeof OrderBy;
}
declare class APIRequester {
	private axios;
	private readonly baseURL;
	constructor(baseURL: string, axiosConfig?: AxiosConfig);
	private computeEndpoint;
	getRaw<T>(endpoint: string, params?: URLSearchParams | APIParams): Promise<T>;
	get<T>(endpoint: string, params?: URLSearchParams | APIParams): Promise<T>;
	postRaw<T>(endpoint: string, data?: any): Promise<T>;
	post<T>(endpoint: string, data?: any): Promise<T>;
}
declare abstract class BaseAPI {
	private req;
	private chains;
	constructor(req: Record<string, APIRequester>, chains: Record<string, LCDClientConfig>);
	getReqFromChainID(chainID: string): APIRequester;
	getReqFromAddress(address: string): APIRequester;
}
export interface Wait {
	height: number;
	txhash: string;
	raw_log: string;
	gas_wanted: number;
	gas_used: number;
	logs: TxLog.Data[];
	timestamp: string;
}
interface Block$1 extends Wait {
	info: string;
	data: string;
}
export interface Sync {
	height: number;
	txhash: string;
	raw_log: string;
}
export interface Async {
	height: number;
	txhash: string;
}
export type TxBroadcastResult<B extends Wait | Block$1 | Sync | Async, C extends TxSuccess | TxError | {}> = B & C;
export interface TxSuccess {
	logs: TxLog[];
}
export interface TxError {
	code: number | string;
	codespace?: string;
}
export type WaitTxBroadcastResult = TxBroadcastResult<Wait, TxSuccess | TxError>;
export type BlockTxBroadcastResult = TxBroadcastResult<Block$1, TxSuccess | TxError>;
export type SyncTxBroadcastResult = TxBroadcastResult<Sync, TxError | {}>;
export type AsyncTxBroadcastResult = TxBroadcastResult<Async, {}>;
export declare function isTxError<T extends TxBroadcastResult<B, C>, B extends Wait | Block$1 | Sync, C extends TxSuccess | TxError | {}>(x: T): x is T & TxBroadcastResult<B, TxError>;
export declare namespace BlockTxBroadcastResult {
	interface Data {
		height: string;
		txhash: string;
		raw_log: string;
		gas_wanted: string;
		gas_used: string;
		logs: TxLog.Data[];
		code: number | string;
		codespace: string;
		info: string;
		data: string;
		timestamp: string;
	}
}
export declare namespace AsyncTxBroadcastResult {
	type Data = Pick<BlockTxBroadcastResult.Data, "height" | "txhash">;
}
export declare namespace SyncTxBroadcastResult {
	type Data = Pick<BlockTxBroadcastResult.Data, "height" | "txhash" | "raw_log" | "code" | "codespace">;
}
export interface SignerOptions {
	address: string;
	sequenceNumber?: number;
	publicKey?: PublicKey | null;
}
export interface SignerData {
	sequenceNumber: number;
	publicKey?: PublicKey | null;
}
export interface CreateTxOptions {
	chainID: string;
	msgs: Msg[];
	fee?: Fee;
	memo?: string;
	gas?: string;
	gasPrices?: Coins.Input;
	gasAdjustment?: Numeric.Input;
	feeDenoms?: string[];
	timeoutHeight?: number;
}
export interface TxResult {
	tx: TxInfo;
}
export declare namespace TxResult {
	interface Data {
		tx: Tx.Data;
		tx_response: TxInfo.Data;
	}
}
export interface TxSearchResult {
	pagination: Pagination;
	txs: TxInfo[];
}
export declare namespace TxSearchResult {
	interface Data {
		txs: Tx.Data[];
		tx_responses: TxInfo.Data[];
		pagination: Pagination;
	}
}
export declare class SimulateResponse {
	gas_info: {
		gas_wanted: number;
		gas_used: number;
	};
	result: {
		data: string;
		log: string;
		events: {
			type: string;
			attributes: {
				key: string;
				value: string;
			}[];
		}[];
	};
	constructor(gas_info: {
		gas_wanted: number;
		gas_used: number;
	}, result: {
		data: string;
		log: string;
		events: {
			type: string;
			attributes: {
				key: string;
				value: string;
			}[];
		}[];
	});
	static fromData(data: SimulateResponse.Data): SimulateResponse;
}
export declare namespace SimulateResponse {
	interface Data {
		gas_info: {
			gas_wanted: string;
			gas_used: string;
		};
		result: {
			data: string;
			log: string;
			events: {
				type: string;
				attributes: {
					key: string;
					value: string;
				}[];
			}[];
		};
	}
}
export interface TxSearchOptions extends PaginationOptions {
	events: {
		key: string;
		value: string;
	}[];
}
export declare class TxAPI extends BaseAPI {
	lcd: LCDClient;
	constructor(lcd: LCDClient);
	/**
	 * Looks up a transaction on the blockchain, addressed by its hash
	 * @param txHash transaction's hash
	 * @param chainID chainID
	 */
	txInfo(txHash: string, chainID: string, params?: APIParams): Promise<TxInfo>;
	/**
	 * Builds a [[StdSignMsg]] that is ready to be signed by a [[Key]]. The appropriate
	 * account number and sequence will be fetched live from the blockchain and added to
	 * the resultant [[StdSignMsg]]. If no fee is provided, fee will be automatically
	 * estimated using the parameters, simulated using a "dummy fee" with sourceAddress's
	 * nonzero denominations in its balance.
	 *
	 * @param sourceAddress account address of signer
	 * @param options TX generation options
	 */
	create(signers: SignerOptions[], options: CreateTxOptions): Promise<Tx>;
	/**
	 * Looks up transactions on the blockchain for the block height. If height is undefined,
	 * gets the transactions for the latest block.
	 * @param chainID chain ID
	 * @param height block height
	 */
	txInfosByHeight(chainID: string, height: number | undefined): Promise<TxInfo[]>;
	/**
	 * Estimates the transaction's fee by simulating it within the node
	 * @param sourceAddress address that will pay the bill
	 * @param msgs standard messages
	 * @param options options for fee estimation
	 */
	estimateFee(signers: SignerData[], options: CreateTxOptions): Promise<Fee>;
	estimateGas(tx: Tx, chainID: string, options?: {
		gasAdjustment?: Numeric.Input;
		signers?: SignerData[];
	}): Promise<number>;
	simulateTx(tx: Tx, chainID: string, options?: {
		gasAdjustment?: Numeric.Input;
		signers?: SignerData[];
	}): Promise<SimulateResponse>;
	computeTax(): Promise<Coins>;
	/**
	 * Encode a transaction to base64-encoded protobuf
	 * @param tx transaction to encode
	 */
	encode(tx: Tx, isClassic?: boolean): string;
	/**
	 * Decode a transaction from base64-encoded protobuf
	 * @param tx transaction string to decode
	 */
	decode(encodedTx: string): Tx;
	/**
	 * Get the transaction's hash
	 * @param tx transaction to hash
	 */
	hash(tx: Tx): Promise<string>;
	private _broadcast;
	/**
	 * Broadcast the transaction using "sync" mode, then wait for its inclusion in a block.
	 *
	 * This method polls txInfo using the txHash to confirm the transaction's execution.
	 *
	 * @param tx      transaction to broadcast
	 * @param chainID chain ID
	 * @param timeout time in milliseconds to wait for transaction to be included in a block. defaults to 30000
	 */
	broadcast(tx: Tx, chainID: string, timeout?: number): Promise<WaitTxBroadcastResult>;
	/**
	 * Broadcast the transaction using the "block" mode, waiting for its inclusion in the blockchain.
	 * @param tx transaction to broadcast
	 * @param chainID chain ID
	 */
	broadcastBlock(tx: Tx, chainID: string): Promise<BlockTxBroadcastResult>;
	/**
	 * NOTE: This is not a synchronous function and is unconventionally named. This function
	 * can be await as it returns a `Promise`.
	 *
	 * Broadcast the transaction using the "sync" mode, returning after CheckTx() is performed.
	 * @param tx transaction to broadcast
	 * @param chainID chain ID
	 */
	broadcastSync(tx: Tx, chainID: string): Promise<SyncTxBroadcastResult>;
	/**
	 * Broadcast the transaction using the "async" mode, returns immediately (transaction might fail).
	 * @param tx transaction to broadcast
	 * @param chainID chain ID
	 */
	broadcastAsync(tx: Tx, chainID: string): Promise<AsyncTxBroadcastResult>;
	/**
	 * Search for transactions based on event attributes.
	 * @param options
	 * @param chainID chain ID
	 */
	search(options: Partial<TxSearchOptions>, chainID: string): Promise<TxSearchResult>;
}
export declare class Tx {
	body: TxBody;
	auth_info: AuthInfo;
	signatures: string[];
	constructor(body: TxBody, auth_info: AuthInfo, signatures: string[]);
	static fromAmino(data: Tx.Amino, isClassic?: boolean): Tx;
	static fromData(data: Tx.Data, isClassic?: boolean): Tx;
	toData(isClassic?: boolean): Tx.Data;
	static unpackAny(anyProto: Any$1, isClassic?: boolean): Tx;
	static fromProto(proto: Tx.Proto, isClassic?: boolean): Tx;
	toProto(isClassic?: boolean): Tx.Proto;
	toBytes(isClassic?: boolean): Uint8Array;
	static fromBuffer(buf: Buffer, isClassic?: boolean): Tx;
	appendEmptySignatures(signers: SignerData[]): void;
	clearSignatures(): void;
	appendSignatures(signatures: SignatureV2[]): void;
}
export declare namespace Tx {
	interface Amino {
		type: "core/StdTx" | "cosmos-sdk/StdTx";
		value: {
			msg: Msg.Amino[];
			fee: Fee.Amino;
			signatures: SignatureV2.Amino[];
			memo: string;
			timeout_height: string;
		};
	}
	interface Data {
		body: TxBody.Data;
		auth_info: AuthInfo.Data;
		signatures: string[];
	}
	type Proto = Tx_pb;
}
export declare class TxBody {
	messages: Msg[];
	memo?: string | undefined;
	timeout_height?: number | undefined;
	constructor(messages: Msg[], memo?: string | undefined, timeout_height?: number | undefined);
	static fromData(data: TxBody.Data, isClassic?: boolean): TxBody;
	toData(isClassic?: boolean): TxBody.Data;
	static fromProto(proto: TxBody.Proto, isClassic?: boolean): TxBody;
	toProto(isClassic?: boolean): TxBody.Proto;
	toBytes(isClassic?: boolean): Uint8Array;
}
export declare namespace TxBody {
	interface Data {
		messages: Msg.Data[];
		memo: string;
		timeout_height: string;
	}
	type Proto = TxBody_pb;
}
export declare class AuthInfo {
	signer_infos: SignerInfo[];
	fee: Fee;
	constructor(signer_infos: SignerInfo[], fee: Fee);
	static fromData(data: AuthInfo.Data): AuthInfo;
	toData(): AuthInfo.Data;
	static fromProto(proto: AuthInfo.Proto): AuthInfo;
	toProto(): AuthInfo.Proto;
	toBytes(): Uint8Array;
}
export declare namespace AuthInfo {
	interface Data {
		signer_infos: SignerInfo.Data[];
		fee: Fee.Data;
	}
	type Proto = AuthInfo_pb;
}
export declare class SignerInfo {
	public_key: PublicKey;
	sequence: number;
	mode_info: ModeInfo;
	constructor(public_key: PublicKey, sequence: number, mode_info: ModeInfo);
	static fromData(data: SignerInfo.Data): SignerInfo;
	toData(): SignerInfo.Data;
	static fromProto(proto: SignerInfo.Proto): SignerInfo;
	toProto(): SignerInfo.Proto;
}
export declare namespace SignerInfo {
	interface Data {
		public_key: PublicKey.Data | null;
		mode_info: ModeInfo.Data;
		sequence: string;
	}
	type Proto = SignerInfo_pb;
}
export declare class ModeInfo {
	single?: ModeInfo.Single;
	multi?: ModeInfo.Multi;
	constructor(mode_info: ModeInfo.Single | ModeInfo.Multi);
	static fromData(data: ModeInfo.Data): ModeInfo;
	toData(): ModeInfo.Data;
	static fromProto(proto: ModeInfo.Proto): ModeInfo;
	toProto(): ModeInfo.Proto;
}
export declare namespace ModeInfo {
	interface Data {
		single?: Single.Data;
		multi?: Multi.Data;
	}
	type Proto = ModeInfo_pb;
	const SignMode: typeof SignMode_pb;
	type SignMode = SignMode_pb;
	class Single {
		mode: SignMode;
		constructor(mode: SignMode);
		static fromData(data: Single.Data): Single;
		toData(): Single.Data;
		static fromProto(proto: Single.Proto): Single;
		toProto(): Single.Proto;
	}
	namespace Single {
		interface Data {
			mode: string;
		}
		type Proto = ModeInfoSingle_pb;
	}
	class Multi {
		bitarray: CompactBitArray;
		modeInfos: ModeInfo[];
		constructor(bitarray: CompactBitArray, modeInfos: ModeInfo[]);
		static fromData(proto: Multi.Data): Multi;
		toData(): Multi.Data;
		static fromProto(proto: Multi.Proto): Multi;
		toProto(): Multi.Proto;
	}
	namespace Multi {
		interface Data {
			bitarray: CompactBitArray.Data;
			mode_infos: ModeInfo.Data[];
		}
		type Proto = ModeInfoMulti_pb;
	}
}
/**
 * A sign message is a data structure that is used to create a [[StdSignature]] to be later
 * appended to the list of signatures in an [[StdTx]]. Essentially, it contains all the
 * information needed to sign and build a transaction, and can be described as an
 * "unsigned transaction."
 */
export declare class SignDoc extends JSONSerializable<SignDoc.Amino, SignDoc.Data, SignDoc.Proto> {
	chain_id: string;
	account_number: number;
	sequence: number;
	auth_info: AuthInfo;
	tx_body: TxBody;
	/**
	 *
	 * @param chain_id ID of blockchain to submit transaction to
	 * @param account_number account number on blockchain
	 * @param sequence Sequence number (nonce), number of signed previous transactions by
	 *    account included on the blockchain at time of broadcast.
	 * @param fee transaction fee
	 * @param msgs list of messages to include
	 * @param memo optional note
	 * @param timeout_height optional transaction timeout height, does not support amino
	 * @param public_key Signer's public key, only used at direct sign mode
	 */
	constructor(chain_id: string, account_number: number, sequence: number, auth_info: AuthInfo, tx_body: TxBody);
	toAmino(isClassic?: boolean): SignDoc.Amino;
	toData(isClassic?: boolean): SignDoc.Data;
	toProto(isClassic?: boolean): SignDoc.Proto;
	toUnSignedTx(): Tx;
	toBytes(isClassic?: boolean): Uint8Array;
}
export declare namespace SignDoc {
	interface Amino {
		chain_id: string;
		account_number: string;
		sequence: string;
		timeout_height?: string;
		fee: Fee.Amino;
		msgs: Msg.Amino[];
		memo: string;
	}
	interface Data {
		body_bytes: string;
		auth_info_bytes: string;
		chain_id: string;
		account_number: string;
	}
	type Proto = SignDoc_pb;
}
/**
 * A TxInfo data structure is used to capture information from a transaction lookup for
 * a transaction already included in a block
 */
export declare class TxInfo {
	height: number;
	txhash: string;
	raw_log: string;
	logs: TxLog[] | undefined;
	gas_wanted: number;
	gas_used: number;
	tx: Tx;
	timestamp: string;
	code: number;
	info: string;
	events: Event$1[];
	codespace?: string | undefined;
	data?: string | undefined;
	/**
	 *
	 * @param height height of the block in which the transaction was included.
	 * @param txhash transaction's hash.
	 * @param raw_log raw log information, as a string.
	 * @param logs log information
	 * @param gas_wanted gas limited submitted in fee
	 * @param gas_used actual gas consumption
	 * @param tx transaction content
	 * @param timestamp time of inclusion
	 * @param code error code
	 * @param info additional tx information that can be indeterminisitc
	 * @param events events emitted during tx execution including ANTE and POST
	 * @param codespace 0 if succeeded or non-zero error code
	 * @param data proto encoded data to HEX type of the Msg
	 */
	constructor(height: number, txhash: string, raw_log: string, logs: TxLog[] | undefined, gas_wanted: number, gas_used: number, tx: Tx, timestamp: string, code: number, info: string, events: Event$1[], codespace?: string | undefined, data?: string | undefined);
	static fromProto(proto: TxInfo.Proto): TxInfo;
	static fromData(data: TxInfo.Data, isClassic?: boolean): TxInfo;
}
export interface EventKV {
	key: string;
	value: string;
}
interface Event$1 {
	type: string;
	attributes: EventKV[];
}
export interface EventsByType {
	[type: string]: {
		[key: string]: string[];
	};
}
export declare namespace EventsByType {
	function parse(eventAmino: Event$1[]): EventsByType;
}
export declare class TxLog {
	msg_index: number;
	log: string;
	events: Event$1[];
	eventsByType: EventsByType;
	constructor(msg_index: number, log: string, events: Event$1[]);
	static fromData(data: TxLog.Data): TxLog;
	toData(): TxLog.Data;
	static fromProto(proto: TxLog.Proto): TxLog;
	toProto(): TxLog.Proto;
}
export declare namespace TxLog {
	interface Data {
		msg_index: number;
		log: string;
		events: {
			type: string;
			attributes: {
				key: string;
				value: string;
			}[];
		}[];
	}
	type Proto = ABCIMessageLog_pb;
}
export declare namespace TxInfo {
	interface Data {
		height: string;
		txhash: string;
		codespace: string;
		code: number;
		data: string;
		raw_log: string;
		logs: TxLog.Data[];
		info: string;
		gas_wanted: string;
		gas_used: string;
		tx: Tx.Data;
		timestamp: string;
		events: Event$1[];
	}
	type Proto = TxResponse_pb;
}
export interface ValidatorSet {
	validators: DelegateValidator[];
}
export interface DelegateValidator {
	address: ValConsAddress;
	pub_key: ValConsPublicKey.Data;
	proposer_priority: string;
	voting_power: string;
}
/**
 * Stores deposit information for a proposal
 */
export declare class Deposit extends JSONSerializable<Deposit.Amino, Deposit.Data, Deposit.Proto> {
	proposal_id: number;
	depositor: AccAddress;
	amount: Coins;
	/**
	 * @param proposal_id Id of porposal to deposit to
	 * @param depositor depositor's account address
	 * @param amount amount to deposit
	 */
	constructor(proposal_id: number, depositor: AccAddress, amount: Coins.Input);
	static fromAmino(data: Deposit.Amino): Deposit;
	toAmino(): Deposit.Amino;
	static fromData(data: Deposit.Data): Deposit;
	toData(): Deposit.Data;
	static fromProto(data: Deposit.Proto): Deposit;
	toProto(): Deposit.Proto;
}
export declare namespace Deposit {
	interface Amino {
		proposal_id: string;
		depositor: AccAddress;
		amount: Coins.Amino;
	}
	interface Data {
		proposal_id: string;
		depositor: AccAddress;
		amount: Coins.Data;
	}
	type Proto = Deposit_pb;
}
export declare class MultiSignature {
	multisig_pubkey: LegacyAminoMultisigPublicKey;
	bitarray: CompactBitArray;
	signatures: SignatureV2.Descriptor[];
	/**
	 * MultiSignature constructor
	 * public_keys order must be guaranteed
	 */
	constructor(multisig_pubkey: LegacyAminoMultisigPublicKey);
	appendSignature(signature_data: SignatureV2.Descriptor, index: number): void;
	appendSignatureFromPubKey(signature_data: SignatureV2.Descriptor, public_key: SimplePublicKey): void;
	appendSignatureV2s(signatures: SignatureV2[]): void;
	toSignatureDescriptor(): SignatureV2.Descriptor;
}
/**
 * Stores information about an account fetched from the blockchain.
 */
export declare class BaseAccount extends JSONSerializable<BaseAccount.Amino, BaseAccount.Data, BaseAccount.Proto> {
	address: AccAddress;
	public_key: PublicKey | null;
	account_number: number;
	sequence: number;
	/**
	 * Creates a new Account object, holding information about a basic account.
	 *
	 * @param address account address
	 * @param public_key account's public key information
	 * @param account_number account number on the blockchain
	 * @param sequence sequence number, or number of transactions that have been posted
	 */
	constructor(address: AccAddress, public_key: PublicKey | null, account_number: number, sequence: number);
	getAccountNumber(): number;
	getSequenceNumber(): number;
	getPublicKey(): PublicKey | null;
	toAmino(isClassic?: boolean): BaseAccount.Amino;
	static fromAmino(data: BaseAccount.Amino, _?: boolean): BaseAccount;
	static fromData(data: BaseAccount.Data, _?: boolean): BaseAccount;
	toData(_?: boolean): BaseAccount.Data;
	toProto(_?: boolean): BaseAccount.Proto;
	static fromProto(baseAccountProto: BaseAccount.Proto, _?: boolean): BaseAccount;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(pubkeyAny: Any$1, isClassic?: boolean): BaseAccount;
}
export declare namespace BaseAccount {
	interface AminoValue {
		address: AccAddress;
		public_key: PublicKey.Amino | null;
		account_number: string;
		sequence: string;
	}
	interface Amino {
		type: "core/Account" | "cosmos-sdk/BaseAccount";
		value: AminoValue;
	}
	interface DataValue {
		address: AccAddress;
		pub_key: PublicKey.Data | null;
		account_number: string;
		sequence: string;
	}
	interface Data extends DataValue {
		"@type": "/cosmos.auth.v1beta1.BaseAccount";
	}
	type Proto = BaseAccount_pb;
}
/**
 * Holds information about a Account which has vesting information.
 */
export declare class BaseVestingAccount extends JSONSerializable<BaseVestingAccount.Amino, BaseVestingAccount.Data, BaseVestingAccount.Proto> {
	base_account: BaseAccount;
	original_vesting: Coins;
	delegated_free: Coins;
	delegated_vesting: Coins;
	end_time: number;
	/**
	 *
	 * @param base_account account information
	 * @param original_vesting initial vesting amount
	 * @param delegated_free
	 * @param delegated_vesting
	 * @param end_time
	 */
	constructor(base_account: BaseAccount, original_vesting: Coins, delegated_free: Coins, delegated_vesting: Coins, end_time: number);
	getAccountNumber(): number;
	getSequenceNumber(): number;
	getPublicKey(): PublicKey | null;
	toAmino(isClassic?: boolean): BaseVestingAccount.Amino;
	static fromAmino(amino: BaseVestingAccount.Amino, isClassic?: boolean): BaseVestingAccount;
	toData(_?: boolean): BaseVestingAccount.Data;
	static fromData(data: BaseVestingAccount.Data, _?: boolean): BaseVestingAccount;
	toProto(_?: boolean): BaseVestingAccount.Proto;
	static fromProto(proto: BaseVestingAccount.Proto, _?: boolean): BaseVestingAccount;
}
export declare namespace BaseVestingAccount {
	interface AminoValue {
		base_account: BaseAccount.AminoValue;
		original_vesting: Coins.Amino;
		delegated_free: Coins.Amino;
		delegated_vesting: Coins.Amino;
		end_time: string;
	}
	interface Amino {
		type: "core/BaseVestingAccount" | "cosmos-sdk/BaseVestingAccount";
		value: AminoValue;
	}
	interface DataValue {
		base_account: BaseAccount.DataValue;
		original_vesting: Coins.Amino;
		delegated_free: Coins.Amino;
		delegated_vesting: Coins.Amino;
		end_time: string;
	}
	interface Data extends DataValue {
		"@type": "/cosmos.vesting.v1beta1.BaseVestingAccount";
	}
	type Proto = BaseVestingAccount_pb;
}
/**
 * Holds information about a Account which has vesting information.
 */
export declare class LazyGradedVestingAccount extends JSONSerializable<LazyGradedVestingAccount.Amino, LazyGradedVestingAccount.Data, LazyGradedVestingAccount.Proto> {
	base_vesting_account: BaseVestingAccount;
	vesting_schedules: LazyGradedVestingAccount.VestingSchedule[];
	/**
	 *
	 * @param base_vesting_account account information
	 * @param vesting_schedules Entries that make up vesting
	 */
	constructor(base_vesting_account: BaseVestingAccount, vesting_schedules: LazyGradedVestingAccount.VestingSchedule[]);
	getAccountNumber(): number;
	getSequenceNumber(): number;
	getPublicKey(): PublicKey | null;
	toAmino(_?: boolean): LazyGradedVestingAccount.Amino;
	static fromAmino(data: LazyGradedVestingAccount.Amino, _?: boolean): LazyGradedVestingAccount;
	toData(_?: boolean): LazyGradedVestingAccount.Data;
	static fromData(data: LazyGradedVestingAccount.Data, _?: boolean): LazyGradedVestingAccount;
	toProto(_?: boolean): LazyGradedVestingAccount.Proto;
	static fromProto(lazyGradedVestingAccountProto: LazyGradedVestingAccount.Proto, _?: boolean): LazyGradedVestingAccount;
	packAny(isClassic?: boolean): Any;
	static unpackAny(pubkeyAny: Any, isClassic?: boolean): LazyGradedVestingAccount;
}
export declare namespace LazyGradedVestingAccount {
	interface Amino {
		type: "core/LazyGradedVestingAccount";
		value: {
			base_vesting_account: BaseVestingAccount.AminoValue;
			vesting_schedules: VestingSchedule.Amino[];
		};
	}
	interface Data {
		"@type": "/terra.vesting.v1beta1.LazyGradedVestingAccount";
		base_vesting_account: BaseVestingAccount.DataValue;
		vesting_schedules: VestingSchedule.Data[];
	}
	type Proto = LazyGradedVestingAccount_pb;
	class VestingSchedule extends JSONSerializable<VestingSchedule.Amino, VestingSchedule.Data, VestingSchedule.Proto> {
		denom: Denom;
		schedules: VestingSchedule.Entry[];
		constructor(denom: Denom, schedules: VestingSchedule.Entry[]);
		toAmino(): VestingSchedule.Amino;
		static fromAmino(data: VestingSchedule.Amino): VestingSchedule;
		toData(): VestingSchedule.Data;
		static fromData(data: VestingSchedule.Data): VestingSchedule;
		toProto(): VestingSchedule.Proto;
		static fromProto(vestingScheduleProto: VestingSchedule.Proto): VestingSchedule;
	}
	namespace VestingSchedule {
		interface Amino {
			denom: Denom;
			schedules: VestingSchedule.Entry.Amino[];
		}
		interface Data {
			denom: Denom;
			schedules: VestingSchedule.Entry.Data[];
		}
		type Proto = VestingSchedule_pb;
		class Entry extends JSONSerializable<Entry.Amino, Entry.Data, Entry.Proto> {
			start_time: number;
			end_time: number;
			ratio: Dec;
			/**
			 *
			 * @param start_time Starting time (block height)
			 * @param end_time Ending time (block height)
			 * @param ratio Ratio (percentage of vested funds that should be released)
			 */
			constructor(start_time: number, end_time: number, ratio: Dec);
			static fromAmino(data: Entry.Amino): Entry;
			toAmino(): Entry.Amino;
			static fromData(data: Entry.Data): Entry;
			toData(): Entry.Data;
			static fromProto(entryProto: Entry.Proto): Entry;
			toProto(): Entry.Proto;
		}
		namespace Entry {
			interface Amino {
				start_time: string;
				end_time: string;
				ratio: string;
			}
			interface Data {
				start_time: string;
				end_time: string;
				ratio: string;
			}
			type Proto = Schedule_pb;
		}
	}
}
/**
 * ContinuousVestingAccount implements the VestingAccount interface. It
 * continuously vests by unlocking coins linearly with respect to time.
 */
export declare class ContinuousVestingAccount extends JSONSerializable<ContinuousVestingAccount.Amino, ContinuousVestingAccount.Data, ContinuousVestingAccount.Proto> {
	base_vesting_account: BaseVestingAccount;
	start_time: number;
	/**
	 *
	 * @param base_vesting_account account information
	 * @param start_time vesting start time
	 */
	constructor(base_vesting_account: BaseVestingAccount, start_time: number);
	getAccountNumber(): number;
	getSequenceNumber(): number;
	getPublicKey(): PublicKey | null;
	toAmino(isClassic?: boolean): ContinuousVestingAccount.Amino;
	static fromAmino(data: ContinuousVestingAccount.Amino, isClassic?: boolean): ContinuousVestingAccount;
	toData(isClassic?: boolean): ContinuousVestingAccount.Data;
	static fromData(data: ContinuousVestingAccount.Data, isClassic?: boolean): ContinuousVestingAccount;
	toProto(isClassic?: boolean): ContinuousVestingAccount.Proto;
	static fromProto(ContinuousVestingAccountProto: ContinuousVestingAccount.Proto, isClassic?: boolean): ContinuousVestingAccount;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(pubkeyAny: Any$1, isClassic?: boolean): ContinuousVestingAccount;
}
export declare namespace ContinuousVestingAccount {
	interface Amino {
		type: "cosmos-sdk/ContinuousVestingAccount";
		value: {
			base_vesting_account: BaseVestingAccount.AminoValue;
			start_time: string;
		};
	}
	interface Data {
		"@type": "/cosmos.vesting.v1beta1.ContinuousVestingAccount";
		base_vesting_account: BaseVestingAccount.DataValue;
		start_time: string;
	}
	type Proto = ContinuousVestingAccount_pb;
}
/**
 * DelayedVestingAccount implements the VestingAccount interface. It vests all
 * coins after a specific time, but non prior. In other words, it keeps them
 * locked until a specified time.
 */
export declare class DelayedVestingAccount extends JSONSerializable<DelayedVestingAccount.Amino, DelayedVestingAccount.Data, DelayedVestingAccount.Proto> {
	base_vesting_account: BaseVestingAccount;
	/**
	 *
	 * @param base_vesting_account account information
	 */
	constructor(base_vesting_account: BaseVestingAccount);
	getAccountNumber(): number;
	getSequenceNumber(): number;
	getPublicKey(): PublicKey | null;
	toAmino(isClassic?: boolean): DelayedVestingAccount.Amino;
	static fromAmino(data: DelayedVestingAccount.Amino, isClassic?: boolean): DelayedVestingAccount;
	toData(isClassic?: boolean): DelayedVestingAccount.Data;
	static fromData(data: DelayedVestingAccount.Data, isClassic?: boolean): DelayedVestingAccount;
	toProto(isClassic?: boolean): DelayedVestingAccount.Proto;
	static fromProto(DelayedVestingAccountProto: DelayedVestingAccount.Proto, isClassic?: boolean): DelayedVestingAccount;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(pubkeyAny: Any$1, isClassic?: boolean): DelayedVestingAccount;
}
export declare namespace DelayedVestingAccount {
	interface Amino {
		type: "cosmos-sdk/DelayedVestingAccount";
		value: {
			base_vesting_account: BaseVestingAccount.AminoValue;
		};
	}
	interface Data {
		"@type": "/cosmos.vesting.v1beta1.DelayedVestingAccount";
		base_vesting_account: BaseVestingAccount.DataValue;
	}
	type Proto = DelayedVestingAccount_pb;
}
/**
 * PeriodicVestingAccount implements the VestingAccount interface. It
 * periodically vests by unlocking coins during each specified period.
 */
export declare class PeriodicVestingAccount extends JSONSerializable<PeriodicVestingAccount.Amino, PeriodicVestingAccount.Data, PeriodicVestingAccount.Proto> {
	base_vesting_account: BaseVestingAccount;
	start_time: number;
	vesting_periods: PeriodicVestingAccount.Period[];
	/**
	 *
	 * @param base_vesting_account account information
	 * @param start_time vesting start time
	 * @param vesting_periods vesting period entries
	 */
	constructor(base_vesting_account: BaseVestingAccount, start_time: number, vesting_periods: PeriodicVestingAccount.Period[]);
	getAccountNumber(): number;
	getSequenceNumber(): number;
	getPublicKey(): PublicKey | null;
	toAmino(isClassic?: boolean): PeriodicVestingAccount.Amino;
	static fromAmino(data: PeriodicVestingAccount.Amino, isClassic?: boolean): PeriodicVestingAccount;
	toData(isClassic?: boolean): PeriodicVestingAccount.Data;
	static fromData(data: PeriodicVestingAccount.Data, isClassic?: boolean): PeriodicVestingAccount;
	toProto(isClassic?: boolean): PeriodicVestingAccount.Proto;
	static fromProto(proto: PeriodicVestingAccount.Proto, isClassic?: boolean): PeriodicVestingAccount;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(pubkeyAny: Any$1, isClassic?: boolean): PeriodicVestingAccount;
}
export declare namespace PeriodicVestingAccount {
	interface Amino {
		type: "cosmos-sdk/PeriodicVestingAccount";
		value: {
			base_vesting_account: BaseVestingAccount.AminoValue;
			start_time: string;
			vesting_periods: Period.Amino[];
		};
	}
	interface Data {
		"@type": "/cosmos.vesting.v1beta1.PeriodicVestingAccount";
		base_vesting_account: BaseVestingAccount.DataValue;
		start_time: string;
		vesting_periods: Period.Data[];
	}
	type Proto = PeriodicVestingAccount_pb;
	class Period extends JSONSerializable<Period.Amino, Period.Data, Period.Proto> {
		length: number;
		amount: Coins;
		constructor(length: number, amount: Coins);
		toAmino(): Period.Amino;
		static fromAmino(data: Period.Amino): Period;
		toData(): Period.Data;
		static fromData(data: Period.Data): Period;
		toProto(): Period.Proto;
		static fromProto(proto: Period.Proto): Period;
	}
	namespace Period {
		interface Amino {
			length: string;
			amount: Coins.Amino;
		}
		interface Data {
			length: string;
			amount: Coins.Amino;
		}
		type Proto = Period_pb;
	}
}
/**
 * Stores information about an account fetched from the blockchain.
 */
export declare class ModuleAccount extends JSONSerializable<ModuleAccount.Amino, ModuleAccount.Data, ModuleAccount.Proto> {
	name: string;
	permissions: string[];
	baseAccount?: BaseAccount | undefined;
	/**
	 * Creates a new Module accout object, holding information about a module account.
	 *
	 * @param name name of the module e.g 'alliance', 'bank', 'distribution'...
	 * @param permissions permissions of the module to operate 'burner', 'staking'...
	 * @param baseAccount basic account information of the module
	 */
	constructor(name: string, permissions: string[], baseAccount?: BaseAccount | undefined);
	getAccountNumber(): number;
	getSequenceNumber(): number;
	getPublicKey(): PublicKey | null;
	toAmino(_: boolean): ModuleAccount.Amino;
	static fromAmino(data: ModuleAccount.Amino, _?: boolean): ModuleAccount;
	static fromData(data: ModuleAccount.Data, _?: boolean): ModuleAccount;
	toData(_?: boolean): ModuleAccount.Data;
	toProto(_?: boolean): ModuleAccount.Proto;
	static fromProto(moduleAccountProto: ModuleAccount.Proto, _?: boolean): ModuleAccount;
	packAny(isClassic?: boolean): Any$1;
	static unpackAny(pubkeyAny: Any$1, _?: boolean): ModuleAccount;
}
export declare namespace ModuleAccount {
	interface AminoValue {
		name: string;
		base_account?: BaseAccount.Amino;
		permissions: string[];
	}
	interface Amino {
		type: "cosmos-sdk/ModuleAccount";
		value: AminoValue;
	}
	interface DataValue {
		name: string;
		base_account?: BaseAccount.Data;
		permissions: string[];
	}
	interface Data extends DataValue {
		"@type": "/cosmos.auth.v1beta1.ModuleAccount";
	}
	type Proto = ModuleAccount_pb;
}
declare class EthAccount extends JSONSerializable<EthAccount.Amino, EthAccount.Data, {}> {
	address: AccAddress;
	public_key: PublicKey | null;
	account_number: number;
	sequence: number;
	/**
	 * Creates a new Account object, holding information about a basic account.
	 *
	 * @param address account address
	 * @param public_key account's public key information
	 * @param account_number account number on the blockchain
	 * @param sequence sequence number, or number of transactions that have been posted
	 */
	constructor(address: AccAddress, public_key: PublicKey | null, account_number: number, sequence: number);
	getAccountNumber(): number;
	getSequenceNumber(): number;
	getPublicKey(): PublicKey | null;
	toAmino(_?: boolean): EthAccount.Amino;
	static fromAmino(data: EthAccount.Amino, _?: boolean): EthAccount;
	static fromData(data: EthAccount.Data, _?: boolean): EthAccount;
	toData(_?: boolean): EthAccount.Data;
	toProto(_?: boolean): {};
}
declare namespace EthAccount {
	interface AminoValue {
		address: AccAddress;
		public_key: PublicKey.Amino | null;
		account_number: string;
		sequence: string;
	}
	interface Amino {
		type: "injective/EthAccount";
		value: AminoValue;
	}
	interface Data {
		"@type": "/injective.types.v1beta1.EthAccount";
		base_account: {
			address: AccAddress;
			pub_key: PublicKey.Data | null;
			account_number: string;
			sequence: string;
		};
	}
}
export type Account = BaseAccount | BaseVestingAccount | LazyGradedVestingAccount | ContinuousVestingAccount | DelayedVestingAccount | PeriodicVestingAccount | ModuleAccount | EthAccount;
/**
 * Stores information about an account fetched from the blockchain.
 */
export declare namespace Account {
	type Amino = BaseAccount.Amino | BaseVestingAccount.Amino | LazyGradedVestingAccount.Amino | ContinuousVestingAccount.Amino | DelayedVestingAccount.Amino | PeriodicVestingAccount.Amino | ModuleAccount.Amino | EthAccount.Amino;
	type Data = BaseAccount.Data | BaseVestingAccount.Data | LazyGradedVestingAccount.Data | ContinuousVestingAccount.Data | DelayedVestingAccount.Data | PeriodicVestingAccount.Data | ModuleAccount.Data | EthAccount.Data;
	type Proto = Any;
	function fromAmino(amino: Account.Amino, isClassic?: boolean): Account;
	function fromData(data: Account.Data, isClassic?: boolean): Account;
	function fromProto(accountAny: Account.Proto, isClassic?: boolean): Account;
}
/**
 * When a delegator decides to take out their funds from the staking pool, they must
 * unbond their tokens which takes an amount of time specified by `unbonding_time`
 * parameter in the staking module.
 *
 * An unbonding delegation is implemented through creating [[UnbondingDelegation.Entry]]
 * objects, limited by the max_entry parameter in the staking module params. You cannot
 * initiate unbonds more times than the amount of entries permitted. Entries are cleared
 * when their unbonding periods are completed and the funds are returned to the
 * delegator's account balance to be spent freely.
 */
export declare class UnbondingDelegation extends JSONSerializable<UnbondingDelegation.Amino, UnbondingDelegation.Data, UnbondingDelegation.Proto> {
	delegator_address: AccAddress;
	validator_address: ValAddress;
	entries: UnbondingDelegation.Entry[];
	constructor(delegator_address: AccAddress, validator_address: ValAddress, entries: UnbondingDelegation.Entry[]);
	static fromAmino(data: UnbondingDelegation.Amino): UnbondingDelegation;
	toAmino(): UnbondingDelegation.Amino;
	static fromData(data: UnbondingDelegation.Data): UnbondingDelegation;
	toData(): UnbondingDelegation.Data;
	toProto(): UnbondingDelegation.Proto;
	static fromProto(proto: UnbondingDelegation.Proto): UnbondingDelegation;
}
export declare namespace UnbondingDelegation {
	interface Amino {
		delegator_address: AccAddress;
		validator_address: ValAddress;
		entries: UnbondingDelegation.Entry.Amino[];
	}
	interface Data {
		delegator_address: AccAddress;
		validator_address: ValAddress;
		entries: UnbondingDelegation.Entry.Data[];
	}
	type Proto = UnbondingDelegation_pb;
	class Entry extends JSONSerializable<Entry.Amino, Entry.Data, Entry.Proto> {
		initial_balance: Int;
		balance: Int;
		creation_height: number;
		completion_time: Date;
		/**
		 * Note that the size of the undelegation is `initial_balance - balance`
		 * @param initial_balance balance of delegation prior to initiating unbond
		 * @param balance balance of delegation after initiating unbond
		 * @param creation_height height of blockchain when entry was created
		 * @param completion_time time when unbonding will be completed
		 */
		constructor(initial_balance: Int, balance: Int, creation_height: number, completion_time: Date);
		toAmino(): Entry.Amino;
		static fromAmino(data: Entry.Amino): Entry;
		toData(): Entry.Data;
		static fromData(data: Entry.Data): Entry;
		toProto(): Entry.Proto;
		static fromProto(proto: Entry.Proto): Entry;
	}
	namespace Entry {
		interface Amino {
			initial_balance: string;
			balance: string;
			creation_height: string;
			completion_time: string;
		}
		interface Data {
			initial_balance: string;
			balance: string;
			creation_height: string;
			completion_time: string;
		}
		type Proto = UnbondingDelegationEntry_pb;
	}
}
export declare class LocalTerra extends LCDClient {
	wallets: {
		validator: Wallet;
		test1: Wallet;
		test2: Wallet;
		test3: Wallet;
		test4: Wallet;
		test5: Wallet;
		test6: Wallet;
		test7: Wallet;
		test8: Wallet;
		test9: Wallet;
		test10: Wallet;
	};
	constructor();
}
export declare class TendermintQuery {
	private _query;
	getValue(value: number | string | Date): string | number;
	exact(field: string, value: number | string | Date): this;
	compare(field: string, op: `${"<" | ">"}${"" | "="}`, value: number | Date): this;
	exists(field: string): this;
	contains(field: string, value: string): this;
	clone(): TendermintQuery;
	toString(): string;
	static AND(lhs: TendermintQuery, rhs: TendermintQuery): TendermintQuery;
	static OR(lhs: TendermintQuery, rhs: TendermintQuery): TendermintQuery;
}
export type Callback = (data: TendermintSubscriptionResponse) => void;
export interface TendermintSubscriptionResponse {
	type: string;
	value: Record<string, any>;
}
export type TendermintEventType = "NewBlock" | "NewBlockHeader" | "Evidence" | "Tx" | "ValidatorSetUpdates" | "CompleteProposal" | "Lock" | "NewRound" | "NewRoundStep" | "Polka" | "Relock" | "Relock" | "TimeoutPropose" | "TimeoutWait" | "Unlock" | "ValidBlock" | "Vote";
/**
 * An object repesenting a connection to a Terra node's WebSocket RPC endpoint.
 * This allows for subscribing to Tendermint events through WebSocket.
 *
 * ### Events
 * - **error** emitted when error raises
 * - **connect** emitted after connection establishment
 * - **reconnect** emitted upon every attempt of reconnection
 * - **destroyed** emitted when socket has been destroyed
 *
 * ### Example
 *
 * ```ts
 * import { TendermintQuery, WebSocketClient } from '@terra-money/terra.js';
 *
 * const wsclient = new WebSocketClient("ws://localhost:26657/websocket");
 * wsclient.start();
 * wsclient.on('connect', () => {
 *   wsclient.subscribe('NewBlock', new TendermintQuery(), (data) => {
 *     console.log(data.value);
 *
 *     // close after receiving one block.
 *     wsclient.destroy();
 *   });
 *
 *   wsclient.subscribe(
 *     'Tx',
 *     new TendermintQuery()
 *       .exact('message.action', 'send')
 *       .contains('message.sender', 'terra1...'),
 *     (data) => {
 *       console.log(data.value);
 *
 *       // close after receiving one send Tx
 *       wsclient.destroy();
 *     },
 *   );
 * });
 * ```
 */
export declare class WebSocketClient extends EventEmitter {
	private URL;
	private reconnectCount;
	private reconnectInterval;
	private _connected;
	private reconnectTimeoutId?;
	private callbacks;
	private shouldAttemptReconnect;
	private socket;
	private _reconnectCount;
	private _nextSubId;
	/**
	 * WebSocketClient constructor
	 * @param URL The WebSocket endpoint URL on the Tendermint RPC server.
	 *            Ex: ws://localhost:26657/websocket
	 * @param reconnectCount 0 for not to attempt reconnect, -1 for infinite, > 0 for number of times to attempt
	 * @param reconnectInterval retry interval in milliseconds
	 */
	constructor(URL: string, reconnectCount?: number, reconnectInterval?: number);
	/**
	 * Destroys class as well as socket
	 */
	destroy(): void;
	start(): void;
	send(data: any): this;
	private onOpen;
	private onMessage;
	private onClose;
	subscribe(event: TendermintEventType, query: TendermintQuery, callback: Callback): this;
	subscribeTx(query: TendermintQuery, callback: Callback): void;
	get isConnected(): boolean;
}
export interface ExtensionOptions extends CreateTxOptions {
	waitForConfirmation?: boolean;
	purgeQueue?: boolean;
	sequence?: number;
	accountNumber?: number;
}
export interface ResponseData {
	name: string;
	payload: object;
}
export type SendDataType = "connect" | "post" | "sign" | "interchain-info" | "get-pubkey";
export interface SendData {
	[key: string]: any;
}
export interface SignBytesOption {
	bytes: Buffer;
	purgeQueue?: boolean;
}
/**
 * Extension class is for communicating between page and extension
 */
export declare class Extension {
	private inpageStream;
	constructor(identifier?: string);
	destroy(): void;
	private generateId;
	/**
	 * Indicates the Station Extension is installed and availble (requires extension v2 (interchain) or later)
	 */
	get isAvailable(): boolean;
	/**
	 * low level function for sending message to extension.
	 * Do not use this function unless you know what you are doing.
	 */
	send(type: SendDataType, data?: SendData): number;
	/**
	 * Listen to events from the Extension.
	 * You will receive an event after calling connect, sign, or post.
	 * payload structures are described on each function in @return section.
	 *
	 * @param name name of event (optional)
	 * @param callback will be called when `name` or any event emits
	 */
	on(name: string, callback: (payload: any) => void): void;
	on(callback: (payload: any) => void): void;
	/**
	 * Listen to an event from the Extension once.
	 * You will receive an event after calling each type of messages.
	 * payload structures are described on each function in @return section.
	 *
	 * @param name name of event (optional)
	 * @param callback will be called when `name` or any event emits
	 */
	once(name: string, callback: (payload: any) => void): void;
	once(callback: (payload: any) => void): void;
	/**
	 * Send a request
	 *
	 * @param {SendDataType} type
	 * @param {SendData} data
	 */
	request(type: SendDataType, data?: SendData): Promise<ResponseData>;
	/**
	 * Request to Station Extension for connecting a wallet
	 *
	 * @return {string}     name      'onConnect'
	 * @return {Record<string, AccAddress>} payload   AccAddresses for each of the supported networks
	 */
	connect(): number;
	/**
	 * Request for Station Extension information
	 *
	 * @return {string}  name               'onInterchainInfo'
	 * @return {object}  payload.networks   Record<string, Object> with the network configuration used by Interchain Extension
	 */
	info(): number;
	/**
	 * Request for Station Extension public key
	 *
	 * @return {string}  name               'onGetPubkey'
	 * @return {object}  payload            Record<string, string> with the public key for each of the supported networks
	 */
	pubkey(): number;
	/**
	 * Request for signing tx
	 *
	 * @return {string}  name               'onSign'
	 * @return {object}  payload
	 * @return {number}  payload.id         identifier
	 * @return {string}  payload.origin     origin address
	 * @return {Msg[]}   payload.msgs       requested msgs
	 * @return {boolean} payload.success
	 * @return {string}  payload.result.public_key Base64 encoded public key
	 * @return {string}  payload.result.signature  Base64 encoded signature
	 * @return {number}  payload.result.recid      Recovery id
	 * @return {StdSignMsg.Data} payload.result.stdSignMsgData
	 */
	sign(options: ExtensionOptions): number;
	/**
	 * Request for signing bytes
	 *
	 * @return {string}  name               'onSign'
	 * @return {object}  payload
	 * @return {number}  payload.id         identifier
	 * @return {string}  payload.origin     origin address
	 * @return {Msg[]}   payload.msgs       requested msgs
	 * @return {boolean} payload.success
	 * @return {string}  payload.result.public_key Base64 encoded public key
	 * @return {string}  payload.result.signature  Base64 encoded signature
	 * @return {number}  payload.result.recid      Recovery id
	 */
	signBytes(options: SignBytesOption): number;
	/**
	 * Request for sign and post to LCD server
	 *
	 * @return {string}  name                   'onPost'
	 * @return {object}  payload
	 * @return {number}  payload.id             identifier
	 * @return {string}  payload.origin         origin address
	 * @return {Msg[]}   payload.msgs           requested msgs
	 * @return {boolean} payload.success
	 * @return {number|undefined} payload.result.code
	 *                                          error code. undefined with successful tx
	 * @return {string}  payload.result.raw_log raw log
	 * @return {string}  payload.result.txhash  transaction hash
	 */
	post(options: ExtensionOptions): number;
}
/**
 * Calculates the transaction hash from Amino-encoded string.
 * @param data Amino-encoded string (base64)
 */
export declare function hashToHex(data: string): string;
/**
 * Calculates the transaction hash from Amino-encoded string.
 * @param data raw bytes
 */
export declare function sha256(data: Uint8Array): Uint8Array;
export declare function ripemd160(data: Uint8Array): Uint8Array;
export declare function getCodeId(txResult: WaitTxBroadcastResult | BlockTxBroadcastResult | TxInfo, msgIndex?: number): string;
export declare function getContractAddress(txResult: WaitTxBroadcastResult | BlockTxBroadcastResult | TxInfo, msgIndex?: number, isClassic?: boolean): string;
export interface ContractEvent {
	contract_address: string;
	[key: string]: string;
}
export declare function getContractEvents(txResult: WaitTxBroadcastResult | BlockTxBroadcastResult | TxInfo, msgIndex?: number, isClassic?: boolean): ContractEvent[];

export {
	AccessType,
	DepositParams$1 as DepositParams,
	Event$1 as Event,
	GovMsg$1 as LegacyGovMsg,
	MsgDelegate$1 as MsgAllianceDelegate,
	MsgDeposit$1 as LegacyMsgDeposit,
	MsgRedelegate as MsgAllianceRedelegate,
	MsgSubmitProposal$1 as LegacyMsgSubmitProposal,
	MsgUndelegate$1 as MsgAllianceUndelegate,
	MsgVote$1 as LegacyMsgVote,
	MsgVoteWeighted$1 as LegacyMsgVoteWeighted,
	Proposal$1 as LegacyProposal,
	SignMode,
	TallyParams$1 as TallyParams,
	Vote$1 as LegacyVote,
	VotingParams$1 as VotingParams,
	WeightedVoteOption$1 as LegacyWeightedVoteOption,
};

export {};
