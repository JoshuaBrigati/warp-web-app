// Generated by dts-bundle-generator v9.3.1

import { Coin, Coins, CreateTxOptions, LCDClient, LCDClientConfig, Msg, TxInfo, Wallet as TerraWallet } from '@terra-money/feather.js';
import Big from 'big.js';
import { Big, BigSource } from 'big.js';

export declare namespace warp_account {
	type Addr = string;
	interface Config {
		creator_addr: Addr;
		owner: Addr;
	}
	type ExecuteMsg = {
		warp_msgs: WarpMsgs;
	};
	type Uint64 = string;
	type WarpMsg = {
		generic: CosmosMsgFor_Empty;
	} | {
		ibc_transfer: IbcTransferMsg;
	} | {
		withdraw_assets: WithdrawAssetsMsg;
	};
	type CosmosMsgFor_Empty = {
		bank: BankMsg;
	} | {
		custom: Empty;
	} | {
		staking: StakingMsg;
	} | {
		distribution: DistributionMsg;
	} | {
		stargate: {
			type_url: string;
			value: Binary;
		};
	} | {
		ibc: IbcMsg;
	} | {
		wasm: WasmMsg;
	} | {
		gov: GovMsg;
	};
	type BankMsg = {
		send: {
			amount: Coin[];
			to_address: string;
		};
	} | {
		burn: {
			amount: Coin[];
		};
	};
	type Uint128 = string;
	type StakingMsg = {
		delegate: {
			amount: Coin;
			validator: string;
		};
	} | {
		undelegate: {
			amount: Coin;
			validator: string;
		};
	} | {
		redelegate: {
			amount: Coin;
			dst_validator: string;
			src_validator: string;
		};
	};
	type DistributionMsg = {
		set_withdraw_address: {
			/**
			 * The `withdraw_address`
			 */
			address: string;
		};
	} | {
		withdraw_delegator_reward: {
			/**
			 * The `validator_address`
			 */
			validator: string;
		};
	};
	type Binary = string;
	type IbcMsg = {
		transfer: {
			/**
			 * packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20
			 */
			amount: Coin;
			/**
			 * exisiting channel to send the tokens over
			 */
			channel_id: string;
			/**
			 * when packet times out, measured on remote chain
			 */
			timeout: IbcTimeout;
			/**
			 * address on the remote chain to receive these tokens
			 */
			to_address: string;
		};
	} | {
		send_packet: {
			channel_id: string;
			data: Binary;
			/**
			 * when packet times out, measured on remote chain
			 */
			timeout: IbcTimeout;
		};
	} | {
		close_channel: {
			channel_id: string;
		};
	};
	type Timestamp = Uint64;
	type WasmMsg = {
		execute: {
			contract_addr: string;
			funds: Coin[];
			/**
			 * msg is the json-encoded ExecuteMsg struct (as raw Binary)
			 */
			msg: Binary;
		};
	} | {
		instantiate: {
			admin?: string | null;
			code_id: number;
			funds: Coin[];
			/**
			 * A human-readbale label for the contract
			 */
			label: string;
			/**
			 * msg is the JSON-encoded InstantiateMsg struct (as raw Binary)
			 */
			msg: Binary;
		};
	} | {
		migrate: {
			contract_addr: string;
			/**
			 * msg is the json-encoded MigrateMsg struct that will be passed to the new code
			 */
			msg: Binary;
			/**
			 * the code_id of the new logic to place in the given contract
			 */
			new_code_id: number;
		};
	} | {
		update_admin: {
			admin: string;
			contract_addr: string;
		};
	} | {
		clear_admin: {
			contract_addr: string;
		};
	};
	type GovMsg = {
		vote: {
			proposal_id: number;
			/**
			 * The vote option.
			 *
			 * This should be called "option" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.
			 */
			vote: VoteOption;
		};
	};
	type VoteOption = "yes" | "no" | "abstain" | "no_with_veto";
	type AssetInfo = {
		native: string;
	} | {
		cw20: Addr;
	} | {
		/**
		 * @minItems 2
		 * @maxItems 2
		 */
		cw721: [
			Addr,
			string
		];
	};
	interface WarpMsgs {
		job_id?: Uint64 | null;
		msgs: WarpMsg[];
	}
	interface Coin {
		amount: Uint128;
		denom: string;
	}
	interface Empty {
	}
	interface IbcTimeout {
		block?: IbcTimeoutBlock | null;
		timestamp?: Timestamp | null;
	}
	interface IbcTimeoutBlock {
		/**
		 * block height after which the packet times out. the height within the given revision
		 */
		height: number;
		/**
		 * the version that the client is currently on (eg. after reseting the chain this could increment 1 as height drops to 0)
		 */
		revision: number;
	}
	interface IbcTransferMsg {
		timeout_block_delta?: number | null;
		timeout_timestamp_seconds_delta?: number | null;
		transfer_msg: TransferMsg;
	}
	interface TransferMsg {
		memo: string;
		receiver: string;
		sender: string;
		source_channel: string;
		source_port: string;
		timeout_block?: TimeoutBlock | null;
		timeout_timestamp?: number | null;
		token?: Coin | null;
	}
	interface TimeoutBlock {
		revision_height?: number | null;
		revision_number?: number | null;
	}
	interface WithdrawAssetsMsg {
		asset_infos: AssetInfo[];
	}
	type CwFund = {
		cw20: Cw20Fund;
	} | {
		cw721: Cw721Fund;
	};
	interface InstantiateMsg {
		cw_funds: CwFund[];
		job_id: Uint64;
		msgs: WarpMsg[];
		native_funds: Coin[];
		owner: string;
	}
	interface Cw20Fund {
		amount: Uint128;
		contract_addr: string;
	}
	interface Cw721Fund {
		contract_addr: string;
		token_id: string;
	}
	type QueryMsg = {
		query_config: QueryConfigMsg;
	};
	interface QueryConfigMsg {
	}
}
export declare namespace warp_account_tracker {
	type Addr = string;
	type AccountType = "funding" | "job";
	interface Account {
		account_addr: Addr;
		account_type: AccountType;
		owner_addr: Addr;
	}
	interface AccountsResponse {
		accounts: Account[];
	}
	interface Config {
		admin: Addr;
		warp_addr: Addr;
	}
	interface ConfigResponse {
		config: Config;
	}
	type ExecuteMsg = {
		take_job_account: TakeJobAccountMsg;
	} | {
		free_job_account: FreeJobAccountMsg;
	} | {
		take_funding_account: TakeFundingAccountMsg;
	} | {
		free_funding_account: FreeFundingAccountMsg;
	} | {
		update_config: UpdateConfigMsg;
	};
	type Uint64 = string;
	interface TakeJobAccountMsg {
		account_addr: string;
		account_owner_addr: string;
		job_id: Uint64;
	}
	interface FreeJobAccountMsg {
		account_addr: string;
		account_owner_addr: string;
		last_job_id: Uint64;
	}
	interface TakeFundingAccountMsg {
		account_addr: string;
		account_owner_addr: string;
		job_id: Uint64;
	}
	interface FreeFundingAccountMsg {
		account_addr: string;
		account_owner_addr: string;
		job_id: Uint64;
	}
	interface UpdateConfigMsg {
		admin?: string | null;
	}
	type AccountStatus = "free" | "taken";
	interface FundingAccountResponse {
		funding_account?: FundingAccount | null;
	}
	interface FundingAccount {
		account_addr: Addr;
		account_status: AccountStatus;
		taken_by_job_ids: Uint64[];
	}
	interface FundingAccountsResponse {
		funding_accounts: FundingAccount[];
		total_count: number;
	}
	interface InstantiateMsg {
		admin: string;
		warp_addr: string;
	}
	interface JobAccountResponse {
		job_account?: JobAccount | null;
	}
	interface JobAccount {
		account_addr: Addr;
		account_status: AccountStatus;
		taken_by_job_id: Uint64;
	}
	interface JobAccountsResponse {
		job_accounts: JobAccount[];
		total_count: number;
	}
	type QueryMsg = {
		query_config: QueryConfigMsg;
	} | {
		query_accounts: QueryAccountsMsg;
	} | {
		query_job_accounts: QueryJobAccountsMsg;
	} | {
		query_job_account: QueryJobAccountMsg;
	} | {
		query_first_free_job_account: QueryFirstFreeJobAccountMsg;
	} | {
		query_funding_accounts: QueryFundingAccountsMsg;
	} | {
		query_funding_account: QueryFundingAccountMsg;
	} | {
		query_first_free_funding_account: QueryFirstFreeFundingAccountMsg;
	};
	interface QueryConfigMsg {
	}
	interface QueryAccountsMsg {
		account_owner_addr: string;
		limit?: number | null;
		start_after?: string | null;
	}
	interface QueryJobAccountsMsg {
		account_owner_addr: string;
		account_status: AccountStatus;
		limit?: number | null;
		start_after?: string | null;
	}
	interface QueryJobAccountMsg {
		account_addr: string;
		account_owner_addr: string;
	}
	interface QueryFirstFreeJobAccountMsg {
		account_owner_addr: string;
	}
	interface QueryFundingAccountsMsg {
		account_owner_addr: string;
		account_status: AccountStatus;
		limit?: number | null;
		start_after?: string | null;
	}
	interface QueryFundingAccountMsg {
		account_addr: string;
		account_owner_addr: string;
	}
	interface QueryFirstFreeFundingAccountMsg {
		account_owner_addr: string;
	}
}
export declare namespace warp_controller {
	type Addr = string;
	type Uint128 = string;
	type Uint64 = string;
	interface Config {
		account_tracker_address: Addr;
		burn_fee_min: Uint128;
		burn_fee_rate: Uint128;
		cancellation_fee_rate: Uint64;
		creation_fee_max: Uint128;
		creation_fee_min: Uint128;
		duration_days_limit: Uint64;
		duration_days_max: Uint64;
		duration_days_min: Uint64;
		fee_collector: Addr;
		fee_denom: string;
		maintenance_fee_max: Uint128;
		maintenance_fee_min: Uint128;
		minimum_reward: Uint128;
		owner: Addr;
		queue_size_left: Uint64;
		queue_size_right: Uint64;
		resolver_address: Addr;
		warp_account_code_id: Uint64;
	}
	interface ConfigResponse {
		config: Config;
	}
	type ExecuteMsg = {
		create_job: CreateJobMsg;
	} | {
		delete_job: DeleteJobMsg;
	} | {
		update_job: UpdateJobMsg;
	} | {
		execute_job: ExecuteJobMsg;
	} | {
		evict_job: EvictJobMsg;
	} | {
		update_config: UpdateConfigMsg;
	} | {
		migrate_accounts: MigrateAccountsMsg;
	} | {
		migrate_pending_jobs: MigrateJobsMsg;
	} | {
		migrate_finished_jobs: MigrateJobsMsg;
	} | {
		create_funding_account: CreateFundingAccountMsg;
	};
	type WarpMsg = {
		generic: CosmosMsgFor_Empty;
	} | {
		ibc_transfer: IbcTransferMsg;
	} | {
		withdraw_assets: WithdrawAssetsMsg;
	};
	type CosmosMsgFor_Empty = {
		bank: BankMsg;
	} | {
		custom: Empty;
	} | {
		staking: StakingMsg;
	} | {
		distribution: DistributionMsg;
	} | {
		stargate: {
			type_url: string;
			value: Binary;
		};
	} | {
		ibc: IbcMsg;
	} | {
		wasm: WasmMsg;
	} | {
		gov: GovMsg;
	};
	type BankMsg = {
		send: {
			amount: Coin[];
			to_address: string;
		};
	} | {
		burn: {
			amount: Coin[];
		};
	};
	type StakingMsg = {
		delegate: {
			amount: Coin;
			validator: string;
		};
	} | {
		undelegate: {
			amount: Coin;
			validator: string;
		};
	} | {
		redelegate: {
			amount: Coin;
			dst_validator: string;
			src_validator: string;
		};
	};
	type DistributionMsg = {
		set_withdraw_address: {
			/**
			 * The `withdraw_address`
			 */
			address: string;
		};
	} | {
		withdraw_delegator_reward: {
			/**
			 * The `validator_address`
			 */
			validator: string;
		};
	};
	type Binary = string;
	type IbcMsg = {
		transfer: {
			/**
			 * packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20
			 */
			amount: Coin;
			/**
			 * exisiting channel to send the tokens over
			 */
			channel_id: string;
			/**
			 * when packet times out, measured on remote chain
			 */
			timeout: IbcTimeout;
			/**
			 * address on the remote chain to receive these tokens
			 */
			to_address: string;
		};
	} | {
		send_packet: {
			channel_id: string;
			data: Binary;
			/**
			 * when packet times out, measured on remote chain
			 */
			timeout: IbcTimeout;
		};
	} | {
		close_channel: {
			channel_id: string;
		};
	};
	type Timestamp = Uint64;
	type WasmMsg = {
		execute: {
			contract_addr: string;
			funds: Coin[];
			/**
			 * msg is the json-encoded ExecuteMsg struct (as raw Binary)
			 */
			msg: Binary;
		};
	} | {
		instantiate: {
			admin?: string | null;
			code_id: number;
			funds: Coin[];
			/**
			 * A human-readbale label for the contract
			 */
			label: string;
			/**
			 * msg is the JSON-encoded InstantiateMsg struct (as raw Binary)
			 */
			msg: Binary;
		};
	} | {
		migrate: {
			contract_addr: string;
			/**
			 * msg is the json-encoded MigrateMsg struct that will be passed to the new code
			 */
			msg: Binary;
			/**
			 * the code_id of the new logic to place in the given contract
			 */
			new_code_id: number;
		};
	} | {
		update_admin: {
			admin: string;
			contract_addr: string;
		};
	} | {
		clear_admin: {
			contract_addr: string;
		};
	};
	type GovMsg = {
		vote: {
			proposal_id: number;
			/**
			 * The vote option.
			 *
			 * This should be called "option" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.
			 */
			vote: VoteOption;
		};
	};
	type VoteOption = "yes" | "no" | "abstain" | "no_with_veto";
	type AssetInfo = {
		native: string;
	} | {
		cw20: Addr;
	} | {
		/**
		 * @minItems 2
		 * @maxItems 2
		 */
		cw721: [
			Addr,
			string
		];
	};
	type CwFund = {
		cw20: Cw20Fund;
	} | {
		cw721: Cw721Fund;
	};
	interface CreateJobMsg {
		account_msgs?: WarpMsg[] | null;
		assets_to_withdraw?: AssetInfo[] | null;
		cw_funds?: CwFund[] | null;
		description: string;
		duration_days: Uint64;
		executions: Execution[];
		funding_account?: Addr | null;
		labels: string[];
		name: string;
		operational_amount: Uint128;
		recurring: boolean;
		reward: Uint128;
		terminate_condition?: string | null;
		vars: string;
	}
	interface Coin {
		amount: Uint128;
		denom: string;
	}
	interface Empty {
	}
	interface IbcTimeout {
		block?: IbcTimeoutBlock | null;
		timestamp?: Timestamp | null;
	}
	interface IbcTimeoutBlock {
		/**
		 * block height after which the packet times out. the height within the given revision
		 */
		height: number;
		/**
		 * the version that the client is currently on (eg. after reseting the chain this could increment 1 as height drops to 0)
		 */
		revision: number;
	}
	interface IbcTransferMsg {
		timeout_block_delta?: number | null;
		timeout_timestamp_seconds_delta?: number | null;
		transfer_msg: TransferMsg;
	}
	interface TransferMsg {
		memo: string;
		receiver: string;
		sender: string;
		source_channel: string;
		source_port: string;
		timeout_block?: TimeoutBlock | null;
		timeout_timestamp?: number | null;
		token?: Coin | null;
	}
	interface TimeoutBlock {
		revision_height?: number | null;
		revision_number?: number | null;
	}
	interface WithdrawAssetsMsg {
		asset_infos: AssetInfo[];
	}
	interface Cw20Fund {
		amount: Uint128;
		contract_addr: string;
	}
	interface Cw721Fund {
		contract_addr: string;
		token_id: string;
	}
	interface Execution {
		condition: string;
		msgs: string;
	}
	interface DeleteJobMsg {
		id: Uint64;
	}
	interface UpdateJobMsg {
		description?: string | null;
		id: Uint64;
		labels?: string[] | null;
		name?: string | null;
	}
	interface ExecuteJobMsg {
		external_inputs?: ExternalInput[] | null;
		id: Uint64;
	}
	interface ExternalInput {
		input: string;
		name: string;
	}
	interface EvictJobMsg {
		id: Uint64;
	}
	interface UpdateConfigMsg {
		burn_fee_min?: Uint128 | null;
		burn_fee_rate?: Uint128 | null;
		cancellation_fee_rate?: Uint64 | null;
		creation_fee_max?: Uint128 | null;
		creation_fee_min?: Uint128 | null;
		duration_days_limit?: Uint64 | null;
		duration_days_max?: Uint64 | null;
		duration_days_min?: Uint64 | null;
		fee_collector?: string | null;
		maintenance_fee_max?: Uint128 | null;
		maintenance_fee_min?: Uint128 | null;
		minimum_reward?: Uint128 | null;
		owner?: string | null;
		queue_size_left?: Uint64 | null;
		queue_size_right?: Uint64 | null;
	}
	interface MigrateAccountsMsg {
		account_owner_addr: string;
		limit: number;
		start_after?: string | null;
		warp_account_code_id: Uint64;
	}
	interface MigrateJobsMsg {
		limit: number;
		start_after?: Uint64 | null;
	}
	interface CreateFundingAccountMsg {
	}
	interface InstantiateMsg {
		account_tracker_code_id: Uint64;
		burn_fee_min: Uint128;
		burn_fee_rate: Uint128;
		cancellation_fee_rate: Uint64;
		creation_fee_max: Uint128;
		creation_fee_min: Uint128;
		duration_days_limit: Uint64;
		duration_days_max: Uint64;
		duration_days_min: Uint64;
		fee_collector?: string | null;
		fee_denom: string;
		maintenance_fee_max: Uint128;
		maintenance_fee_min: Uint128;
		minimum_reward: Uint128;
		owner?: string | null;
		queue_size_left: Uint64;
		queue_size_right: Uint64;
		resolver_address: string;
		warp_account_code_id: Uint64;
	}
	type JobStatus = "Pending" | "Executed" | "Failed" | "Cancelled" | "Evicted";
	interface JobResponse {
		job: Job;
	}
	interface Job {
		account: Addr;
		assets_to_withdraw: AssetInfo[];
		created_at_time: Uint64;
		description: string;
		duration_days: Uint64;
		executions: Execution[];
		funding_account?: Addr | null;
		id: Uint64;
		labels: string[];
		last_update_time: Uint64;
		name: string;
		owner: Addr;
		prev_id?: Uint64 | null;
		recurring: boolean;
		reward: Uint128;
		status: JobStatus;
		terminate_condition?: string | null;
		vars: string;
	}
	interface JobsResponse {
		jobs: Job[];
		total_count: number;
	}
	type QueryMsg = {
		query_job: QueryJobMsg;
	} | {
		query_jobs: QueryJobsMsg;
	} | {
		query_config: QueryConfigMsg;
	} | {
		query_state: QueryStateMsg;
	};
	interface QueryJobMsg {
		id: Uint64;
	}
	interface QueryJobsMsg {
		active?: boolean | null;
		condition_status?: boolean | null;
		ids?: Uint64[] | null;
		job_status?: JobStatus | null;
		limit?: number | null;
		name?: string | null;
		owner?: Addr | null;
		start_after?: JobIndex | null;
	}
	interface JobIndex {
		_0: Uint128;
		_1: Uint64;
	}
	interface QueryConfigMsg {
	}
	interface QueryStateMsg {
	}
	interface State {
		current_job_id: Uint64;
		q: Uint64;
	}
	interface StateResponse {
		state: State;
	}
}
export declare namespace warp_resolver {
	type Condition = {
		and: Condition1[];
	} | {
		or: Condition1[];
	} | {
		not: Condition1;
	} | {
		expr: Expr;
	};
	type Condition1 = {
		and: Condition1[];
	} | {
		or: Condition1[];
	} | {
		not: Condition1;
	} | {
		expr: Expr;
	};
	type Expr = {
		string: GenExprFor_StringValueFor_StringAnd_StringOp;
	} | {
		uint: GenExprFor_NumValueFor_Uint256And_NumExprOpAnd_IntFnOpAnd_NumOp;
	} | {
		int: GenExprFor_NumValueForInt128And_NumExprOpAnd_IntFnOpAnd_NumOp;
	} | {
		decimal: GenExprFor_NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOpAnd_NumOp;
	} | {
		timestamp: TimeExpr;
	} | {
		block_height: BlockExpr;
	} | {
		bool: string;
	};
	type StringValueFor_String = {
		simple: string;
	} | {
		ref: string;
	} | {
		env: StringEnvValue;
	};
	type StringEnvValue = "warp_account_addr";
	type StringOp = "starts_with" | "ends_with" | "contains" | "eq" | "neq";
	type NumValueFor_Uint256And_NumExprOpAnd_IntFnOp = {
		simple: Uint256;
	} | {
		expr: NumExprValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	} | {
		ref: string;
	} | {
		fn: NumFnValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	} | {
		env: NumEnvValue;
	};
	type Uint256 = string;
	type NumExprOp = "add" | "sub" | "div" | "mul" | "mod";
	type IntFnOp = "abs" | "neg";
	type NumEnvValue = "time" | "block_height";
	type NumOp = "eq" | "neq" | "lt" | "gt" | "gte" | "lte";
	type NumValueForInt128And_NumExprOpAnd_IntFnOp = {
		simple: number;
	} | {
		expr: NumExprValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		ref: string;
	} | {
		fn: NumFnValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		env: NumEnvValue;
	};
	type NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp = {
		simple: Decimal256;
	} | {
		expr: NumExprValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	} | {
		ref: string;
	} | {
		fn: NumFnValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	} | {
		env: NumEnvValue;
	};
	type Decimal256 = string;
	type DecimalFnOp = "abs" | "neg" | "floor" | "sqrt" | "ceil";
	type Uint64 = string;
	type TimeOp = "lt" | "gt";
	interface GenExprFor_StringValueFor_StringAnd_StringOp {
		left: StringValueFor_String;
		op: StringOp;
		right: StringValueFor_String;
	}
	interface GenExprFor_NumValueFor_Uint256And_NumExprOpAnd_IntFnOpAnd_NumOp {
		left: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
		op: NumOp;
		right: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	}
	interface NumExprValueFor_Uint256And_NumExprOpAnd_IntFnOp {
		left: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
		op: NumExprOp;
		right: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	}
	interface NumFnValueFor_Uint256And_NumExprOpAnd_IntFnOp {
		op: IntFnOp;
		right: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	}
	interface GenExprFor_NumValueForInt128And_NumExprOpAnd_IntFnOpAnd_NumOp {
		left: NumValueForInt128And_NumExprOpAnd_IntFnOp;
		op: NumOp;
		right: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	}
	interface NumExprValueForInt128And_NumExprOpAnd_IntFnOp {
		left: NumValueForInt128And_NumExprOpAnd_IntFnOp;
		op: NumExprOp;
		right: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	}
	interface NumFnValueForInt128And_NumExprOpAnd_IntFnOp {
		op: IntFnOp;
		right: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	}
	interface GenExprFor_NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOpAnd_NumOp {
		left: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
		op: NumOp;
		right: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	}
	interface NumExprValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp {
		left: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
		op: NumExprOp;
		right: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	}
	interface NumFnValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp {
		op: DecimalFnOp;
		right: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	}
	interface TimeExpr {
		comparator: Uint64;
		op: TimeOp;
	}
	interface BlockExpr {
		comparator: Uint64;
		op: NumOp;
	}
	type CosmosMsgFor_Empty = {
		bank: BankMsg;
	} | {
		custom: Empty;
	} | {
		staking: StakingMsg;
	} | {
		distribution: DistributionMsg;
	} | {
		stargate: {
			type_url: string;
			value: Binary;
		};
	} | {
		ibc: IbcMsg;
	} | {
		wasm: WasmMsg;
	} | {
		gov: GovMsg;
	};
	type BankMsg = {
		send: {
			amount: Coin[];
			to_address: string;
		};
	} | {
		burn: {
			amount: Coin[];
		};
	};
	type Uint128 = string;
	type StakingMsg = {
		delegate: {
			amount: Coin;
			validator: string;
		};
	} | {
		undelegate: {
			amount: Coin;
			validator: string;
		};
	} | {
		redelegate: {
			amount: Coin;
			dst_validator: string;
			src_validator: string;
		};
	};
	type DistributionMsg = {
		set_withdraw_address: {
			/**
			 * The `withdraw_address`
			 */
			address: string;
		};
	} | {
		withdraw_delegator_reward: {
			/**
			 * The `validator_address`
			 */
			validator: string;
		};
	};
	type Binary = string;
	type IbcMsg = {
		transfer: {
			/**
			 * packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20
			 */
			amount: Coin;
			/**
			 * exisiting channel to send the tokens over
			 */
			channel_id: string;
			/**
			 * when packet times out, measured on remote chain
			 */
			timeout: IbcTimeout;
			/**
			 * address on the remote chain to receive these tokens
			 */
			to_address: string;
		};
	} | {
		send_packet: {
			channel_id: string;
			data: Binary;
			/**
			 * when packet times out, measured on remote chain
			 */
			timeout: IbcTimeout;
		};
	} | {
		close_channel: {
			channel_id: string;
		};
	};
	type Timestamp = Uint64;
	type WasmMsg = {
		execute: {
			contract_addr: string;
			funds: Coin[];
			/**
			 * msg is the json-encoded ExecuteMsg struct (as raw Binary)
			 */
			msg: Binary;
		};
	} | {
		instantiate: {
			admin?: string | null;
			code_id: number;
			funds: Coin[];
			/**
			 * A human-readbale label for the contract
			 */
			label: string;
			/**
			 * msg is the JSON-encoded InstantiateMsg struct (as raw Binary)
			 */
			msg: Binary;
		};
	} | {
		migrate: {
			contract_addr: string;
			/**
			 * msg is the json-encoded MigrateMsg struct that will be passed to the new code
			 */
			msg: Binary;
			/**
			 * the code_id of the new logic to place in the given contract
			 */
			new_code_id: number;
		};
	} | {
		update_admin: {
			admin: string;
			contract_addr: string;
		};
	} | {
		clear_admin: {
			contract_addr: string;
		};
	};
	type GovMsg = {
		vote: {
			proposal_id: number;
			/**
			 * The vote option.
			 *
			 * This should be called "option" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.
			 */
			vote: VoteOption;
		};
	};
	type VoteOption = "yes" | "no" | "abstain" | "no_with_veto";
	interface Coin {
		amount: Uint128;
		denom: string;
	}
	interface Empty {
	}
	interface IbcTimeout {
		block?: IbcTimeoutBlock | null;
		timestamp?: Timestamp | null;
	}
	interface IbcTimeoutBlock {
		/**
		 * block height after which the packet times out. the height within the given revision
		 */
		height: number;
		/**
		 * the version that the client is currently on (eg. after reseting the chain this could increment 1 as height drops to 0)
		 */
		revision: number;
	}
	type ExecuteMsg = {
		execute_simulate_query: ExecuteSimulateQueryMsg;
	} | {
		execute_validate_job_creation: ExecuteValidateJobCreationMsg;
	} | {
		execute_hydrate_vars: ExecuteHydrateVarsMsg;
	} | {
		execute_resolve_condition: ExecuteResolveConditionMsg;
	} | {
		execute_apply_var_fn: ExecuteApplyVarFnMsg;
	} | {
		execute_hydrate_msgs: ExecuteHydrateMsgsMsg;
	} | {
		warp_msgs_to_cosmos_msgs: WarpMsgsToCosmosMsgsMsg;
	};
	type QueryRequestFor_String = {
		bank: BankQuery;
	} | {
		custom: string;
	} | {
		staking: StakingQuery;
	} | {
		stargate: {
			/**
			 * this is the expected protobuf message type (not any), binary encoded
			 */
			data: Binary;
			/**
			 * this is the fully qualified service path used for routing, eg. custom/cosmos_sdk.x.bank.v1.Query/QueryBalance
			 */
			path: string;
		};
	} | {
		ibc: IbcQuery;
	} | {
		wasm: WasmQuery;
	};
	type BankQuery = {
		balance: {
			address: string;
			denom: string;
		};
	} | {
		all_balances: {
			address: string;
		};
	};
	type StakingQuery = {
		bonded_denom: {};
	} | {
		all_delegations: {
			delegator: string;
		};
	} | {
		delegation: {
			delegator: string;
			validator: string;
		};
	} | {
		all_validators: {};
	} | {
		validator: {
			/**
			 * The validator's address (e.g. (e.g. cosmosvaloper1...))
			 */
			address: string;
		};
	};
	type IbcQuery = {
		port_id: {};
	} | {
		list_channels: {
			port_id?: string | null;
		};
	} | {
		channel: {
			channel_id: string;
			port_id?: string | null;
		};
	};
	type WasmQuery = {
		smart: {
			contract_addr: string;
			/**
			 * msg is the json-encoded QueryMsg struct
			 */
			msg: Binary;
		};
	} | {
		raw: {
			contract_addr: string;
			/**
			 * Key is the raw key used in the contracts Storage
			 */
			key: Binary;
		};
	} | {
		contract_info: {
			contract_addr: string;
		};
	};
	type JobStatus = "Pending" | "Executed" | "Failed" | "Cancelled" | "Evicted";
	type WarpMsg = {
		generic: CosmosMsgFor_Empty;
	} | {
		ibc_transfer: IbcTransferMsg;
	} | {
		withdraw_assets: WithdrawAssetsMsg;
	};
	type AssetInfo = {
		native: string;
	} | {
		cw20: Addr;
	} | {
		/**
		 * @minItems 2
		 * @maxItems 2
		 */
		cw721: [
			Addr,
			string
		];
	};
	type Addr = string;
	interface ExecuteSimulateQueryMsg {
		query: QueryRequestFor_String;
	}
	interface ExecuteValidateJobCreationMsg {
		executions: Execution[];
		terminate_condition?: string | null;
		vars: string;
	}
	interface Execution {
		condition: string;
		msgs: string;
	}
	interface ExecuteHydrateVarsMsg {
		external_inputs?: ExternalInput[] | null;
		vars: string;
		warp_account_addr?: string | null;
	}
	interface ExternalInput {
		input: string;
		name: string;
	}
	interface ExecuteResolveConditionMsg {
		condition: string;
		vars: string;
		warp_account_addr?: string | null;
	}
	interface ExecuteApplyVarFnMsg {
		status: JobStatus;
		vars: string;
		warp_account_addr?: string | null;
	}
	interface ExecuteHydrateMsgsMsg {
		msgs: string;
		vars: string;
	}
	interface WarpMsgsToCosmosMsgsMsg {
		msgs: WarpMsg[];
		owner: Addr;
	}
	interface IbcTransferMsg {
		timeout_block_delta?: number | null;
		timeout_timestamp_seconds_delta?: number | null;
		transfer_msg: TransferMsg;
	}
	interface TransferMsg {
		memo: string;
		receiver: string;
		sender: string;
		source_channel: string;
		source_port: string;
		timeout_block?: TimeoutBlock | null;
		timeout_timestamp?: number | null;
		token?: Coin | null;
	}
	interface TimeoutBlock {
		revision_height?: number | null;
		revision_number?: number | null;
	}
	interface WithdrawAssetsMsg {
		asset_infos: AssetInfo[];
	}
	interface InstantiateMsg {
	}
	type QueryMsg = {
		simulate_query: SimulateQueryMsg;
	} | {
		query_validate_job_creation: QueryValidateJobCreationMsg;
	} | {
		query_hydrate_vars: QueryHydrateVarsMsg;
	} | {
		query_resolve_condition: QueryResolveConditionMsg;
	} | {
		query_apply_var_fn: QueryApplyVarFnMsg;
	} | {
		query_hydrate_msgs: QueryHydrateMsgsMsg;
	};
	interface SimulateQueryMsg {
		query: QueryRequestFor_String;
	}
	interface QueryValidateJobCreationMsg {
		executions: Execution[];
		terminate_condition?: string | null;
		vars: string;
	}
	interface QueryHydrateVarsMsg {
		external_inputs?: ExternalInput[] | null;
		vars: string;
		warp_account_addr?: string | null;
	}
	interface QueryResolveConditionMsg {
		condition: string;
		vars: string;
		warp_account_addr?: string | null;
	}
	interface QueryApplyVarFnMsg {
		status: JobStatus;
		vars: string;
		warp_account_addr?: string | null;
	}
	interface QueryHydrateMsgsMsg {
		msgs: string;
		vars: string;
	}
	interface SimulateResponse {
		response: string;
	}
	type Variable = {
		static: StaticVariable;
	} | {
		external: ExternalVariable;
	} | {
		query: QueryVariable;
	};
	type FnValue = {
		uint: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	} | {
		int: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		decimal: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	} | {
		timestamp: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		block_height: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		bool: string;
	} | {
		string: StringValueFor_String;
	};
	type VariableKind = "string" | "uint" | "int" | "decimal" | "timestamp" | "bool" | "amount" | "asset" | "json";
	type Method = "get" | "post" | "put" | "patch" | "delete";
	interface StaticVariable {
		encode: boolean;
		init_fn: FnValue;
		kind: VariableKind;
		name: string;
		reinitialize: boolean;
		update_fn?: UpdateFn | null;
		value?: string | null;
	}
	interface UpdateFn {
		on_error?: FnValue | null;
		on_success?: FnValue | null;
	}
	interface ExternalVariable {
		encode: boolean;
		init_fn: ExternalExpr;
		kind: VariableKind;
		name: string;
		reinitialize: boolean;
		update_fn?: UpdateFn | null;
		value?: string | null;
	}
	interface ExternalExpr {
		body?: string | null;
		headers?: {
			[k: string]: string;
		} | null;
		method?: Method | null;
		selector: string;
		url: string;
	}
	interface QueryVariable {
		encode: boolean;
		init_fn: QueryExpr;
		kind: VariableKind;
		name: string;
		reinitialize: boolean;
		update_fn?: UpdateFn | null;
		value?: string | null;
	}
	interface QueryExpr {
		query: QueryRequestFor_String;
		selector: string;
	}
}
export declare namespace warp_templates {
	type Addr = string;
	type Uint128 = string;
	interface Config {
		fee_collector: Addr;
		fee_denom: string;
		owner: Addr;
		template_fee: Uint128;
	}
	interface ConfigResponse {
		config: Config;
	}
	type ExecuteMsg = {
		submit_template: SubmitTemplateMsg;
	} | {
		edit_template: EditTemplateMsg;
	} | {
		delete_template: DeleteTemplateMsg;
	} | {
		update_config: UpdateConfigMsg;
	};
	type Variable = {
		static: StaticVariable;
	} | {
		external: ExternalVariable;
	} | {
		query: QueryVariable;
	};
	type FnValue = {
		uint: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	} | {
		int: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		decimal: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	} | {
		timestamp: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		block_height: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		bool: string;
	} | {
		string: StringValueFor_String;
	};
	type NumValueFor_Uint256And_NumExprOpAnd_IntFnOp = {
		simple: Uint256;
	} | {
		expr: NumExprValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	} | {
		ref: string;
	} | {
		fn: NumFnValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	} | {
		env: NumEnvValue;
	};
	type Uint256 = string;
	type NumExprOp = "add" | "sub" | "div" | "mul" | "mod";
	type IntFnOp = "abs" | "neg";
	type NumEnvValue = "time" | "block_height";
	type NumValueForInt128And_NumExprOpAnd_IntFnOp = {
		simple: number;
	} | {
		expr: NumExprValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		ref: string;
	} | {
		fn: NumFnValueForInt128And_NumExprOpAnd_IntFnOp;
	} | {
		env: NumEnvValue;
	};
	type NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp = {
		simple: Decimal256;
	} | {
		expr: NumExprValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	} | {
		ref: string;
	} | {
		fn: NumFnValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	} | {
		env: NumEnvValue;
	};
	type Decimal256 = string;
	type DecimalFnOp = "abs" | "neg" | "floor" | "sqrt" | "ceil";
	type StringValueFor_String = {
		simple: string;
	} | {
		ref: string;
	} | {
		env: StringEnvValue;
	};
	type StringEnvValue = "warp_account_addr";
	type VariableKind = "string" | "uint" | "int" | "decimal" | "timestamp" | "bool" | "amount" | "asset" | "json";
	type Method = "get" | "post" | "put" | "patch" | "delete";
	type QueryRequestFor_String = {
		bank: BankQuery;
	} | {
		custom: string;
	} | {
		staking: StakingQuery;
	} | {
		stargate: {
			/**
			 * this is the expected protobuf message type (not any), binary encoded
			 */
			data: Binary;
			/**
			 * this is the fully qualified service path used for routing, eg. custom/cosmos_sdk.x.bank.v1.Query/QueryBalance
			 */
			path: string;
		};
	} | {
		ibc: IbcQuery;
	} | {
		wasm: WasmQuery;
	};
	type BankQuery = {
		balance: {
			address: string;
			denom: string;
		};
	} | {
		all_balances: {
			address: string;
		};
	};
	type StakingQuery = {
		bonded_denom: {};
	} | {
		all_delegations: {
			delegator: string;
		};
	} | {
		delegation: {
			delegator: string;
			validator: string;
		};
	} | {
		all_validators: {};
	} | {
		validator: {
			/**
			 * The validator's address (e.g. (e.g. cosmosvaloper1...))
			 */
			address: string;
		};
	};
	type Binary = string;
	type IbcQuery = {
		port_id: {};
	} | {
		list_channels: {
			port_id?: string | null;
		};
	} | {
		channel: {
			channel_id: string;
			port_id?: string | null;
		};
	};
	type WasmQuery = {
		smart: {
			contract_addr: string;
			/**
			 * msg is the json-encoded QueryMsg struct
			 */
			msg: Binary;
		};
	} | {
		raw: {
			contract_addr: string;
			/**
			 * Key is the raw key used in the contracts Storage
			 */
			key: Binary;
		};
	} | {
		contract_info: {
			contract_addr: string;
		};
	};
	type Uint64 = string;
	interface SubmitTemplateMsg {
		executions: Execution[];
		formatted_str: string;
		name: string;
		vars: Variable[];
	}
	interface Execution {
		condition: string;
		msgs: string;
	}
	interface StaticVariable {
		encode: boolean;
		init_fn: FnValue;
		kind: VariableKind;
		name: string;
		reinitialize: boolean;
		update_fn?: UpdateFn | null;
		value?: string | null;
	}
	interface NumExprValueFor_Uint256And_NumExprOpAnd_IntFnOp {
		left: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
		op: NumExprOp;
		right: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	}
	interface NumFnValueFor_Uint256And_NumExprOpAnd_IntFnOp {
		op: IntFnOp;
		right: NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	}
	interface NumExprValueForInt128And_NumExprOpAnd_IntFnOp {
		left: NumValueForInt128And_NumExprOpAnd_IntFnOp;
		op: NumExprOp;
		right: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	}
	interface NumFnValueForInt128And_NumExprOpAnd_IntFnOp {
		op: IntFnOp;
		right: NumValueForInt128And_NumExprOpAnd_IntFnOp;
	}
	interface NumExprValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp {
		left: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
		op: NumExprOp;
		right: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	}
	interface NumFnValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp {
		op: DecimalFnOp;
		right: NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	}
	interface UpdateFn {
		on_error?: FnValue | null;
		on_success?: FnValue | null;
	}
	interface ExternalVariable {
		encode: boolean;
		init_fn: ExternalExpr;
		kind: VariableKind;
		name: string;
		reinitialize: boolean;
		update_fn?: UpdateFn | null;
		value?: string | null;
	}
	interface ExternalExpr {
		body?: string | null;
		headers?: {
			[k: string]: string;
		} | null;
		method?: Method | null;
		selector: string;
		url: string;
	}
	interface QueryVariable {
		encode: boolean;
		init_fn: QueryExpr;
		kind: VariableKind;
		name: string;
		reinitialize: boolean;
		update_fn?: UpdateFn | null;
		value?: string | null;
	}
	interface QueryExpr {
		query: QueryRequestFor_String;
		selector: string;
	}
	interface EditTemplateMsg {
		id: Uint64;
		name?: string | null;
	}
	interface DeleteTemplateMsg {
		id: Uint64;
	}
	interface UpdateConfigMsg {
		fee_collector?: string | null;
		fee_denom?: string | null;
		owner?: string | null;
		template_fee?: Uint128 | null;
	}
	interface InstantiateMsg {
		fee_collector: string;
		fee_denom: string;
		owner: string;
		templates: Template[];
	}
	interface Template {
		executions: Execution[];
		formatted_str: string;
		id: Uint64;
		name: string;
		owner: Addr;
		vars: Variable[];
	}
	type QueryMsg = {
		query_template: QueryTemplateMsg;
	} | {
		query_templates: QueryTemplatesMsg;
	} | {
		query_config: QueryConfigMsg;
	};
	interface QueryTemplateMsg {
		id: Uint64;
	}
	interface QueryTemplatesMsg {
		ids?: Uint64[] | null;
		limit?: number | null;
		name?: string | null;
		owner?: Addr | null;
		start_after?: Uint64 | null;
	}
	interface QueryConfigMsg {
	}
	interface TemplateResponse {
		template: Template;
	}
	interface TemplatesResponse {
		templates: Template[];
	}
}
declare enum TerraEventKind {
	TxSubmitted = 0
}
export type TxSubmittedEvent = {
	kind: TerraEventKind.TxSubmitted;
	payload: {
		txHash: string;
	};
};
export type TerraEventHandler = (event: TerraEvent) => void;
export type TerraEvent = TxSubmittedEvent;
export declare abstract class Wallet {
	lcd: LCDClient;
	chainConfig: LCDClientConfig;
	constructor(lcd: LCDClient, chainConfig: LCDClientConfig);
	abstract submitTx(txOpts: CreateTxOptions, handleEvent: TerraEventHandler): Promise<string>;
	finalizeTx(txHash: string): Promise<TxInfo>;
	tx(txOpts: CreateTxOptions, handleEvent?: TerraEventHandler): Promise<TxInfo>;
}
export declare class TerraTxError extends Error {
	txInfo: TxInfo;
	constructor(txInfo: TxInfo);
}
export type PostResponse = {
	height: string | number;
	raw_log: string;
	txhash: string;
	code?: number | string;
	codespace?: string;
};
export type ConnectedWalletInput = {
	wallet?: ConnectedWalletPayload;
	lcd: LCDClient;
};
export type ConnectedWalletPayload = {
	post: (tx: CreateTxOptions) => Promise<PostResponse>;
};
export declare class ConnectedWallet extends Wallet {
	private wallet?;
	constructor(input: ConnectedWalletInput, chainConfig: LCDClientConfig);
	submitTx(txOpts: CreateTxOptions): Promise<string>;
}
export declare class NativeWallet extends Wallet {
	private wallet;
	constructor(wallet: TerraWallet, chainConfig: LCDClientConfig);
	submitTx(txOpts: CreateTxOptions): Promise<string>;
}
export type WalletLike = {
	connectedWallet: ConnectedWalletInput;
} | TerraWallet;
export declare const wallet: (walletLike: WalletLike, chainConfig: LCDClientConfig) => ConnectedWallet | NativeWallet;
export type ChainName = "terra" | "injective" | "neutron" | "nibiru" | "migaloo";
export type NetworkName = "testnet" | "mainnet";
export interface ContractDefinition {
	codeId: string;
	address: string;
}
export type ContractNames = "warp-controller" | "warp-resolver" | "warp-templates" | "warp-account-tracker";
export type NetworkConfig = {
	[contract in ContractNames]: ContractDefinition;
};
export type Refs = {
	testnet: NetworkConfig;
	mainnet: NetworkConfig;
};
export type ChainMetadata = {
	name: ChainName;
	mainnet: string;
	mainnetConfig: LCDClientConfig;
	testnet: string;
	testnetConfig: LCDClientConfig;
	refs: Refs;
};
export declare const TERRA_CHAIN: ChainMetadata;
export declare const NEUTRON_CHAIN: ChainMetadata;
export declare const INJECTIVE_CHAIN: ChainMetadata;
export declare const NIBIRU_CHAIN: ChainMetadata;
export declare const MIGALOO_CHAIN: ChainMetadata;
export declare const SUPPORTED_CHAINS: ChainMetadata[];
export interface ContractAddresses {
	controller: string;
	resolver: string;
	templates: string;
	accountTracker: string;
}
export declare class ChainModule {
	config: LCDClientConfig;
	metadata: ChainMetadata;
	contracts: ContractAddresses;
	constructor(config: LCDClientConfig);
	static lcdClientConfig(networks?: NetworkName[], chains?: ChainName[]): Record<string, LCDClientConfig>;
	static lcdClient(input?: {
		chains?: ChainName[];
		networks?: NetworkName[];
	}): LCDClient;
	static chainMetadata(chainName: ChainName): ChainMetadata;
	static supportedChains(): ChainMetadata[];
	static chainMetadataFromChainId(chainId: string): ChainMetadata;
	static networkNameFromChainId(chainId: string): NetworkName;
	static contractsFromChainId(chainId: string): NetworkConfig;
	static contractAddress(contract: keyof ContractAddresses, chainId: string): string;
}
export type Execution = {
	condition: warp_resolver.Condition;
	msgs: warp_resolver.WarpMsg[];
};
export type Job = Omit<warp_controller.Job, "executions" | "vars"> & {
	executions: Execution[];
	vars: warp_resolver.Variable[];
};
export type JobResponse = {
	job: Job;
};
export type JobsResponse = {
	total_count: number;
	jobs: Job[];
};
export declare const parseExecution: (execution: warp_controller.Execution) => Execution;
export declare const parseJob: (job: warp_controller.Job) => Job;
export declare const parseJobResponse: (resp: warp_controller.JobResponse) => JobResponse;
export declare const parseJobsResponse: (resp: warp_controller.JobsResponse) => JobsResponse;
export declare class Condition {
	wallet: Wallet;
	contracts: ContractAddresses;
	sdk: WarpSdk;
	constructor(wallet: Wallet, contracts: ContractAddresses, sdk: WarpSdk);
	resolveCond: (cond: warp_resolver.Condition, job: Job) => Promise<boolean>;
	resolveExpr: (expr: warp_resolver.Expr, job: Job) => Promise<boolean>;
	resolveExprTimestamp: (expr: warp_resolver.TimeExpr) => Promise<boolean>;
	resolveExprBlockheight: (expr: warp_resolver.BlockExpr) => Promise<boolean>;
	resolveExprString: (expr: warp_resolver.GenExprFor_StringValueFor_StringAnd_StringOp, job: Job) => Promise<boolean>;
	resolveStringValue: (value: warp_resolver.StringValueFor_String, job: Job) => Promise<string>;
	resolveExprNum: (expr: warp_resolver.GenExprFor_NumValueForInt128And_NumExprOpAnd_IntFnOpAnd_NumOp | warp_resolver.GenExprFor_NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOpAnd_NumOp | warp_resolver.GenExprFor_NumValueFor_Uint256And_NumExprOpAnd_IntFnOpAnd_NumOp, job: Job) => Promise<boolean>;
	resolveNumValue: (value: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp | warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp | warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp, job: Job) => Promise<Big>;
	resolveNumFn(fn: warp_resolver.NumFnValueForInt128And_NumExprOpAnd_IntFnOp | warp_resolver.NumFnValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp | warp_resolver.NumFnValueFor_Uint256And_NumExprOpAnd_IntFnOp, job: Job): Promise<Big>;
	resolveNumExpr(expr: warp_resolver.NumExprValueForInt128And_NumExprOpAnd_IntFnOp | warp_resolver.NumExprValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp | warp_resolver.NumExprValueFor_Uint256And_NumExprOpAnd_IntFnOp, job: Job): Promise<Big>;
	variable(ref: string, job: Job): warp_resolver.Variable;
	resolveExprBool(ref: string, job: Job): Promise<boolean>;
	resolveVariable<T>(variable: warp_resolver.Variable, cast: (val: string) => T): Promise<T>;
	resolveQueryVariable(query: warp_resolver.QueryVariable): Promise<string>;
	resolveStringOp: (left: string, right: string, op: warp_resolver.StringOp) => Promise<boolean>;
	resolveNumOp: (left: Big, right: Big, op: warp_resolver.NumOp) => Promise<boolean>;
}
export declare const contractQuery: <QueryMsg extends {}, QueryResponse>(lcd: LCDClient, contractAddress: string, msg: QueryMsg) => Promise<QueryResponse>;
export type TransferMsg = {
	transfer: {
		recipient: string;
		amount: string;
	};
};
export type TransferNftMsg = {
	transfer_nft: {
		recipient: string;
		token_id: string;
	};
};
export declare const base64encode: (input: any) => string;
export declare function base64decode<T>(value: string): T;
export type TokenBase = {
	key: string;
	name: string;
	symbol: string;
	icon: string;
	decimals: number;
	coinGeckoId?: string;
};
export type NativeToken = TokenBase & {
	type: "native";
	denom: string;
};
export type NominalType<T extends BigSource> = {
	__type: T;
};
export type CW20Addr = string & NominalType<"CW20Addr">;
export type CW20Token = TokenBase & {
	type: "cw20";
	protocol: string;
	token: CW20Addr;
};
export type IBCToken = TokenBase & {
	type: "ibc";
	path: string;
	base_denom: string;
	denom: string;
};
export type Token = NativeToken | CW20Token | IBCToken;
export declare const LUNA: NativeToken;
export declare const NEUTRON: NativeToken;
export declare const INJ: NativeToken;
export declare const NATIVE_TOKENS: {
	LUNA: NativeToken;
	INJ: NativeToken;
	NEUTRON: NativeToken;
};
export declare const nativeTokenDenom: (lcd: LCDClient, chainId: string) => Promise<string>;
export declare function cosmosMsgToCreateTxMsg(sender: string, input: warp_resolver.CosmosMsgFor_Empty): Msg;
export declare function computeCreationFee(queueSize: Big, config: warp_controller.Config): Big;
export declare function computeMaintenanceFee(durationDays: Big, config: warp_controller.Config): Big;
export declare function computeBurnFee(jobReward: Big, config: warp_controller.Config): Big;
export declare function calculateDurationDaysAdjustmentFactor(durationDays: Big): Big;
export declare class TxModule {
	private warpSdk;
	constructor(warpSdk: WarpSdk);
	createJob(sender: string, msg: warp_controller.CreateJobMsg, coins?: Coins.Input): Promise<CreateTxOptions>;
	createJobSequence(sender: string, sequence: warp_controller.CreateJobMsg[], coins?: Coins.Input): Promise<CreateTxOptions>;
	deleteJob(sender: string, jobId: string): Promise<CreateTxOptions>;
	updateJob(sender: string, msg: warp_controller.UpdateJobMsg): Promise<CreateTxOptions>;
	evictJob(sender: string, jobId: string): Promise<CreateTxOptions>;
	executeJob(sender: string, jobId: string): Promise<CreateTxOptions>;
	createFundingAccount(sender: string, funds?: Coins.Input): Promise<CreateTxOptions>;
	submitTemplate(sender: string, msg: warp_templates.SubmitTemplateMsg): Promise<CreateTxOptions>;
	deleteTemplate(sender: string, templateId: string): Promise<CreateTxOptions>;
	executeSimulateQuery(sender: string, msg: warp_resolver.ExecuteSimulateQueryMsg): Promise<CreateTxOptions>;
	executeHydrateVars(sender: string, msg: warp_resolver.ExecuteHydrateVarsMsg): Promise<CreateTxOptions>;
	executeHydrateMsgs(sender: string, msg: warp_resolver.ExecuteHydrateMsgsMsg): Promise<CreateTxOptions>;
	executeValidateJobCreation(sender: string, msg: warp_resolver.ExecuteValidateJobCreationMsg): Promise<CreateTxOptions>;
	executeResolveCondition(sender: string, msg: warp_resolver.ExecuteResolveConditionMsg): Promise<CreateTxOptions>;
	executeApplyVarFn(sender: string, msg: warp_resolver.ExecuteApplyVarFnMsg): Promise<CreateTxOptions>;
	editTemplate(sender: string, msg: warp_templates.EditTemplateMsg): Promise<CreateTxOptions>;
	transferCwToController(sender: string, funds: warp_controller.CwFund[]): Promise<CreateTxOptions>;
	withdrawAssets(sender: string, job_id: string, msg: warp_account.WithdrawAssetsMsg): Promise<CreateTxOptions>;
	depositToAccount(sender: string, account: string, token: Token, amount: string): Promise<CreateTxOptions>;
	withdrawFromAccount(sender: string, account: string, receiver: string, token: Token, amount: string): Promise<CreateTxOptions>;
}
export type EstimateJobMsg = {
	vars: string;
	recurring: boolean;
	executions: warp_controller.Execution[];
	duration_days: string;
};
export declare class WarpSdk {
	wallet: Wallet;
	condition: Condition;
	tx: TxModule;
	chain: ChainModule;
	constructor(walletLike: WalletLike, chainConfig: LCDClientConfig);
	static lcdClientConfig(networks?: NetworkName[], chains?: ChainName[]): Record<string, LCDClientConfig>;
	static lcdClient(input?: {
		chains?: ChainName[];
		networks?: NetworkName[];
	}): LCDClient;
	isJobActive(jobId: string): Promise<boolean>;
	jobs(opts?: warp_controller.QueryJobsMsg): Promise<Job[]>;
	job(id: string): Promise<Job>;
	templates(opts?: warp_templates.QueryTemplatesMsg): Promise<warp_templates.Template[]>;
	template(id: string): Promise<warp_templates.Template>;
	simulateQuery(query: warp_resolver.QueryRequestFor_String): Promise<object>;
	validateJobCreation(msg: warp_resolver.QueryValidateJobCreationMsg): Promise<string>;
	hydrateVars(msg: warp_resolver.QueryHydrateVarsMsg): Promise<string>;
	resolveCondition(msg: warp_resolver.QueryResolveConditionMsg): Promise<boolean>;
	applyVarFn(msg: warp_resolver.QueryApplyVarFnMsg): Promise<string>;
	hydrateMsgs(msg: warp_resolver.QueryHydrateMsgsMsg): Promise<warp_resolver.WarpMsg[]>;
	jobAccounts(msg: warp_account_tracker.QueryJobAccountsMsg): Promise<warp_account_tracker.JobAccountsResponse>;
	firstFreeJobAccount(msg: warp_account_tracker.QueryFirstFreeJobAccountMsg): Promise<warp_account_tracker.JobAccountResponse>;
	firstFreeFundingAccount(msg: warp_account_tracker.QueryFirstFreeJobAccountMsg): Promise<warp_account_tracker.FundingAccountResponse>;
	fundingAccounts(msg: warp_account_tracker.QueryFundingAccountsMsg): Promise<warp_account_tracker.FundingAccountsResponse>;
	config(): Promise<warp_controller.Config & warp_templates.Config>;
	state(): Promise<warp_controller.State>;
	estimateJobFee(sender: string, estimateJobMsg: EstimateJobMsg, reward?: string): Promise<Coin>;
	estimateJobReward(sender: string, estimateJobMsg: EstimateJobMsg): Promise<Coin>;
	estimateJobExecutionReward(sender: string, estimateJobMsg: EstimateJobMsg, execution: warp_controller.Execution): Promise<Coin>;
	nativeTokenDenom(): Promise<string>;
	createJob(sender: string, msg: warp_controller.CreateJobMsg, coins?: Coins.Input): Promise<TxInfo>;
	createJobSequence(sender: string, sequence: warp_controller.CreateJobMsg[], coins?: Coins.Input): Promise<TxInfo>;
	deleteJob(sender: string, jobId: string): Promise<TxInfo>;
	updateJob(sender: string, msg: warp_controller.UpdateJobMsg): Promise<TxInfo>;
	evictJob(sender: string, jobId: string): Promise<TxInfo>;
	executeJob(sender: string, jobId: string): Promise<TxInfo>;
	createFundingAccount(sender: string, funds?: Coins.Input): Promise<TxInfo>;
	submitTemplate(sender: string, msg: warp_templates.SubmitTemplateMsg): Promise<TxInfo>;
	deleteTemplate(sender: string, templateId: string): Promise<TxInfo>;
	editTemplate(sender: string, msg: warp_templates.EditTemplateMsg): Promise<TxInfo>;
	withdrawAssets(sender: string, job_id: string, msg: warp_account.WithdrawAssetsMsg): Promise<TxInfo>;
	depositToAccount(sender: string, account: string, token: Token, amount: string): Promise<TxInfo>;
	withdrawFromAccount(sender: string, account: string, receiver: string, token: Token, amount: string): Promise<TxInfo>;
}
export declare const extractVariableName: (str: string) => string;
export declare const isVariableRef: (input: any) => boolean;
export declare const variableName: (v: warp_resolver.Variable) => string;
export declare const resolveExternalVariable: (external: warp_resolver.ExternalVariable) => Promise<string>;
export declare const resolveExternalInputs: (variables: warp_resolver.Variable[]) => Promise<warp_controller.ExternalInput[]>;
export declare class ConditionComposer {
	and(...conditions: warp_resolver.Condition[]): warp_resolver.Condition;
	or(...conditions: warp_resolver.Condition[]): warp_resolver.Condition;
	not(condition: warp_resolver.Condition): warp_resolver.Condition;
	expr(expression: warp_resolver.Expr): warp_resolver.Condition;
	string(left: warp_resolver.StringValueFor_String, op: warp_resolver.StringOp, right: warp_resolver.StringValueFor_String): warp_resolver.Condition;
	uint(left: warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp, op: warp_resolver.NumOp, right: warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp): warp_resolver.Condition;
	int(left: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp, op: warp_resolver.NumOp, right: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp): warp_resolver.Condition;
	decimal(left: warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp, op: warp_resolver.NumOp, right: warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp): warp_resolver.Condition;
	timestamp(comparator: warp_resolver.Uint64, op: warp_resolver.TimeOp): warp_resolver.Condition;
	block_height(comparator: warp_resolver.Uint64, op: warp_resolver.NumOp): warp_resolver.Condition;
	bool(value: warp_resolver.Variable): warp_resolver.Condition;
}
export declare class UintValueComposer {
	simple(value: string): warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	expr(left: warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp, op: warp_resolver.NumExprOp, right: warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp): warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	ref(ref: warp_resolver.Variable): warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	fn(op: warp_resolver.IntFnOp, right: warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp): warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
	env(env: warp_resolver.NumEnvValue): warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp;
}
export declare class IntValueComposer {
	simple(value: number): warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp;
	expr(left: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp, op: warp_resolver.NumExprOp, right: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp): warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp;
	ref(ref: warp_resolver.Variable): warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp;
	fn(op: warp_resolver.IntFnOp, right: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp): warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp;
	env(env: warp_resolver.NumEnvValue): warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp;
}
export declare class DecimalValueComposer {
	simple(value: string): warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	expr(left: warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp, op: warp_resolver.NumExprOp, right: warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp): warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	ref(ref: warp_resolver.Variable): warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	fn(op: warp_resolver.IntFnOp, right: warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp): warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
	env(env: warp_resolver.NumEnvValue): warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp;
}
export declare class StringValueComposer {
	simple(value: string): warp_resolver.StringValueFor_String;
	ref(ref: warp_resolver.Variable): warp_resolver.StringValueFor_String;
}
export declare class UpdateFnComposer {
	uint(value: warp_resolver.NumValueFor_Uint256And_NumExprOpAnd_IntFnOp): warp_resolver.FnValue;
	int(value: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp): warp_resolver.FnValue;
	decimal(value: warp_resolver.NumValueFor_Decimal256And_NumExprOpAnd_DecimalFnOp): warp_resolver.FnValue;
	timestamp(value: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp): warp_resolver.FnValue;
	block_height(value: warp_resolver.NumValueForInt128And_NumExprOpAnd_IntFnOp): warp_resolver.FnValue;
	bool(value: warp_resolver.Variable): warp_resolver.FnValue;
}
export declare class JobSequenceMsgComposer {
	static new(): JobSequenceMsgComposer;
	sequence: any[];
	chainSequence: (idx: number) => warp_controller.CreateJobMsg;
	chain(msg: warp_controller.CreateJobMsg): JobSequenceMsgComposer;
	compose(): warp_controller.CreateJobMsg;
}
export declare class CreateJobMsgComposer {
	private _name;
	private _recurring;
	private _reward;
	private _description;
	private _labels;
	private _assetsToWithdraw;
	private _vars;
	private _executions;
	private _durationDays;
	private _fundingAccount;
	private _operationalAmount;
	static new(): CreateJobMsgComposer;
	name(name: string): CreateJobMsgComposer;
	recurring(recurring: boolean): CreateJobMsgComposer;
	reward(reward: warp_controller.Uint128): CreateJobMsgComposer;
	description(description: string): CreateJobMsgComposer;
	labels(labels: string[]): CreateJobMsgComposer;
	durationDays(durationDays: string): CreateJobMsgComposer;
	fundingAccount(fundingAccount?: string): CreateJobMsgComposer;
	operationalAmount(operationalAmount: warp_controller.Uint128): CreateJobMsgComposer;
	assetsToWithdraw(assetsToWithdraw: warp_controller.AssetInfo[]): CreateJobMsgComposer;
	executions(executions: Execution[]): CreateJobMsgComposer;
	vars(vars: warp_resolver.Variable[]): CreateJobMsgComposer;
	compose(): warp_controller.CreateJobMsg;
}
export declare class EstimateJobMsgComposer {
	private _recurring;
	private _vars;
	private _executions;
	private _durationDays;
	static new(): EstimateJobMsgComposer;
	recurring(recurring: boolean): EstimateJobMsgComposer;
	durationDays(durationDays: string): EstimateJobMsgComposer;
	executions(executions: Execution[]): EstimateJobMsgComposer;
	vars(vars: warp_resolver.Variable[]): EstimateJobMsgComposer;
	compose(): EstimateJobMsg;
}
export declare class JobComposer {
	create(): CreateJobMsgComposer;
	estimate(): EstimateJobMsgComposer;
}
export declare class MessageComposer {
	send(amount: warp_resolver.Coin[], to_address: string): warp_resolver.WarpMsg;
	burn(amount: warp_resolver.Coin[]): warp_resolver.WarpMsg;
	delegate(amount: warp_resolver.Coin, validator: string): warp_resolver.WarpMsg;
	undelegate(amount: warp_resolver.Coin, validator: string): warp_resolver.WarpMsg;
	redelegate(amount: warp_resolver.Coin, dst_validator: string, src_validator: string): warp_resolver.WarpMsg;
	setWithdrawAddress(address: string): warp_resolver.WarpMsg;
	withdrawDelegatorReward(validator: string): warp_resolver.WarpMsg;
	transfer(amount: warp_resolver.Coin, channel_id: string, timeout: warp_resolver.IbcTimeout, to_address: string): warp_resolver.WarpMsg;
	sendPacket<T>(channel_id: string, data: T, timeout: warp_resolver.IbcTimeout): warp_resolver.WarpMsg;
	closeChannel(channel_id: string): warp_resolver.WarpMsg;
	execute<T>(contract_addr: string, msg: T, funds?: warp_resolver.Coin[]): warp_resolver.WarpMsg;
	instantiate<T>(admin: string | null, code_id: number, label: string, msg: T, funds?: warp_resolver.Coin[]): warp_resolver.WarpMsg;
	migrate<T>(contract_addr: string, msg: T, new_code_id: number): warp_resolver.WarpMsg;
	update_admin(admin: string, contract_addr: string): warp_resolver.WarpMsg;
	clear_admin(contract_addr: string): warp_resolver.WarpMsg;
	vote(proposal_id: number, vote: warp_resolver.VoteOption): warp_resolver.WarpMsg;
	withdrawAssets(msg: warp_resolver.WithdrawAssetsMsg): warp_resolver.WarpMsg;
	ibcTransfer(msg: warp_resolver.IbcTransferMsg): warp_resolver.WarpMsg;
}
export declare class SubmitTemplateMsgComposer {
	private _executions;
	private _formattedStr;
	private _msgs;
	private _name;
	private _vars;
	static new(): SubmitTemplateMsgComposer;
	formattedStr(formattedStr: string): SubmitTemplateMsgComposer;
	name(name: string): SubmitTemplateMsgComposer;
	var(variable: warp_resolver.Variable): SubmitTemplateMsgComposer;
	executions(executions: Execution[]): SubmitTemplateMsgComposer;
	compose(): warp_templates.SubmitTemplateMsg;
}
export declare class TemplateComposer {
	submit(): SubmitTemplateMsgComposer;
}
declare class StaticVariableComposer {
	private variable;
	constructor();
	kind(kind: warp_resolver.VariableKind): StaticVariableComposer;
	name(name: string): StaticVariableComposer;
	value(value: string): StaticVariableComposer;
	encode(value: boolean): StaticVariableComposer;
	reinitialize(value: boolean): StaticVariableComposer;
	onInit(value: warp_resolver.FnValue): StaticVariableComposer;
	onSuccess(fn: warp_resolver.FnValue): StaticVariableComposer;
	onError(fn: warp_resolver.FnValue): StaticVariableComposer;
	compose(): warp_resolver.Variable;
}
declare class ExternalVariableComposer {
	private variable;
	constructor();
	kind(kind: warp_resolver.VariableKind): ExternalVariableComposer;
	name(name: string): ExternalVariableComposer;
	value(value: string): ExternalVariableComposer;
	reinitialize(value: boolean): ExternalVariableComposer;
	encode(value: boolean): ExternalVariableComposer;
	onInit(value: warp_resolver.ExternalExpr): ExternalVariableComposer;
	onSuccess(fn: warp_resolver.FnValue): ExternalVariableComposer;
	onError(fn: warp_resolver.FnValue): ExternalVariableComposer;
	compose(): warp_resolver.Variable;
}
declare class QueryVariableComposer {
	private variable;
	constructor();
	kind(kind: warp_resolver.VariableKind): QueryVariableComposer;
	name(name: string): QueryVariableComposer;
	value(value: string): QueryVariableComposer;
	reinitialize(value: boolean): QueryVariableComposer;
	encode(value: boolean): QueryVariableComposer;
	onInit(value: warp_resolver.QueryExpr): QueryVariableComposer;
	onSuccess(fn: warp_resolver.FnValue): QueryVariableComposer;
	onError(fn: warp_resolver.FnValue): QueryVariableComposer;
	compose(): warp_resolver.Variable;
}
export declare class VariableComposer {
	static(): StaticVariableComposer;
	external(): ExternalVariableComposer;
	query(): QueryVariableComposer;
	ref(v: warp_resolver.Variable): string;
}
declare class TimestampComposer {
	date(date: Date): string;
	seconds(amount: number): string;
	minutes(amount: number): string;
	hours(amount: number): string;
	days(amount: number): string;
}
declare class QueryComposer {
	balance(address: string, denom: string): warp_resolver.QueryRequestFor_String;
	allBalances(address: string): warp_resolver.QueryRequestFor_String;
	bondedDenom(): warp_resolver.QueryRequestFor_String;
	allDelegations(delegator: string): warp_resolver.QueryRequestFor_String;
	delegation(delegator: string, validator: string): warp_resolver.QueryRequestFor_String;
	allValidators(): warp_resolver.QueryRequestFor_String;
	validator(address: string): warp_resolver.QueryRequestFor_String;
	stargate<T extends {}>(data: T, path: string): warp_resolver.QueryRequestFor_String;
	portId(): warp_resolver.QueryRequestFor_String;
	listChannels(port_id?: string | null): warp_resolver.QueryRequestFor_String;
	channel(channel_id: string, port_id?: string | null): warp_resolver.QueryRequestFor_String;
	smart<T extends {}>(contract_addr: string, msg: T): warp_resolver.QueryRequestFor_String;
	raw(contract_addr: string, key: warp_resolver.Binary): warp_resolver.QueryRequestFor_String;
	contractInfo(contract_addr: string): warp_resolver.QueryRequestFor_String;
	custom(customQuery: string): warp_resolver.QueryRequestFor_String;
}
declare class AccountComposer {
	msgs(msgs: warp_resolver.WarpMsg[]): Extract<warp_account.ExecuteMsg, {
		warp_msgs: {};
	}>;
}
export declare const decimal: DecimalValueComposer;
export declare const uint: UintValueComposer;
export declare const int: IntValueComposer;
export declare const string: StringValueComposer;
export declare const cond: ConditionComposer;
export declare const fn: UpdateFnComposer;
export declare const msg: MessageComposer;
export declare const template: TemplateComposer;
export declare const job: JobComposer;
export declare const variable: VariableComposer;
export declare const ts: TimestampComposer;
export declare const query: QueryComposer;
export declare const account: AccountComposer;
export declare const composers: {
	decimal: DecimalValueComposer;
	uint: UintValueComposer;
	int: IntValueComposer;
	string: StringValueComposer;
	cond: ConditionComposer;
	fn: UpdateFnComposer;
	msg: {};
	template: TemplateComposer;
	job: JobComposer;
	variable: VariableComposer;
	ts: TimestampComposer;
	query: QueryComposer;
	account: AccountComposer;
};

export {};
